<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://loopback.io"

    >loopback (v3.6.0)</a>
</h1>
<h4>LoopBack: Open Source Framework for Node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback">module loopback</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.</span>isServer</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.loopback">
            function <span class="apidocSignatureSpan"></span>loopback
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL">
            function <span class="apidocSignatureSpan">loopback.</span>ACL
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_">
            function <span class="apidocSignatureSpan">loopback.</span>ACL.super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken">
            function <span class="apidocSignatureSpan">loopback.</span>AccessToken
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application">
            function <span class="apidocSignatureSpan">loopback.</span>Application
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change">
            function <span class="apidocSignatureSpan">loopback.</span>Change
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict">
            function <span class="apidocSignatureSpan">loopback.</span>Change.Conflict
            <span class="apidocSignatureSpan">(modelId, SourceModel, TargetModel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint">
            function <span class="apidocSignatureSpan">loopback.</span>Checkpoint
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Connector">
            function <span class="apidocSignatureSpan">loopback.</span>Connector
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource">
            function <span class="apidocSignatureSpan">loopback.</span>DataSource
            <span class="apidocSignatureSpan">(name, settings, modelBuilder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Any">
            function <span class="apidocSignatureSpan">loopback.</span>DataSource.Any
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject">
            function <span class="apidocSignatureSpan">loopback.</span>DataSource.DataAccessObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.JSON">
            function <span class="apidocSignatureSpan">loopback.</span>DataSource.JSON
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Text">
            function <span class="apidocSignatureSpan">loopback.</span>DataSource.Text
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email">
            function <span class="apidocSignatureSpan">loopback.</span>Email
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_">
            function <span class="apidocSignatureSpan">loopback.</span>Email.super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.GeoPoint">
            function <span class="apidocSignatureSpan">loopback.</span>GeoPoint
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel">
            function <span class="apidocSignatureSpan">loopback.</span>KeyValueModel
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail">
            function <span class="apidocSignatureSpan">loopback.</span>Mail
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.DataAccessObject">
            function <span class="apidocSignatureSpan">loopback.</span>Mail.prototype.DataAccessObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Memory">
            function <span class="apidocSignatureSpan">loopback.</span>Memory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Remote">
            function <span class="apidocSignatureSpan">loopback.</span>Remote
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role">
            function <span class="apidocSignatureSpan">loopback.</span>Role
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping">
            function <span class="apidocSignatureSpan">loopback.</span>RoleMapping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route">
            function <span class="apidocSignatureSpan">loopback.</span>Route
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router">
            function <span class="apidocSignatureSpan">loopback.</span>Router
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope">
            function <span class="apidocSignatureSpan">loopback.</span>Scope
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User">
            function <span class="apidocSignatureSpan">loopback.</span>User
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ValidationError">
            function <span class="apidocSignatureSpan">loopback.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ValidationError.super_">
            function <span class="apidocSignatureSpan">loopback.</span>ValidationError.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.configureModel">
            function <span class="apidocSignatureSpan">loopback.</span>configureModel
            <span class="apidocSignatureSpan">(ModelCtor, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.context">
            function <span class="apidocSignatureSpan">loopback.</span>context
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.createContext">
            function <span class="apidocSignatureSpan">loopback.</span>createContext
            <span class="apidocSignatureSpan">(scopeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.createDataSource">
            function <span class="apidocSignatureSpan">loopback.</span>createDataSource
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.createModel">
            function <span class="apidocSignatureSpan">loopback.</span>createModel
            <span class="apidocSignatureSpan">(name, properties, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.errorHandler">
            function <span class="apidocSignatureSpan">loopback.</span>errorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.favicon">
            function <span class="apidocSignatureSpan">loopback.</span>favicon
            <span class="apidocSignatureSpan">(icon, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.findModel">
            function <span class="apidocSignatureSpan">loopback.</span>findModel
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.getCurrentContext">
            function <span class="apidocSignatureSpan">loopback.</span>getCurrentContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.getModel">
            function <span class="apidocSignatureSpan">loopback.</span>getModel
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.getModelByType">
            function <span class="apidocSignatureSpan">loopback.</span>getModelByType
            <span class="apidocSignatureSpan">(modelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index">
            function <span class="apidocSignatureSpan">loopback.</span>index
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.memory">
            function <span class="apidocSignatureSpan">loopback.</span>memory
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.query">
            function <span class="apidocSignatureSpan">loopback.</span>query
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.</span>remoteMethod
            <span class="apidocSignatureSpan">(fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.rest">
            function <span class="apidocSignatureSpan">loopback.</span>rest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.runInContext">
            function <span class="apidocSignatureSpan">loopback.</span>runInContext
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.static">
            function <span class="apidocSignatureSpan">loopback.</span>static
            <span class="apidocSignatureSpan">(root, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.status">
            function <span class="apidocSignatureSpan">loopback.</span>status
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.template">
            function <span class="apidocSignatureSpan">loopback.</span>template
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.token">
            function <span class="apidocSignatureSpan">loopback.</span>token
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.urlNotFound">
            function <span class="apidocSignatureSpan">loopback.</span>urlNotFound
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>ACL.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>ACL.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>ACL.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>ACL.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>AccessToken.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>AccessToken.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>AccessToken.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Application.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Application.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Application.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Change.Conflict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Change.getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Change.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Change.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Change.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Checkpoint.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Checkpoint.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Connector.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>DataSource.Any.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>DataSource.DataAccessObject.Transaction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>DataSource.DataAccessObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>DataSource.JSON.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>DataSource.Text.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>DataSource.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Email.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Email.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Email.super_.super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>GeoPoint.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>KeyValueModel.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Mail.mailer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Mail.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Mail.prototype.DataAccessObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Remote.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Role.resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Role.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Role.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>RoleMapping.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>RoleMapping.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>RoleMapping.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Route.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Scope.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>Scope.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>User.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>User.setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>User.settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>User.sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>access_context</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>application</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>registry.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>request</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>response</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.</span>faviconFile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ACL">module loopback.ACL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.ACL">
            function <span class="apidocSignatureSpan">loopback.</span>ACL
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.ValidationError">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL._ACL">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.addListener">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.afterRemote">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.attachTo">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.changes">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.checkAccess">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.checkAccessForContext">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>checkAccessForContext
            <span class="apidocSignatureSpan">(context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.checkAccessForToken">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>checkAccessForToken
            <span class="apidocSignatureSpan">(token, model, modelId, method, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.checkPermission">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>checkPermission
            <span class="apidocSignatureSpan">(principalType, principalId, model, property, accessType, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.checkpoint">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.clearObservers">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.count">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.create">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.createUpdates">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.defineProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.deleteAll">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.deleteById">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.destroyAll">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.destroyById">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.diff">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.emit">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.eventNames">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.exists">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.extend">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.find">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.findById">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.findLastChange">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.findOne">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getApp">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getDataSource">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getIdName">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getMatchingScore">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getMatchingScore
            <span class="apidocSignatureSpan">(rule, req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getSourceId">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.getStaticACLs">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>getStaticACLs
            <span class="apidocSignatureSpan">(model, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.isAllowed">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>isAllowed
            <span class="apidocSignatureSpan">(permission, defaultPermission)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.isMappedToRole">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>isMappedToRole
            <span class="apidocSignatureSpan">(principalType, principalId, role, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.listenerCount">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.listeners">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.mixin">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.observe">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.on">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.once">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.prependListener">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.registerProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.remove">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.removeById">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.removeListener">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.removeObserver">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.replaceById">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.replicate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.resolvePermission">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>resolvePermission
            <span class="apidocSignatureSpan">(acls, req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.resolvePrincipal">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>resolvePrincipal
            <span class="apidocSignatureSpan">(type, id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.resolveRelatedModels">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>resolveRelatedModels
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.setup">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.update">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.updateAll">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.upsert">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validate">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validateAsync">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.</span>sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>ALARM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>ALL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>ALLOW</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>APP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>APPLICATION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>AUDIT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>DEFAULT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>DENY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>EXECUTE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>READ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>REPLICATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>ROLE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>SCOPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>USER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.</span>WRITE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ACL.prototype">module loopback.ACL.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.prototype.debug">
            function <span class="apidocSignatureSpan">loopback.ACL.prototype.</span>debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.prototype.isAllowed">
            function <span class="apidocSignatureSpan">loopback.ACL.prototype.</span>isAllowed
            <span class="apidocSignatureSpan">(defaultPermission)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.prototype.score">
            function <span class="apidocSignatureSpan">loopback.ACL.prototype.</span>score
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ACL.settings">module loopback.ACL.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.ACL.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.ACL.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.settings.base">
            function <span class="apidocSignatureSpan">loopback.ACL.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ACL.sharedClass">module loopback.ACL.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ACL.super_">module loopback.ACL.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.super_">
            function <span class="apidocSignatureSpan">loopback.ACL.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.ValidationError">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_._ACL">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.addListener">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.afterRemote">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.attachTo">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.changes">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.checkAccess">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.checkpoint">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.clearObservers">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.count">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.create">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.createUpdates">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.defineProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.deleteAll">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.deleteById">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.destroyAll">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.destroyById">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.diff">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.emit">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.eventNames">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.exists">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.extend">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.find">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.findById">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.findLastChange">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.findOne">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getApp">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getDataSource">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getIdName">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.getSourceId">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.listenerCount">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.listeners">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.mixin">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.observe">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.on">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.once">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prependListener">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.registerProperty">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.remove">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.removeById">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.removeListener">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.removeObserver">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.replaceById">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.replicate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.setup">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.update">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.updateAll">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.upsert">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validate">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validateAsync">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.ACL.super_.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ACL.super_.prototype">module loopback.ACL.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.delete">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>delete
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.destroy">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>destroy
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.fillCustomChangeProperties">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>fillCustomChangeProperties
            <span class="apidocSignatureSpan">(change, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.getId">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>getId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.getIdName">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.isNewRecord">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>isNewRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.patchAttributes">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>patchAttributes
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.reload">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>reload
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.remove">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>remove
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.replaceAttributes">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>replaceAttributes
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.save">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>save
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.setId">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>setId
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.updateAttribute">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>updateAttribute
            <span class="apidocSignatureSpan">(name, value, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ACL.super_.prototype.updateAttributes">
            function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>updateAttributes
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.AccessToken">module loopback.AccessToken</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.AccessToken">
            function <span class="apidocSignatureSpan">loopback.</span>AccessToken
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.ValidationError">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken._ACL">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.addListener">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.afterRemote">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.attachTo">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.changes">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.checkAccess">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.checkpoint">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.clearObservers">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.count">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.create">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.createAccessTokenId">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createAccessTokenId
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.createUpdates">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.defineProperty">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.deleteAll">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.deleteById">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.destroyAll">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.destroyById">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.diff">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.emit">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.eventNames">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.exists">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.extend">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.find">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.findById">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.findForRequest">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findForRequest
            <span class="apidocSignatureSpan">(req, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.findLastChange">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.findOne">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getApp">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getDataSource">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getIdName">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.getSourceId">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.listenerCount">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.listeners">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.mixin">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.observe">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.on">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.once">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.prependListener">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.registerProperty">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.remove">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.removeById">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.removeListener">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.removeObserver">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.replaceById">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.replicate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.setup">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.super_">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.update">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.updateAll">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.upsert">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validateAsync">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>ANONYMOUS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.AccessToken.prototype">module loopback.AccessToken.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.prototype.validate">
            function <span class="apidocSignatureSpan">loopback.AccessToken.prototype.</span>validate
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.AccessToken.settings">module loopback.AccessToken.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.AccessToken.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.AccessToken.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.settings.base">
            function <span class="apidocSignatureSpan">loopback.AccessToken.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.settings.</span>acls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.settings.</span>relations</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.AccessToken.sharedClass">module loopback.AccessToken.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.AccessToken.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Application">module loopback.Application</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.Application">
            function <span class="apidocSignatureSpan">loopback.</span>Application
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Application.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application._ACL">
            function <span class="apidocSignatureSpan">loopback.Application.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.Application.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Application.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Application.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Application.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.addListener">
            function <span class="apidocSignatureSpan">loopback.Application.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Application.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Application.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.attachTo">
            function <span class="apidocSignatureSpan">loopback.Application.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.authenticate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>authenticate
            <span class="apidocSignatureSpan">(appId, key, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Application.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Application.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.changes">
            function <span class="apidocSignatureSpan">loopback.Application.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Application.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.checkpoint">
            function <span class="apidocSignatureSpan">loopback.Application.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Application.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.count">
            function <span class="apidocSignatureSpan">loopback.Application.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.create">
            function <span class="apidocSignatureSpan">loopback.Application.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.Application.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.Application.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Application.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.createUpdates">
            function <span class="apidocSignatureSpan">loopback.Application.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.Application.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Application.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.deleteAll">
            function <span class="apidocSignatureSpan">loopback.Application.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.deleteById">
            function <span class="apidocSignatureSpan">loopback.Application.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.destroyAll">
            function <span class="apidocSignatureSpan">loopback.Application.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.destroyById">
            function <span class="apidocSignatureSpan">loopback.Application.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.diff">
            function <span class="apidocSignatureSpan">loopback.Application.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Application.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Application.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.emit">
            function <span class="apidocSignatureSpan">loopback.Application.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.Application.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.eventNames">
            function <span class="apidocSignatureSpan">loopback.Application.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.exists">
            function <span class="apidocSignatureSpan">loopback.Application.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.extend">
            function <span class="apidocSignatureSpan">loopback.Application.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.find">
            function <span class="apidocSignatureSpan">loopback.Application.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.findById">
            function <span class="apidocSignatureSpan">loopback.Application.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.findLastChange">
            function <span class="apidocSignatureSpan">loopback.Application.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.findOne">
            function <span class="apidocSignatureSpan">loopback.Application.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Application.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getApp">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getIdName">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.getSourceId">
            function <span class="apidocSignatureSpan">loopback.Application.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.Application.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Application.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Application.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Application.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Application.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Application.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.listeners">
            function <span class="apidocSignatureSpan">loopback.Application.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.mixin">
            function <span class="apidocSignatureSpan">loopback.Application.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Application.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Application.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.observe">
            function <span class="apidocSignatureSpan">loopback.Application.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.on">
            function <span class="apidocSignatureSpan">loopback.Application.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.once">
            function <span class="apidocSignatureSpan">loopback.Application.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.Application.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.prependListener">
            function <span class="apidocSignatureSpan">loopback.Application.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Application.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.Application.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.Application.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.register">
            function <span class="apidocSignatureSpan">loopback.Application.</span>register
            <span class="apidocSignatureSpan">(owner, name, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Application.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Application.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.remove">
            function <span class="apidocSignatureSpan">loopback.Application.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Application.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.removeById">
            function <span class="apidocSignatureSpan">loopback.Application.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.removeListener">
            function <span class="apidocSignatureSpan">loopback.Application.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Application.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.replaceById">
            function <span class="apidocSignatureSpan">loopback.Application.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.replicate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.resetKeys">
            function <span class="apidocSignatureSpan">loopback.Application.</span>resetKeys
            <span class="apidocSignatureSpan">(appId, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Application.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Application.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.setup">
            function <span class="apidocSignatureSpan">loopback.Application.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.Application.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Application.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.super_">
            function <span class="apidocSignatureSpan">loopback.Application.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.update">
            function <span class="apidocSignatureSpan">loopback.Application.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.updateAll">
            function <span class="apidocSignatureSpan">loopback.Application.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.Application.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.upsert">
            function <span class="apidocSignatureSpan">loopback.Application.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.Application.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validate">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Application.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Application.prototype">module loopback.Application.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.prototype.resetKeys">
            function <span class="apidocSignatureSpan">loopback.Application.prototype.</span>resetKeys
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">undefined <span class="apidocSignatureSpan">loopback.Application.prototype.</span>url</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Application.settings">module loopback.Application.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Application.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Application.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.settings.base">
            function <span class="apidocSignatureSpan">loopback.Application.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Application.sharedClass">module loopback.Application.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Application.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change">module loopback.Change</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Change">
            function <span class="apidocSignatureSpan">loopback.</span>Change
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict">
            function <span class="apidocSignatureSpan">loopback.Change.</span>Conflict
            <span class="apidocSignatureSpan">(modelId, SourceModel, TargetModel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Change.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change._ACL">
            function <span class="apidocSignatureSpan">loopback.Change.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.Change.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Change.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Change.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Change.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.addListener">
            function <span class="apidocSignatureSpan">loopback.Change.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Change.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Change.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.attachTo">
            function <span class="apidocSignatureSpan">loopback.Change.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Change.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Change.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.bothDeleted">
            function <span class="apidocSignatureSpan">loopback.Change.</span>bothDeleted
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.changes">
            function <span class="apidocSignatureSpan">loopback.Change.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Change.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.checkpoint">
            function <span class="apidocSignatureSpan">loopback.Change.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Change.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.count">
            function <span class="apidocSignatureSpan">loopback.Change.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.create">
            function <span class="apidocSignatureSpan">loopback.Change.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.Change.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.Change.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Change.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.createUpdates">
            function <span class="apidocSignatureSpan">loopback.Change.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.Change.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Change.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.deleteAll">
            function <span class="apidocSignatureSpan">loopback.Change.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.deleteById">
            function <span class="apidocSignatureSpan">loopback.Change.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.destroyAll">
            function <span class="apidocSignatureSpan">loopback.Change.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.destroyById">
            function <span class="apidocSignatureSpan">loopback.Change.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.diff">
            function <span class="apidocSignatureSpan">loopback.Change.</span>diff
            <span class="apidocSignatureSpan">(modelName, since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Change.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Change.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.emit">
            function <span class="apidocSignatureSpan">loopback.Change.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.Change.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.eventNames">
            function <span class="apidocSignatureSpan">loopback.Change.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.exists">
            function <span class="apidocSignatureSpan">loopback.Change.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.extend">
            function <span class="apidocSignatureSpan">loopback.Change.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.find">
            function <span class="apidocSignatureSpan">loopback.Change.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.findById">
            function <span class="apidocSignatureSpan">loopback.Change.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.findLastChange">
            function <span class="apidocSignatureSpan">loopback.Change.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.findOne">
            function <span class="apidocSignatureSpan">loopback.Change.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.findOrCreateChange">
            function <span class="apidocSignatureSpan">loopback.Change.</span>findOrCreateChange
            <span class="apidocSignatureSpan">(modelName, modelId, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Change.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getApp">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getCheckpointModel">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getCheckpointModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getIdName">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getSourceId">
            function <span class="apidocSignatureSpan">loopback.Change.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.Change.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Change.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Change.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.hash">
            function <span class="apidocSignatureSpan">loopback.Change.</span>hash
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.idForModel">
            function <span class="apidocSignatureSpan">loopback.Change.</span>idForModel
            <span class="apidocSignatureSpan">(modelName, modelId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Change.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Change.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Change.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.listeners">
            function <span class="apidocSignatureSpan">loopback.Change.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.mixin">
            function <span class="apidocSignatureSpan">loopback.Change.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Change.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Change.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.observe">
            function <span class="apidocSignatureSpan">loopback.Change.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.on">
            function <span class="apidocSignatureSpan">loopback.Change.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.once">
            function <span class="apidocSignatureSpan">loopback.Change.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.Change.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prependListener">
            function <span class="apidocSignatureSpan">loopback.Change.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Change.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.rectifyAll">
            function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyAll
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.rectifyModelChanges">
            function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyModelChanges
            <span class="apidocSignatureSpan">(modelName, modelIds, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Change.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Change.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.remove">
            function <span class="apidocSignatureSpan">loopback.Change.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Change.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.removeById">
            function <span class="apidocSignatureSpan">loopback.Change.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.removeListener">
            function <span class="apidocSignatureSpan">loopback.Change.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Change.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.replaceById">
            function <span class="apidocSignatureSpan">loopback.Change.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.replicate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.revisionForInst">
            function <span class="apidocSignatureSpan">loopback.Change.</span>revisionForInst
            <span class="apidocSignatureSpan">(inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Change.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Change.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.setup">
            function <span class="apidocSignatureSpan">loopback.Change.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.Change.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Change.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.super_">
            function <span class="apidocSignatureSpan">loopback.Change.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.update">
            function <span class="apidocSignatureSpan">loopback.Change.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.updateAll">
            function <span class="apidocSignatureSpan">loopback.Change.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.Change.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.upsert">
            function <span class="apidocSignatureSpan">loopback.Change.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.Change.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validate">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Change.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.</span>sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Change.</span>CREATE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Change.</span>DELETE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Change.</span>UNKNOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Change.</span>UPDATE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change.Conflict">module loopback.Change.Conflict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.Conflict">
            function <span class="apidocSignatureSpan">loopback.Change.</span>Conflict
            <span class="apidocSignatureSpan">(modelId, SourceModel, TargetModel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change.Conflict.prototype">module loopback.Change.Conflict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.changes">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>changes
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.models">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>models
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.resolve">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolve
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.resolveManually">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolveManually
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.resolveUsingSource">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolveUsingSource
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.resolveUsingTarget">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolveUsingTarget
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.swapParties">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>swapParties
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.Conflict.prototype.type">
            function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>type
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change.getter">module loopback.Change.getter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.getter.id">
            function <span class="apidocSignatureSpan">loopback.Change.getter.</span>id
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change.prototype">module loopback.Change.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.conflictsWith">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>conflictsWith
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.currentRevision">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>currentRevision
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.debug">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.equals">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>equals
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.getModel">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>getModel
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.getModelCtor">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>getModelCtor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.getModelId">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>getModelId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.isBasedOn">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>isBasedOn
            <span class="apidocSignatureSpan">(change)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.rectify">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>rectify
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.prototype.type">
            function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.prototype.</span>id</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change.settings">module loopback.Change.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Change.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Change.settings.</span>strict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Change.settings.</span>trackChanges</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.settings.base">
            function <span class="apidocSignatureSpan">loopback.Change.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Change.sharedClass">module loopback.Change.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Change.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Checkpoint">module loopback.Checkpoint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.Checkpoint">
            function <span class="apidocSignatureSpan">loopback.</span>Checkpoint
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint._ACL">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint._getSingleton">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_getSingleton
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.addListener">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.attachTo">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.bumpLastSeq">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>bumpLastSeq
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.changes">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.checkpoint">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.count">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.create">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.createUpdates">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.current">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>current
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.deleteAll">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.deleteById">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.destroyAll">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.destroyById">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.diff">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.emit">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.eventNames">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.exists">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.extend">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.find">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.findById">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.findLastChange">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.findOne">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getApp">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getIdName">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.getSourceId">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.listeners">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.mixin">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.observe">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.on">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.once">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.prependListener">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.remove">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.removeById">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.removeListener">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.replaceById">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.replicate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.setup">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.super_">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.update">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.updateAll">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.upsert">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validate">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Checkpoint.settings">module loopback.Checkpoint.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Checkpoint.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Checkpoint.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.settings.base">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Checkpoint.sharedClass">module loopback.Checkpoint.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Checkpoint.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Connector">module loopback.Connector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Connector.Connector">
            function <span class="apidocSignatureSpan">loopback.</span>Connector
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Connector._createJDBAdapter">
            function <span class="apidocSignatureSpan">loopback.Connector.</span>_createJDBAdapter
            <span class="apidocSignatureSpan">(jdbModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Connector.super_">
            function <span class="apidocSignatureSpan">loopback.Connector.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Connector.prototype">module loopback.Connector.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Connector.prototype._addCrudOperationsFromJDBAdapter">
            function <span class="apidocSignatureSpan">loopback.Connector.prototype.</span>_addCrudOperationsFromJDBAdapter
            <span class="apidocSignatureSpan">(connector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource">module loopback.DataSource</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataSource">
            function <span class="apidocSignatureSpan">loopback.</span>DataSource
            <span class="apidocSignatureSpan">(name, settings, modelBuilder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Any">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>Any
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>DataAccessObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.JSON">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>JSON
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Text">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>Text
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource._resolveConnector">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>_resolveConnector
            <span class="apidocSignatureSpan">(name, loader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.super_">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.DataSource.</span>relationTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.Any">module loopback.DataSource.Any</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Any.Any">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>Any
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.Any.prototype">module loopback.DataSource.Any.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Any.prototype.toJSON">
            function <span class="apidocSignatureSpan">loopback.DataSource.Any.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Any.prototype.toObject">
            function <span class="apidocSignatureSpan">loopback.DataSource.Any.prototype.</span>toObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.DataAccessObject">module loopback.DataSource.DataAccessObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.DataAccessObject">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>DataAccessObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>Transaction
            <span class="apidocSignatureSpan">(connector, connection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject._allowExtendedOperators">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_allowExtendedOperators
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject._coerce">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_coerce
            <span class="apidocSignatureSpan">(where, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject._forDB">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_forDB
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject._getSetting">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_getSetting
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject._normalize">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_normalize
            <span class="apidocSignatureSpan">(filter, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.all">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.applyProperties">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>applyProperties
            <span class="apidocSignatureSpan">(data, inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.applyScope">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>applyScope
            <span class="apidocSignatureSpan">(query, inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.beginTransaction">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>beginTransaction
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.belongsTo">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>belongsTo
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.count">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>count
            <span class="apidocSignatureSpan">(where, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.create">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>create
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.defaultScope">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>defaultScope
            <span class="apidocSignatureSpan">(target, inst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.deleteAll">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>deleteAll
            <span class="apidocSignatureSpan">(where, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.deleteById">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>deleteById
            <span class="apidocSignatureSpan">(id, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.destroyAll">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>destroyAll
            <span class="apidocSignatureSpan">(where, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.destroyById">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>destroyById
            <span class="apidocSignatureSpan">(id, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.embedsMany">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>embedsMany
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.embedsOne">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>embedsOne
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.exists">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>exists
            <span class="apidocSignatureSpan">(id, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.find">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>find
            <span class="apidocSignatureSpan">(query, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.findById">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findById
            <span class="apidocSignatureSpan">(id, filter, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.findByIds">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findByIds
            <span class="apidocSignatureSpan">(ids, query, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.findOne">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findOne
            <span class="apidocSignatureSpan">(query, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.getConnector">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>getConnector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.hasAndBelongsToMany">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>hasAndBelongsToMany
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.hasMany">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>hasMany
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.hasOne">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>hasOne
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.include">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>include
            <span class="apidocSignatureSpan">(objects, include, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.lookupModel">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>lookupModel
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.normalizeInclude">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>normalizeInclude
            <span class="apidocSignatureSpan">(include)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.referencesMany">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>referencesMany
            <span class="apidocSignatureSpan">(modelTo, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.remove">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>remove
            <span class="apidocSignatureSpan">(where, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.removeById">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>removeById
            <span class="apidocSignatureSpan">(id, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.replaceById">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.scope">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>scope
            <span class="apidocSignatureSpan">(name, query, targetClass, methods, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.update">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>update
            <span class="apidocSignatureSpan">(where, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.updateAll">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.upsert">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>upsert
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, options, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_mixins</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.DataAccessObject.Transaction.prototype">module loopback.DataSource.DataAccessObject.Transaction.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.clearObservers">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.commit">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>commit
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.observe">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.removeObserver">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.rollback">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>rollback
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.toJSON">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.toString">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>_mixins</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.DataAccessObject.prototype">module loopback.DataSource.DataAccessObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.delete">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>delete
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.destroy">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>destroy
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.getConnector">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>getConnector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.isNewRecord">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>isNewRecord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.patchAttributes">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>patchAttributes
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.reload">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>reload
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.remove">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>remove
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.replaceAttributes">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>replaceAttributes
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.save">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>save
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.setAttribute">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>setAttribute
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.setAttributes">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>setAttributes
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.unsetAttribute">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>unsetAttribute
            <span class="apidocSignatureSpan">(name, nullify)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttribute">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>updateAttribute
            <span class="apidocSignatureSpan">(name, value, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttributes">
            function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>updateAttributes
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.JSON">module loopback.DataSource.JSON</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.JSON.JSON">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>JSON
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.JSON.prototype">module loopback.DataSource.JSON.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.JSON.prototype.toJSON">
            function <span class="apidocSignatureSpan">loopback.DataSource.JSON.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.JSON.prototype.toObject">
            function <span class="apidocSignatureSpan">loopback.DataSource.JSON.prototype.</span>toObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.Text">module loopback.DataSource.Text</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Text.Text">
            function <span class="apidocSignatureSpan">loopback.DataSource.</span>Text
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.Text.prototype">module loopback.DataSource.Text.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Text.prototype.toJSON">
            function <span class="apidocSignatureSpan">loopback.DataSource.Text.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.Text.prototype.toObject">
            function <span class="apidocSignatureSpan">loopback.DataSource.Text.prototype.</span>toObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.DataSource.prototype">module loopback.DataSource.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype._setupConnector">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>_setupConnector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.attach">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>attach
            <span class="apidocSignatureSpan">(modelClass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.automigrate">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>automigrate
            <span class="apidocSignatureSpan">(models, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.autoupdate">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>autoupdate
            <span class="apidocSignatureSpan">(models, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.buildModelFromInstance">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>buildModelFromInstance
            <span class="apidocSignatureSpan">(name, json, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.columnMetadata">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>columnMetadata
            <span class="apidocSignatureSpan">(modelName, propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.columnName">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>columnName
            <span class="apidocSignatureSpan">(modelName, propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.columnNames">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>columnNames
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.connect">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>connect
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.copyModel">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>copyModel
            <span class="apidocSignatureSpan">(Master)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.createModel">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>createModel
            <span class="apidocSignatureSpan">(className, properties, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.define">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>define
            <span class="apidocSignatureSpan">(className, properties, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.defineForeignKey">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineForeignKey
            <span class="apidocSignatureSpan">(className, key, foreignClassName, pkName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.defineOperation">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineOperation
            <span class="apidocSignatureSpan">(name, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.defineProperty">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineProperty
            <span class="apidocSignatureSpan">(model, prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.defineRelations">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineRelations
            <span class="apidocSignatureSpan">(modelClass, relations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.defineScopes">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineScopes
            <span class="apidocSignatureSpan">(modelClass, scopes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.disableRemote">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>disableRemote
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.disconnect">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverAndBuildModels">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverAndBuildModels
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverAndBuildModelsSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverAndBuildModelsSync
            <span class="apidocSignatureSpan">(modelName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverExportedForeignKeys">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverExportedForeignKeys
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverExportedForeignKeysSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverExportedForeignKeysSync
            <span class="apidocSignatureSpan">(modelName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverForeignKeys">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverForeignKeys
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverForeignKeysSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverForeignKeysSync
            <span class="apidocSignatureSpan">(modelName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverModelDefinitions">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelDefinitions
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverModelDefinitionsSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelDefinitionsSync
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverModelProperties">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelProperties
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverModelPropertiesSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelPropertiesSync
            <span class="apidocSignatureSpan">(modelName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverPrimaryKeys">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverPrimaryKeys
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverPrimaryKeysSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverPrimaryKeysSync
            <span class="apidocSignatureSpan">(modelName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverSchema">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverSchema
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverSchemas">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverSchemas
            <span class="apidocSignatureSpan">(modelName, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.discoverSchemasSync">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverSchemasSync
            <span class="apidocSignatureSpan">(modelName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.enableRemote">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>enableRemote
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.freeze">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>freeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.getModel">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getModel
            <span class="apidocSignatureSpan">(name, forceCreate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.getModelDefinition">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getModelDefinition
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.getOperation">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getOperation
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.getTypes">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getTypes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.idColumnName">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idColumnName
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.idName">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idName
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.idNames">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idNames
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.idProperty">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idProperty
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.isActual">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>isActual
            <span class="apidocSignatureSpan">(models, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.isRelational">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>isRelational
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.log">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>log
            <span class="apidocSignatureSpan">(sql, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.mixin">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>mixin
            <span class="apidocSignatureSpan">(ModelCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.operations">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>operations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.ping">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>ping
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.ready">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>ready
            <span class="apidocSignatureSpan">(obj, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.setup">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>setup
            <span class="apidocSignatureSpan">(name, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.setupDataAccess">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>setupDataAccess
            <span class="apidocSignatureSpan">(modelClass, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.supportTypes">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>supportTypes
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.tableName">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>tableName
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.DataSource.prototype.transaction">
            function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>transaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Email">module loopback.Email</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.Email">
            function <span class="apidocSignatureSpan">loopback.</span>Email
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Email.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email._ACL">
            function <span class="apidocSignatureSpan">loopback.Email.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Email.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Email.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Email.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.addListener">
            function <span class="apidocSignatureSpan">loopback.Email.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Email.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Email.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.attachTo">
            function <span class="apidocSignatureSpan">loopback.Email.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Email.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Email.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Email.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Email.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Email.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Email.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Email.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.emit">
            function <span class="apidocSignatureSpan">loopback.Email.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.eventNames">
            function <span class="apidocSignatureSpan">loopback.Email.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.extend">
            function <span class="apidocSignatureSpan">loopback.Email.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Email.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.getApp">
            function <span class="apidocSignatureSpan">loopback.Email.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Email.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Email.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Email.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Email.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Email.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Email.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.listeners">
            function <span class="apidocSignatureSpan">loopback.Email.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.mixin">
            function <span class="apidocSignatureSpan">loopback.Email.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Email.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.observe">
            function <span class="apidocSignatureSpan">loopback.Email.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.on">
            function <span class="apidocSignatureSpan">loopback.Email.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.once">
            function <span class="apidocSignatureSpan">loopback.Email.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.prependListener">
            function <span class="apidocSignatureSpan">loopback.Email.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Email.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Email.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Email.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Email.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.removeListener">
            function <span class="apidocSignatureSpan">loopback.Email.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Email.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.send">
            function <span class="apidocSignatureSpan">loopback.Email.</span>send
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Email.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.setup">
            function <span class="apidocSignatureSpan">loopback.Email.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Email.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_">
            function <span class="apidocSignatureSpan">loopback.Email.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validate">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Email.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Email.prototype">module loopback.Email.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.prototype.send">
            function <span class="apidocSignatureSpan">loopback.Email.prototype.</span>send
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Email.sharedClass">module loopback.Email.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Email.super_">module loopback.Email.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_">
            function <span class="apidocSignatureSpan">loopback.Email.</span>super_
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_._ACL">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.addListener">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.attachTo">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.emit">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.eventNames">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.extend">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.getApp">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.listeners">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.mixin">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.observe">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.on">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.once">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.prependListener">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.removeListener">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.setup">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validate">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Email.super_.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Email.super_.super_.prototype">module loopback.Email.super_.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype._initProperties">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>_initProperties
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.fromObject">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>fromObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.inspect">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>inspect
            <span class="apidocSignatureSpan">(depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.isValid">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>isValid
            <span class="apidocSignatureSpan">(callback, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.reset">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.setStrict">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>setStrict
            <span class="apidocSignatureSpan">(strict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.toJSON">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.toObject">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>toObject
            <span class="apidocSignatureSpan">(onlySchema, removeHidden, removeProtected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Email.super_.super_.prototype.trigger">
            function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>trigger
            <span class="apidocSignatureSpan">(actionName, work, data, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.GeoPoint">module loopback.GeoPoint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.GeoPoint.GeoPoint">
            function <span class="apidocSignatureSpan">loopback.</span>GeoPoint
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.GeoPoint.distanceBetween">
            function <span class="apidocSignatureSpan">loopback.GeoPoint.</span>distanceBetween
            <span class="apidocSignatureSpan">(a, b, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.GeoPoint.prototype">module loopback.GeoPoint.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.GeoPoint.prototype.distanceTo">
            function <span class="apidocSignatureSpan">loopback.GeoPoint.prototype.</span>distanceTo
            <span class="apidocSignatureSpan">(point, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.GeoPoint.prototype.toString">
            function <span class="apidocSignatureSpan">loopback.GeoPoint.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.KeyValueModel">module loopback.KeyValueModel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.KeyValueModel">
            function <span class="apidocSignatureSpan">loopback.</span>KeyValueModel
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.ValidationError">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel._ACL">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.addListener">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.afterRemote">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.attachTo">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.checkAccess">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.clearObservers">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.defineProperty">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.emit">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.eventNames">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.expire">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>expire
            <span class="apidocSignatureSpan">(key, ttl, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.extend">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.get">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>get
            <span class="apidocSignatureSpan">(key, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.getApp">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.getDataSource">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.iterateKeys">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>iterateKeys
            <span class="apidocSignatureSpan">(filter, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.keys">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>keys
            <span class="apidocSignatureSpan">(filter, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.listenerCount">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.listeners">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.mixin">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.observe">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.on">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.once">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.prependListener">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.registerProperty">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.removeListener">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.removeObserver">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.set">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>set
            <span class="apidocSignatureSpan">(key, value, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.setup">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.super_">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.ttl">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>ttl
            <span class="apidocSignatureSpan">(key, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validate">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validateAsync">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.KeyValueModel.sharedClass">module loopback.KeyValueModel.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.KeyValueModel.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Mail">module loopback.Mail</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.Mail">
            function <span class="apidocSignatureSpan">loopback.</span>Mail
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.initialize">
            function <span class="apidocSignatureSpan">loopback.Mail.</span>initialize
            <span class="apidocSignatureSpan">(dataSource, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Mail.</span>mailer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Mail.mailer">module loopback.Mail.mailer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.mailer.createTransport">
            function <span class="apidocSignatureSpan">loopback.Mail.mailer.</span>createTransport
            <span class="apidocSignatureSpan">(transporter, defaults)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Mail.prototype">module loopback.Mail.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.DataAccessObject">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>DataAccessObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.defaultTransport">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>defaultTransport
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.setupTransport">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>setupTransport
            <span class="apidocSignatureSpan">(setting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.transportForName">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>transportForName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>mailer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Mail.prototype.DataAccessObject">module loopback.Mail.prototype.DataAccessObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.DataAccessObject.DataAccessObject">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>DataAccessObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.DataAccessObject.send">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.DataAccessObject.</span>send
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Mail.prototype.DataAccessObject.</span>mailer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Mail.prototype.DataAccessObject.prototype">module loopback.Mail.prototype.DataAccessObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Mail.prototype.DataAccessObject.prototype.send">
            function <span class="apidocSignatureSpan">loopback.Mail.prototype.DataAccessObject.prototype.</span>send
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Mail.prototype.DataAccessObject.prototype.</span>mailer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Memory">module loopback.Memory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Memory.Memory">
            function <span class="apidocSignatureSpan">loopback.</span>Memory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Memory.initialize">
            function <span class="apidocSignatureSpan">loopback.Memory.</span>initialize
            <span class="apidocSignatureSpan">(dataSource, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Memory.super_">
            function <span class="apidocSignatureSpan">loopback.Memory.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Remote">module loopback.Remote</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Remote.Remote">
            function <span class="apidocSignatureSpan">loopback.</span>Remote
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Remote.initialize">
            function <span class="apidocSignatureSpan">loopback.Remote.</span>initialize
            <span class="apidocSignatureSpan">(dataSource, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Remote.prototype">module loopback.Remote.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Remote.prototype.connect">
            function <span class="apidocSignatureSpan">loopback.Remote.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Remote.prototype.define">
            function <span class="apidocSignatureSpan">loopback.Remote.prototype.</span>define
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Remote.prototype.resolve">
            function <span class="apidocSignatureSpan">loopback.Remote.prototype.</span>resolve
            <span class="apidocSignatureSpan">(Model)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Role">module loopback.Role</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.Role">
            function <span class="apidocSignatureSpan">loopback.</span>Role
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Role.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role._ACL">
            function <span class="apidocSignatureSpan">loopback.Role.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.Role.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Role.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Role.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Role.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.addListener">
            function <span class="apidocSignatureSpan">loopback.Role.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Role.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Role.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.attachTo">
            function <span class="apidocSignatureSpan">loopback.Role.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Role.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Role.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.changes">
            function <span class="apidocSignatureSpan">loopback.Role.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Role.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.checkpoint">
            function <span class="apidocSignatureSpan">loopback.Role.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Role.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.count">
            function <span class="apidocSignatureSpan">loopback.Role.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.create">
            function <span class="apidocSignatureSpan">loopback.Role.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.Role.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.Role.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Role.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.createUpdates">
            function <span class="apidocSignatureSpan">loopback.Role.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.Role.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Role.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.deleteAll">
            function <span class="apidocSignatureSpan">loopback.Role.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.deleteById">
            function <span class="apidocSignatureSpan">loopback.Role.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.destroyAll">
            function <span class="apidocSignatureSpan">loopback.Role.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.destroyById">
            function <span class="apidocSignatureSpan">loopback.Role.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.diff">
            function <span class="apidocSignatureSpan">loopback.Role.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Role.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Role.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.emit">
            function <span class="apidocSignatureSpan">loopback.Role.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.Role.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.eventNames">
            function <span class="apidocSignatureSpan">loopback.Role.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.exists">
            function <span class="apidocSignatureSpan">loopback.Role.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.extend">
            function <span class="apidocSignatureSpan">loopback.Role.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.find">
            function <span class="apidocSignatureSpan">loopback.Role.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.findById">
            function <span class="apidocSignatureSpan">loopback.Role.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.findLastChange">
            function <span class="apidocSignatureSpan">loopback.Role.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.findOne">
            function <span class="apidocSignatureSpan">loopback.Role.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Role.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getApp">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getIdName">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getRoles">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getRoles
            <span class="apidocSignatureSpan">(context, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.getSourceId">
            function <span class="apidocSignatureSpan">loopback.Role.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.Role.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Role.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Role.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.isAuthenticated">
            function <span class="apidocSignatureSpan">loopback.Role.</span>isAuthenticated
            <span class="apidocSignatureSpan">(context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Role.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.isInRole">
            function <span class="apidocSignatureSpan">loopback.Role.</span>isInRole
            <span class="apidocSignatureSpan">(role, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.isOwner">
            function <span class="apidocSignatureSpan">loopback.Role.</span>isOwner
            <span class="apidocSignatureSpan">(modelClass, modelId, userId, principalType, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Role.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Role.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.listeners">
            function <span class="apidocSignatureSpan">loopback.Role.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.mixin">
            function <span class="apidocSignatureSpan">loopback.Role.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Role.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Role.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.observe">
            function <span class="apidocSignatureSpan">loopback.Role.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.on">
            function <span class="apidocSignatureSpan">loopback.Role.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.once">
            function <span class="apidocSignatureSpan">loopback.Role.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.Role.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.prependListener">
            function <span class="apidocSignatureSpan">loopback.Role.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Role.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.Role.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.Role.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Role.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.registerResolver">
            function <span class="apidocSignatureSpan">loopback.Role.</span>registerResolver
            <span class="apidocSignatureSpan">(role, resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Role.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.remove">
            function <span class="apidocSignatureSpan">loopback.Role.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Role.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.removeById">
            function <span class="apidocSignatureSpan">loopback.Role.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.removeListener">
            function <span class="apidocSignatureSpan">loopback.Role.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Role.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.replaceById">
            function <span class="apidocSignatureSpan">loopback.Role.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.replicate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.resolveRelatedModels">
            function <span class="apidocSignatureSpan">loopback.Role.</span>resolveRelatedModels
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Role.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Role.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.setup">
            function <span class="apidocSignatureSpan">loopback.Role.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.Role.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Role.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.super_">
            function <span class="apidocSignatureSpan">loopback.Role.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.update">
            function <span class="apidocSignatureSpan">loopback.Role.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.updateAll">
            function <span class="apidocSignatureSpan">loopback.Role.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.Role.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.upsert">
            function <span class="apidocSignatureSpan">loopback.Role.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.Role.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validate">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Role.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.</span>sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Role.</span>AUTHENTICATED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Role.</span>EVERYONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Role.</span>OWNER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Role.</span>RELATED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Role.</span>UNAUTHENTICATED</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Role.resolvers">module loopback.Role.resolvers</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Role.settings">module loopback.Role.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Role.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Role.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.settings.base">
            function <span class="apidocSignatureSpan">loopback.Role.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.settings.</span>relations</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Role.sharedClass">module loopback.Role.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Role.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.RoleMapping">module loopback.RoleMapping</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.RoleMapping">
            function <span class="apidocSignatureSpan">loopback.</span>RoleMapping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.ValidationError">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping._ACL">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.addListener">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.afterRemote">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.attachTo">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.changes">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.checkAccess">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.checkpoint">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.clearObservers">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.count">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.create">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.createUpdates">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.defineProperty">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.deleteAll">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.deleteById">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.destroyAll">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.destroyById">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.diff">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.emit">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.eventNames">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.exists">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.extend">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.find">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.findById">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.findLastChange">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.findOne">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getApp">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getDataSource">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getIdName">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.getSourceId">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.listenerCount">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.listeners">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.mixin">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.observe">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.on">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.once">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.prependListener">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.registerProperty">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.remove">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.removeById">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.removeListener">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.removeObserver">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.replaceById">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.replicate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.resolveRelatedModels">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>resolveRelatedModels
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.setup">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.super_">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.update">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.updateAll">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.upsert">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validate">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validateAsync">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.</span>sharedClass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.RoleMapping.</span>APP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.RoleMapping.</span>APPLICATION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.RoleMapping.</span>ROLE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.RoleMapping.</span>USER</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.RoleMapping.prototype">module loopback.RoleMapping.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.prototype.application">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.prototype.</span>application
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.prototype.childRole">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.prototype.</span>childRole
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.prototype.user">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.prototype.</span>user
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.RoleMapping.settings">module loopback.RoleMapping.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.RoleMapping.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.RoleMapping.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.settings.base">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.settings.</span>relations</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.RoleMapping.settings.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.RoleMapping.sharedClass">module loopback.RoleMapping.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.RoleMapping.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Route">module loopback.Route</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.Route">
            function <span class="apidocSignatureSpan">loopback.</span>Route
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Route.prototype">module loopback.Route.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype._handles_method">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>_handles_method
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype._options">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>_options
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.acl">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>acl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.all">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.bind">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>bind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.checkout">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>checkout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.connect">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.copy">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.delete">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>delete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.dispatch">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(req, res, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.get">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.head">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>head
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.link">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>link
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.lock">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>lock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.m-search">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>m-search
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.merge">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.mkactivity">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>mkactivity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.mkcalendar">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>mkcalendar
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.mkcol">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>mkcol
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.move">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>move
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.notify">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>notify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.options">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>options
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.patch">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>patch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.post">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>post
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.propfind">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>propfind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.proppatch">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>proppatch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.purge">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>purge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.put">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>put
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.rebind">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>rebind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.report">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>report
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.search">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>search
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.subscribe">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>subscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.trace">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>trace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.unbind">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unbind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.unlink">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unlink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.unlock">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Route.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Router">module loopback.Router</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.Router">
            function <span class="apidocSignatureSpan">loopback.</span>Router
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.acl">
            function <span class="apidocSignatureSpan">loopback.Router.</span>acl
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.all">
            function <span class="apidocSignatureSpan">loopback.Router.</span>all
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.bind">
            function <span class="apidocSignatureSpan">loopback.Router.</span>bind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.checkout">
            function <span class="apidocSignatureSpan">loopback.Router.</span>checkout
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.connect">
            function <span class="apidocSignatureSpan">loopback.Router.</span>connect
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.copy">
            function <span class="apidocSignatureSpan">loopback.Router.</span>copy
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.delete">
            function <span class="apidocSignatureSpan">loopback.Router.</span>delete
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.get">
            function <span class="apidocSignatureSpan">loopback.Router.</span>get
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.handle">
            function <span class="apidocSignatureSpan">loopback.Router.</span>handle
            <span class="apidocSignatureSpan">(req, res, out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.head">
            function <span class="apidocSignatureSpan">loopback.Router.</span>head
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.link">
            function <span class="apidocSignatureSpan">loopback.Router.</span>link
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.lock">
            function <span class="apidocSignatureSpan">loopback.Router.</span>lock
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.m-search">
            function <span class="apidocSignatureSpan">loopback.Router.</span>m-search
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.merge">
            function <span class="apidocSignatureSpan">loopback.Router.</span>merge
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.mkactivity">
            function <span class="apidocSignatureSpan">loopback.Router.</span>mkactivity
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.mkcalendar">
            function <span class="apidocSignatureSpan">loopback.Router.</span>mkcalendar
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.mkcol">
            function <span class="apidocSignatureSpan">loopback.Router.</span>mkcol
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.move">
            function <span class="apidocSignatureSpan">loopback.Router.</span>move
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.notify">
            function <span class="apidocSignatureSpan">loopback.Router.</span>notify
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.options">
            function <span class="apidocSignatureSpan">loopback.Router.</span>options
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.param">
            function <span class="apidocSignatureSpan">loopback.Router.</span>param
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.patch">
            function <span class="apidocSignatureSpan">loopback.Router.</span>patch
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.post">
            function <span class="apidocSignatureSpan">loopback.Router.</span>post
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.process_params">
            function <span class="apidocSignatureSpan">loopback.Router.</span>process_params
            <span class="apidocSignatureSpan">(layer, called, req, res, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.propfind">
            function <span class="apidocSignatureSpan">loopback.Router.</span>propfind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.proppatch">
            function <span class="apidocSignatureSpan">loopback.Router.</span>proppatch
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.purge">
            function <span class="apidocSignatureSpan">loopback.Router.</span>purge
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.put">
            function <span class="apidocSignatureSpan">loopback.Router.</span>put
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.rebind">
            function <span class="apidocSignatureSpan">loopback.Router.</span>rebind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.report">
            function <span class="apidocSignatureSpan">loopback.Router.</span>report
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.route">
            function <span class="apidocSignatureSpan">loopback.Router.</span>route
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.search">
            function <span class="apidocSignatureSpan">loopback.Router.</span>search
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.subscribe">
            function <span class="apidocSignatureSpan">loopback.Router.</span>subscribe
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.trace">
            function <span class="apidocSignatureSpan">loopback.Router.</span>trace
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.unbind">
            function <span class="apidocSignatureSpan">loopback.Router.</span>unbind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.unlink">
            function <span class="apidocSignatureSpan">loopback.Router.</span>unlink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.unlock">
            function <span class="apidocSignatureSpan">loopback.Router.</span>unlock
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.unsubscribe">
            function <span class="apidocSignatureSpan">loopback.Router.</span>unsubscribe
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Router.use">
            function <span class="apidocSignatureSpan">loopback.Router.</span>use
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Scope">module loopback.Scope</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.Scope">
            function <span class="apidocSignatureSpan">loopback.</span>Scope
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.ValidationError">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope._ACL">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.addListener">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.afterRemote">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.attachTo">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.changes">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.checkAccess">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.checkPermission">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>checkPermission
            <span class="apidocSignatureSpan">(scope, model, property, accessType, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.checkpoint">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.clearObservers">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.count">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.create">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.createUpdates">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.defineProperty">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.deleteAll">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.deleteById">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.destroyAll">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.destroyById">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.diff">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.emit">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.eventNames">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.exists">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.extend">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.find">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.findById">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.findLastChange">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.findOne">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getApp">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getDataSource">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getIdName">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.getSourceId">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.listenerCount">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.listeners">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.mixin">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.observe">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.on">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.once">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.prependListener">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.registerProperty">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.remove">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.removeById">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.removeListener">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.removeObserver">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.replaceById">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.replicate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.resolveRelatedModels">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>resolveRelatedModels
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.setup">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.super_">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.update">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.updateAll">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.upsert">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validate">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validateAsync">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Scope.settings">module loopback.Scope.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Scope.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.Scope.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.settings.base">
            function <span class="apidocSignatureSpan">loopback.Scope.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.settings.</span>description</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.Scope.sharedClass">module loopback.Scope.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.Scope.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.User">module loopback.User</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.User">
            function <span class="apidocSignatureSpan">loopback.</span>User
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.ValidationError">
            function <span class="apidocSignatureSpan">loopback.User.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User._ACL">
            function <span class="apidocSignatureSpan">loopback.User.</span>_ACL
            <span class="apidocSignatureSpan">(ACL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User._defineChangeModel">
            function <span class="apidocSignatureSpan">loopback.User.</span>_defineChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User._getAccessTypeForMethod">
            function <span class="apidocSignatureSpan">loopback.User.</span>_getAccessTypeForMethod
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User._invalidateAccessTokensOfUsers">
            function <span class="apidocSignatureSpan">loopback.User.</span>_invalidateAccessTokensOfUsers
            <span class="apidocSignatureSpan">(userIds, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User._notifyBaseObservers">
            function <span class="apidocSignatureSpan">loopback.User.</span>_notifyBaseObservers
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User._runWhenAttachedToApp">
            function <span class="apidocSignatureSpan">loopback.User.</span>_runWhenAttachedToApp
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.accessToken">
            function <span class="apidocSignatureSpan">loopback.User.</span>accessToken
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.addListener">
            function <span class="apidocSignatureSpan">loopback.User.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.afterRemote">
            function <span class="apidocSignatureSpan">loopback.User.</span>afterRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.afterRemoteError">
            function <span class="apidocSignatureSpan">loopback.User.</span>afterRemoteError
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.attachTo">
            function <span class="apidocSignatureSpan">loopback.User.</span>attachTo
            <span class="apidocSignatureSpan">(dataSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.beforeRemote">
            function <span class="apidocSignatureSpan">loopback.User.</span>beforeRemote
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.belongsToRemoting">
            function <span class="apidocSignatureSpan">loopback.User.</span>belongsToRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.bulkUpdate">
            function <span class="apidocSignatureSpan">loopback.User.</span>bulkUpdate
            <span class="apidocSignatureSpan">(updates, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.changePassword">
            function <span class="apidocSignatureSpan">loopback.User.</span>changePassword
            <span class="apidocSignatureSpan">(userId, oldPassword, newPassword, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.changes">
            function <span class="apidocSignatureSpan">loopback.User.</span>changes
            <span class="apidocSignatureSpan">(since, filter, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.checkAccess">
            function <span class="apidocSignatureSpan">loopback.User.</span>checkAccess
            <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.checkpoint">
            function <span class="apidocSignatureSpan">loopback.User.</span>checkpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.clearObservers">
            function <span class="apidocSignatureSpan">loopback.User.</span>clearObservers
            <span class="apidocSignatureSpan">(operation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.confirm">
            function <span class="apidocSignatureSpan">loopback.User.</span>confirm
            <span class="apidocSignatureSpan">(uid, token, redirect, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.count">
            function <span class="apidocSignatureSpan">loopback.User.</span>count
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.create">
            function <span class="apidocSignatureSpan">loopback.User.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.createChangeFilter">
            function <span class="apidocSignatureSpan">loopback.User.</span>createChangeFilter
            <span class="apidocSignatureSpan">(since, modelFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.createChangeStream">
            function <span class="apidocSignatureSpan">loopback.User.</span>createChangeStream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.createOptionsFromRemotingContext">
            function <span class="apidocSignatureSpan">loopback.User.</span>createOptionsFromRemotingContext
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.createUpdates">
            function <span class="apidocSignatureSpan">loopback.User.</span>createUpdates
            <span class="apidocSignatureSpan">(deltas, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.currentCheckpoint">
            function <span class="apidocSignatureSpan">loopback.User.</span>currentCheckpoint
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.defineProperty">
            function <span class="apidocSignatureSpan">loopback.User.</span>defineProperty
            <span class="apidocSignatureSpan">(prop, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.deleteAll">
            function <span class="apidocSignatureSpan">loopback.User.</span>deleteAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.deleteById">
            function <span class="apidocSignatureSpan">loopback.User.</span>deleteById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.destroyAll">
            function <span class="apidocSignatureSpan">loopback.User.</span>destroyAll
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.destroyById">
            function <span class="apidocSignatureSpan">loopback.User.</span>destroyById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.diff">
            function <span class="apidocSignatureSpan">loopback.User.</span>diff
            <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.disableRemoteMethod">
            function <span class="apidocSignatureSpan">loopback.User.</span>disableRemoteMethod
            <span class="apidocSignatureSpan">(name, isStatic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.disableRemoteMethodByName">
            function <span class="apidocSignatureSpan">loopback.User.</span>disableRemoteMethodByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.email">
            function <span class="apidocSignatureSpan">loopback.User.</span>email
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.emit">
            function <span class="apidocSignatureSpan">loopback.User.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.enableChangeTracking">
            function <span class="apidocSignatureSpan">loopback.User.</span>enableChangeTracking
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.eventNames">
            function <span class="apidocSignatureSpan">loopback.User.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.exists">
            function <span class="apidocSignatureSpan">loopback.User.</span>exists
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.extend">
            function <span class="apidocSignatureSpan">loopback.User.</span>extend
            <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.find">
            function <span class="apidocSignatureSpan">loopback.User.</span>find
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.findById">
            function <span class="apidocSignatureSpan">loopback.User.</span>findById
            <span class="apidocSignatureSpan">(id, filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.findLastChange">
            function <span class="apidocSignatureSpan">loopback.User.</span>findLastChange
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.findOne">
            function <span class="apidocSignatureSpan">loopback.User.</span>findOne
            <span class="apidocSignatureSpan">(filter, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.findOrCreate">
            function <span class="apidocSignatureSpan">loopback.User.</span>findOrCreate
            <span class="apidocSignatureSpan">(query, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.forEachProperty">
            function <span class="apidocSignatureSpan">loopback.User.</span>forEachProperty
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.generateVerificationToken">
            function <span class="apidocSignatureSpan">loopback.User.</span>generateVerificationToken
            <span class="apidocSignatureSpan">(user, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getApp">
            function <span class="apidocSignatureSpan">loopback.User.</span>getApp
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getChangeModel">
            function <span class="apidocSignatureSpan">loopback.User.</span>getChangeModel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getDataSource">
            function <span class="apidocSignatureSpan">loopback.User.</span>getDataSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getIdName">
            function <span class="apidocSignatureSpan">loopback.User.</span>getIdName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getMaxListeners">
            function <span class="apidocSignatureSpan">loopback.User.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getPropertyType">
            function <span class="apidocSignatureSpan">loopback.User.</span>getPropertyType
            <span class="apidocSignatureSpan">(propName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.getSourceId">
            function <span class="apidocSignatureSpan">loopback.User.</span>getSourceId
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.handleChangeError">
            function <span class="apidocSignatureSpan">loopback.User.</span>handleChangeError
            <span class="apidocSignatureSpan">(err, operationName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.hasManyRemoting">
            function <span class="apidocSignatureSpan">loopback.User.</span>hasManyRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.hasOneRemoting">
            function <span class="apidocSignatureSpan">loopback.User.</span>hasOneRemoting
            <span class="apidocSignatureSpan">(relationName, relation, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.hashPassword">
            function <span class="apidocSignatureSpan">loopback.User.</span>hashPassword
            <span class="apidocSignatureSpan">(plain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.isHiddenProperty">
            function <span class="apidocSignatureSpan">loopback.User.</span>isHiddenProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.isProtectedProperty">
            function <span class="apidocSignatureSpan">loopback.User.</span>isProtectedProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.listenerCount">
            function <span class="apidocSignatureSpan">loopback.User.</span>listenerCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.listeners">
            function <span class="apidocSignatureSpan">loopback.User.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.login">
            function <span class="apidocSignatureSpan">loopback.User.</span>login
            <span class="apidocSignatureSpan">(credentials, include, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.logout">
            function <span class="apidocSignatureSpan">loopback.User.</span>logout
            <span class="apidocSignatureSpan">(tokenId, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.mixin">
            function <span class="apidocSignatureSpan">loopback.User.</span>mixin
            <span class="apidocSignatureSpan">(anotherClass, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.nestRemoting">
            function <span class="apidocSignatureSpan">loopback.User.</span>nestRemoting
            <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.normalizeCredentials">
            function <span class="apidocSignatureSpan">loopback.User.</span>normalizeCredentials
            <span class="apidocSignatureSpan">(credentials, realmRequired, realmDelimiter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.notifyObserversAround">
            function <span class="apidocSignatureSpan">loopback.User.</span>notifyObserversAround
            <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.notifyObserversOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>notifyObserversOf
            <span class="apidocSignatureSpan">(operation, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.observe">
            function <span class="apidocSignatureSpan">loopback.User.</span>observe
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.on">
            function <span class="apidocSignatureSpan">loopback.User.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.once">
            function <span class="apidocSignatureSpan">loopback.User.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.patchOrCreate">
            function <span class="apidocSignatureSpan">loopback.User.</span>patchOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.patchOrCreateWithWhere">
            function <span class="apidocSignatureSpan">loopback.User.</span>patchOrCreateWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.prependListener">
            function <span class="apidocSignatureSpan">loopback.User.</span>prependListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.prependOnceListener">
            function <span class="apidocSignatureSpan">loopback.User.</span>prependOnceListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.rectifyAllChanges">
            function <span class="apidocSignatureSpan">loopback.User.</span>rectifyAllChanges
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.rectifyChange">
            function <span class="apidocSignatureSpan">loopback.User.</span>rectifyChange
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.registerProperty">
            function <span class="apidocSignatureSpan">loopback.User.</span>registerProperty
            <span class="apidocSignatureSpan">(propertyName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.User.</span>remoteMethod
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.remove">
            function <span class="apidocSignatureSpan">loopback.User.</span>remove
            <span class="apidocSignatureSpan">(where, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.removeAllListeners">
            function <span class="apidocSignatureSpan">loopback.User.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.removeById">
            function <span class="apidocSignatureSpan">loopback.User.</span>removeById
            <span class="apidocSignatureSpan">(id, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.removeListener">
            function <span class="apidocSignatureSpan">loopback.User.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.removeObserver">
            function <span class="apidocSignatureSpan">loopback.User.</span>removeObserver
            <span class="apidocSignatureSpan">(operation, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.replaceById">
            function <span class="apidocSignatureSpan">loopback.User.</span>replaceById
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.replaceOrCreate">
            function <span class="apidocSignatureSpan">loopback.User.</span>replaceOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.replicate">
            function <span class="apidocSignatureSpan">loopback.User.</span>replicate
            <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.resetPassword">
            function <span class="apidocSignatureSpan">loopback.User.</span>resetPassword
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.scopeRemoting">
            function <span class="apidocSignatureSpan">loopback.User.</span>scopeRemoting
            <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.setMaxListeners">
            function <span class="apidocSignatureSpan">loopback.User.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.setup">
            function <span class="apidocSignatureSpan">loopback.User.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.setupRemoting">
            function <span class="apidocSignatureSpan">loopback.User.</span>setupRemoting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.sharedCtor">
            function <span class="apidocSignatureSpan">loopback.User.</span>sharedCtor
            <span class="apidocSignatureSpan">(data, id, options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.super_">
            function <span class="apidocSignatureSpan">loopback.User.</span>super_
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.update">
            function <span class="apidocSignatureSpan">loopback.User.</span>update
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.updateAll">
            function <span class="apidocSignatureSpan">loopback.User.</span>updateAll
            <span class="apidocSignatureSpan">(where, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.updateLastChange">
            function <span class="apidocSignatureSpan">loopback.User.</span>updateLastChange
            <span class="apidocSignatureSpan">(id, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.updateOrCreate">
            function <span class="apidocSignatureSpan">loopback.User.</span>updateOrCreate
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.upsert">
            function <span class="apidocSignatureSpan">loopback.User.</span>upsert
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.upsertWithWhere">
            function <span class="apidocSignatureSpan">loopback.User.</span>upsertWithWhere
            <span class="apidocSignatureSpan">(where, data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validate">
            function <span class="apidocSignatureSpan">loopback.User.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validateAsync">
            function <span class="apidocSignatureSpan">loopback.User.</span>validateAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatePassword">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatePassword
            <span class="apidocSignatureSpan">(plain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesAbsenceOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesAbsenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesExclusionOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesExclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesFormatOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesFormatOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesInclusionOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesInclusionOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesLengthOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesLengthOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesNumericalityOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesNumericalityOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesPresenceOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesPresenceOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.validatesUniquenessOf">
            function <span class="apidocSignatureSpan">loopback.User.</span>validatesUniquenessOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>afterCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>afterDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>afterInitialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>afterSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>afterUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>afterValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>beforeCreate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>beforeDestroy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>beforeSave</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>beforeUpdate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>beforeValidate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>definition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>getter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>setter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>settings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.</span>sharedClass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.User.prototype">module loopback.User.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.prototype.changePassword">
            function <span class="apidocSignatureSpan">loopback.User.prototype.</span>changePassword
            <span class="apidocSignatureSpan">(oldPassword, newPassword, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.prototype.createAccessToken">
            function <span class="apidocSignatureSpan">loopback.User.prototype.</span>createAccessToken
            <span class="apidocSignatureSpan">(ttl, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.prototype.hasPassword">
            function <span class="apidocSignatureSpan">loopback.User.prototype.</span>hasPassword
            <span class="apidocSignatureSpan">(plain, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.prototype.verify">
            function <span class="apidocSignatureSpan">loopback.User.prototype.</span>verify
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.User.setter">module loopback.User.setter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.setter.email">
            function <span class="apidocSignatureSpan">loopback.User.setter.</span>email
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.setter.password">
            function <span class="apidocSignatureSpan">loopback.User.setter.</span>password
            <span class="apidocSignatureSpan">(plain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.User.settings">module loopback.User.settings</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.User.settings.</span>caseSensitiveEmail</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.User.settings.</span>replaceOnPUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.User.settings.</span>strict</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.settings.base">
            function <span class="apidocSignatureSpan">loopback.User.settings.</span>base
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">loopback.User.settings.</span>maxTTL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">loopback.User.settings.</span>ttl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.settings.</span>acls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.settings.</span>hidden</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.settings.</span>relations</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.User.sharedClass">module loopback.User.sharedClass</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.User.sharedClass.ctor">
            function <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>ctor
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>_disabledMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>_methods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>_resolvers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>sharedCtor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ValidationError">module loopback.ValidationError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ValidationError.ValidationError">
            function <span class="apidocSignatureSpan">loopback.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ValidationError.super_">
            function <span class="apidocSignatureSpan">loopback.ValidationError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">loopback.ValidationError.</span>maxPropertyStringLength</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.ValidationError.super_">module loopback.ValidationError.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ValidationError.super_.super_">
            function <span class="apidocSignatureSpan">loopback.ValidationError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.ValidationError.super_.captureStackTrace">
            function <span class="apidocSignatureSpan">loopback.ValidationError.super_.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">loopback.ValidationError.super_.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.access_context">module loopback.access_context</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.access_context.AccessContext">
            function <span class="apidocSignatureSpan">loopback.access_context.</span>AccessContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.access_context.AccessRequest">
            function <span class="apidocSignatureSpan">loopback.access_context.</span>AccessRequest
            <span class="apidocSignatureSpan">(model, property, accessType, permission, methodNames, registry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.access_context.Principal">
            function <span class="apidocSignatureSpan">loopback.access_context.</span>Principal
            <span class="apidocSignatureSpan">(type, id, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.application">module loopback.application</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.acl">
            function <span class="apidocSignatureSpan">loopback.application.</span>acl
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.all">
            function <span class="apidocSignatureSpan">loopback.application.</span>all
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.bind">
            function <span class="apidocSignatureSpan">loopback.application.</span>bind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.checkout">
            function <span class="apidocSignatureSpan">loopback.application.</span>checkout
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.connect">
            function <span class="apidocSignatureSpan">loopback.application.</span>connect
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.copy">
            function <span class="apidocSignatureSpan">loopback.application.</span>copy
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.defaultConfiguration">
            function <span class="apidocSignatureSpan">loopback.application.</span>defaultConfiguration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.del">
            function <span class="apidocSignatureSpan">loopback.application.</span>del
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.delete">
            function <span class="apidocSignatureSpan">loopback.application.</span>delete
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.disable">
            function <span class="apidocSignatureSpan">loopback.application.</span>disable
            <span class="apidocSignatureSpan">(setting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.disabled">
            function <span class="apidocSignatureSpan">loopback.application.</span>disabled
            <span class="apidocSignatureSpan">(setting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.enable">
            function <span class="apidocSignatureSpan">loopback.application.</span>enable
            <span class="apidocSignatureSpan">(setting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.enabled">
            function <span class="apidocSignatureSpan">loopback.application.</span>enabled
            <span class="apidocSignatureSpan">(setting)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.engine">
            function <span class="apidocSignatureSpan">loopback.application.</span>engine
            <span class="apidocSignatureSpan">(ext, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.get">
            function <span class="apidocSignatureSpan">loopback.application.</span>get
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.handle">
            function <span class="apidocSignatureSpan">loopback.application.</span>handle
            <span class="apidocSignatureSpan">(req, res, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.head">
            function <span class="apidocSignatureSpan">loopback.application.</span>head
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.init">
            function <span class="apidocSignatureSpan">loopback.application.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.lazyrouter">
            function <span class="apidocSignatureSpan">loopback.application.</span>lazyrouter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.link">
            function <span class="apidocSignatureSpan">loopback.application.</span>link
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.listen">
            function <span class="apidocSignatureSpan">loopback.application.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.lock">
            function <span class="apidocSignatureSpan">loopback.application.</span>lock
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.m-search">
            function <span class="apidocSignatureSpan">loopback.application.</span>m-search
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.merge">
            function <span class="apidocSignatureSpan">loopback.application.</span>merge
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.mkactivity">
            function <span class="apidocSignatureSpan">loopback.application.</span>mkactivity
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.mkcalendar">
            function <span class="apidocSignatureSpan">loopback.application.</span>mkcalendar
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.mkcol">
            function <span class="apidocSignatureSpan">loopback.application.</span>mkcol
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.move">
            function <span class="apidocSignatureSpan">loopback.application.</span>move
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.notify">
            function <span class="apidocSignatureSpan">loopback.application.</span>notify
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.options">
            function <span class="apidocSignatureSpan">loopback.application.</span>options
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.param">
            function <span class="apidocSignatureSpan">loopback.application.</span>param
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.patch">
            function <span class="apidocSignatureSpan">loopback.application.</span>patch
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.path">
            function <span class="apidocSignatureSpan">loopback.application.</span>path
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.post">
            function <span class="apidocSignatureSpan">loopback.application.</span>post
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.propfind">
            function <span class="apidocSignatureSpan">loopback.application.</span>propfind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.proppatch">
            function <span class="apidocSignatureSpan">loopback.application.</span>proppatch
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.purge">
            function <span class="apidocSignatureSpan">loopback.application.</span>purge
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.put">
            function <span class="apidocSignatureSpan">loopback.application.</span>put
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.rebind">
            function <span class="apidocSignatureSpan">loopback.application.</span>rebind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.render">
            function <span class="apidocSignatureSpan">loopback.application.</span>render
            <span class="apidocSignatureSpan">(name, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.report">
            function <span class="apidocSignatureSpan">loopback.application.</span>report
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.route">
            function <span class="apidocSignatureSpan">loopback.application.</span>route
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.search">
            function <span class="apidocSignatureSpan">loopback.application.</span>search
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.set">
            function <span class="apidocSignatureSpan">loopback.application.</span>set
            <span class="apidocSignatureSpan">(setting, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.subscribe">
            function <span class="apidocSignatureSpan">loopback.application.</span>subscribe
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.trace">
            function <span class="apidocSignatureSpan">loopback.application.</span>trace
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.unbind">
            function <span class="apidocSignatureSpan">loopback.application.</span>unbind
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.unlink">
            function <span class="apidocSignatureSpan">loopback.application.</span>unlink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.unlock">
            function <span class="apidocSignatureSpan">loopback.application.</span>unlock
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.unsubscribe">
            function <span class="apidocSignatureSpan">loopback.application.</span>unsubscribe
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.application.use">
            function <span class="apidocSignatureSpan">loopback.application.</span>use
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.index">module loopback.index</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.index.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">loopback.index.</span>isServer</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.index">
            function <span class="apidocSignatureSpan">loopback.</span>index
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.ACL">
            function <span class="apidocSignatureSpan">loopback.index.</span>ACL
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.AccessToken">
            function <span class="apidocSignatureSpan">loopback.index.</span>AccessToken
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Application">
            function <span class="apidocSignatureSpan">loopback.index.</span>Application
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Change">
            function <span class="apidocSignatureSpan">loopback.index.</span>Change
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Checkpoint">
            function <span class="apidocSignatureSpan">loopback.index.</span>Checkpoint
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Connector">
            function <span class="apidocSignatureSpan">loopback.index.</span>Connector
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.DataSource">
            function <span class="apidocSignatureSpan">loopback.index.</span>DataSource
            <span class="apidocSignatureSpan">(name, settings, modelBuilder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Email">
            function <span class="apidocSignatureSpan">loopback.index.</span>Email
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.GeoPoint">
            function <span class="apidocSignatureSpan">loopback.index.</span>GeoPoint
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.KeyValueModel">
            function <span class="apidocSignatureSpan">loopback.index.</span>KeyValueModel
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Mail">
            function <span class="apidocSignatureSpan">loopback.index.</span>Mail
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Memory">
            function <span class="apidocSignatureSpan">loopback.index.</span>Memory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Remote">
            function <span class="apidocSignatureSpan">loopback.index.</span>Remote
            <span class="apidocSignatureSpan">(settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Role">
            function <span class="apidocSignatureSpan">loopback.index.</span>Role
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.RoleMapping">
            function <span class="apidocSignatureSpan">loopback.index.</span>RoleMapping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Route">
            function <span class="apidocSignatureSpan">loopback.index.</span>Route
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Router">
            function <span class="apidocSignatureSpan">loopback.index.</span>Router
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.Scope">
            function <span class="apidocSignatureSpan">loopback.index.</span>Scope
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.User">
            function <span class="apidocSignatureSpan">loopback.index.</span>User
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.ValidationError">
            function <span class="apidocSignatureSpan">loopback.index.</span>ValidationError
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.configureModel">
            function <span class="apidocSignatureSpan">loopback.index.</span>configureModel
            <span class="apidocSignatureSpan">(ModelCtor, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.context">
            function <span class="apidocSignatureSpan">loopback.index.</span>context
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.createContext">
            function <span class="apidocSignatureSpan">loopback.index.</span>createContext
            <span class="apidocSignatureSpan">(scopeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.createDataSource">
            function <span class="apidocSignatureSpan">loopback.index.</span>createDataSource
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.createModel">
            function <span class="apidocSignatureSpan">loopback.index.</span>createModel
            <span class="apidocSignatureSpan">(name, properties, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.errorHandler">
            function <span class="apidocSignatureSpan">loopback.index.</span>errorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.favicon">
            function <span class="apidocSignatureSpan">loopback.index.</span>favicon
            <span class="apidocSignatureSpan">(icon, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.findModel">
            function <span class="apidocSignatureSpan">loopback.index.</span>findModel
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.getCurrentContext">
            function <span class="apidocSignatureSpan">loopback.index.</span>getCurrentContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.getModel">
            function <span class="apidocSignatureSpan">loopback.index.</span>getModel
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.getModelByType">
            function <span class="apidocSignatureSpan">loopback.index.</span>getModelByType
            <span class="apidocSignatureSpan">(modelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.memory">
            function <span class="apidocSignatureSpan">loopback.index.</span>memory
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.query">
            function <span class="apidocSignatureSpan">loopback.index.</span>query
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.remoteMethod">
            function <span class="apidocSignatureSpan">loopback.index.</span>remoteMethod
            <span class="apidocSignatureSpan">(fn, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.rest">
            function <span class="apidocSignatureSpan">loopback.index.</span>rest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.runInContext">
            function <span class="apidocSignatureSpan">loopback.index.</span>runInContext
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.static">
            function <span class="apidocSignatureSpan">loopback.index.</span>static
            <span class="apidocSignatureSpan">(root, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.status">
            function <span class="apidocSignatureSpan">loopback.index.</span>status
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.template">
            function <span class="apidocSignatureSpan">loopback.index.</span>template
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.token">
            function <span class="apidocSignatureSpan">loopback.index.</span>token
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.index.urlNotFound">
            function <span class="apidocSignatureSpan">loopback.index.</span>urlNotFound
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.index.</span>application</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.index.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.index.</span>request</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">loopback.index.</span>response</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.index.</span>faviconFile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">loopback.index.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.registry">module loopback.registry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.registry">
            function <span class="apidocSignatureSpan">loopback.</span>registry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.registry.prototype">module loopback.registry.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype._defineRemoteMethods">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>_defineRemoteMethods
            <span class="apidocSignatureSpan">(ModelCtor, methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.configureModel">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>configureModel
            <span class="apidocSignatureSpan">(ModelCtor, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.createDataSource">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>createDataSource
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.createModel">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>createModel
            <span class="apidocSignatureSpan">(name, properties, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.findModel">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>findModel
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.getModel">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>getModel
            <span class="apidocSignatureSpan">(modelName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.getModelByType">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>getModelByType
            <span class="apidocSignatureSpan">(modelType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.registry.prototype.memory">
            function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>memory
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.request">module loopback.request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.accepts">
            function <span class="apidocSignatureSpan">loopback.request.</span>accepts
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.acceptsCharset">
            function <span class="apidocSignatureSpan">loopback.request.</span>acceptsCharset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.acceptsCharsets">
            function <span class="apidocSignatureSpan">loopback.request.</span>acceptsCharsets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.acceptsEncoding">
            function <span class="apidocSignatureSpan">loopback.request.</span>acceptsEncoding
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.acceptsEncodings">
            function <span class="apidocSignatureSpan">loopback.request.</span>acceptsEncodings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.acceptsLanguage">
            function <span class="apidocSignatureSpan">loopback.request.</span>acceptsLanguage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.acceptsLanguages">
            function <span class="apidocSignatureSpan">loopback.request.</span>acceptsLanguages
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.get">
            function <span class="apidocSignatureSpan">loopback.request.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.header">
            function <span class="apidocSignatureSpan">loopback.request.</span>header
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.is">
            function <span class="apidocSignatureSpan">loopback.request.</span>is
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.param">
            function <span class="apidocSignatureSpan">loopback.request.</span>param
            <span class="apidocSignatureSpan">(name, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.request.range">
            function <span class="apidocSignatureSpan">loopback.request.</span>range
            <span class="apidocSignatureSpan">(size, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.response">module loopback.response</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.append">
            function <span class="apidocSignatureSpan">loopback.response.</span>append
            <span class="apidocSignatureSpan">(field, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.attachment">
            function <span class="apidocSignatureSpan">loopback.response.</span>attachment
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.clearCookie">
            function <span class="apidocSignatureSpan">loopback.response.</span>clearCookie
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.contentType">
            function <span class="apidocSignatureSpan">loopback.response.</span>contentType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.cookie">
            function <span class="apidocSignatureSpan">loopback.response.</span>cookie
            <span class="apidocSignatureSpan">(name, value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.download">
            function <span class="apidocSignatureSpan">loopback.response.</span>download
            <span class="apidocSignatureSpan">(path, filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.format">
            function <span class="apidocSignatureSpan">loopback.response.</span>format
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.get">
            function <span class="apidocSignatureSpan">loopback.response.</span>get
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.header">
            function <span class="apidocSignatureSpan">loopback.response.</span>header
            <span class="apidocSignatureSpan">(field, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.json">
            function <span class="apidocSignatureSpan">loopback.response.</span>json
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.jsonp">
            function <span class="apidocSignatureSpan">loopback.response.</span>jsonp
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.links">
            function <span class="apidocSignatureSpan">loopback.response.</span>links
            <span class="apidocSignatureSpan">(links)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.location">
            function <span class="apidocSignatureSpan">loopback.response.</span>location
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.redirect">
            function <span class="apidocSignatureSpan">loopback.response.</span>redirect
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.render">
            function <span class="apidocSignatureSpan">loopback.response.</span>render
            <span class="apidocSignatureSpan">(view, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.send">
            function <span class="apidocSignatureSpan">loopback.response.</span>send
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.sendFile">
            function <span class="apidocSignatureSpan">loopback.response.</span>sendFile
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.sendStatus">
            function <span class="apidocSignatureSpan">loopback.response.</span>sendStatus
            <span class="apidocSignatureSpan">(statusCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.sendfile">
            function <span class="apidocSignatureSpan">loopback.response.</span>sendfile
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.set">
            function <span class="apidocSignatureSpan">loopback.response.</span>set
            <span class="apidocSignatureSpan">(field, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.status">
            function <span class="apidocSignatureSpan">loopback.response.</span>status
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.type">
            function <span class="apidocSignatureSpan">loopback.response.</span>type
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.response.vary">
            function <span class="apidocSignatureSpan">loopback.response.</span>vary
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.loopback.utils">module loopback.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.utils.concatResults">
            function <span class="apidocSignatureSpan">loopback.utils.</span>concatResults
            <span class="apidocSignatureSpan">(previousResults, currentResults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.utils.createPromiseCallback">
            function <span class="apidocSignatureSpan">loopback.utils.</span>createPromiseCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.utils.downloadInChunks">
            function <span class="apidocSignatureSpan">loopback.utils.</span>downloadInChunks
            <span class="apidocSignatureSpan">(filter, chunkSize, processFunction, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.loopback.utils.uploadInChunks">
            function <span class="apidocSignatureSpan">loopback.utils.</span>uploadInChunks
            <span class="apidocSignatureSpan">(largeArray, chunkSize, processFunction, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback" id="apidoc.module.loopback">module loopback</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.loopback" id="apidoc.element.loopback.loopback">
        function <span class="apidocSignatureSpan"></span>loopback
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createApplication(options) {
  var app = loopbackExpress();

  merge(app, proto);

  app.loopback = loopback;

  // Create a new instance of models registry per each app instance
  app.models = function() {
    return proto.models.apply(this, arguments);
  };

  // Create a new instance of datasources registry per each app instance
  app.datasources = app.dataSources = {};

  // Create a new instance of connector registry per each app instance
  app.connectors = {};

  // Register built-in connectors. It&#x27;s important to keep this code
  // hand-written, so that all require() calls are static
  // and thus browserify can process them (include connectors in the bundle)
  app.connector(&#x27;memory&#x27;, loopback.Memory);
  app.connector(&#x27;remote&#x27;, loopback.Remote);
  app.connector(&#x27;kv-memory&#x27;,
    require(&#x27;loopback-datasource-juggler/lib/connectors/kv-memory&#x27;));

  if (loopback.localRegistry || options &#x26;&#x26; options.localRegistry === true) {
    // setup the app registry
    var registry = app.registry = new Registry();
    if (options &#x26;&#x26; options.loadBuiltinModels === true) {
      require(&#x27;./builtin-models&#x27;)(registry);
    }
  } else {
    app.registry = loopback.registry;
  }

  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL" id="apidoc.element.loopback.ACL">
        function <span class="apidocSignatureSpan">loopback.</span>ACL
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_" id="apidoc.element.loopback.ACL.super_">
        function <span class="apidocSignatureSpan">loopback.</span>ACL.super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken" id="apidoc.element.loopback.AccessToken">
        function <span class="apidocSignatureSpan">loopback.</span>AccessToken
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application" id="apidoc.element.loopback.Application">
        function <span class="apidocSignatureSpan">loopback.</span>Application
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change" id="apidoc.element.loopback.Change">
        function <span class="apidocSignatureSpan">loopback.</span>Change
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict" id="apidoc.element.loopback.Change.Conflict">
        function <span class="apidocSignatureSpan">loopback.</span>Change.Conflict
        <span class="apidocSignatureSpan">(modelId, SourceModel, TargetModel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Conflict(modelId, SourceModel, TargetModel) {
  this.SourceModel = SourceModel;
  this.TargetModel = TargetModel;
  this.SourceChange = SourceModel.getChangeModel();
  this.TargetChange = TargetModel.getChangeModel();
  this.modelId = modelId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint" id="apidoc.element.loopback.Checkpoint">
        function <span class="apidocSignatureSpan">loopback.</span>Checkpoint
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Connector" id="apidoc.element.loopback.Connector">
        function <span class="apidocSignatureSpan">loopback.</span>Connector
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connector(options) {
  EventEmitter.apply(this, arguments);
  this.options = options;

  debug(&#x27;created with options&#x27;, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource" id="apidoc.element.loopback.DataSource">
        function <span class="apidocSignatureSpan">loopback.</span>DataSource
        <span class="apidocSignatureSpan">(name, settings, modelBuilder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataSource(name, settings, modelBuilder) {
  if (!(this instanceof DataSource)) {
    return new DataSource(name, settings);
  }

  // Check if the settings object is passed as the first argument
  if (typeof name === &#x27;object&#x27; &#x26;&#x26; settings === undefined) {
    settings = name;
    name = undefined;
  }

  // Check if the first argument is a URL
  if (typeof name === &#x27;string&#x27; &#x26;&#x26; name.indexOf(&#x27;://&#x27;) !== -1) {
    name = utils.parseSettings(name);
  }

  // Check if the settings is in the form of URL string
  if (typeof settings === &#x27;string&#x27; &#x26;&#x26; settings.indexOf(&#x27;://&#x27;) !== -1) {
    settings = utils.parseSettings(settings);
  }

  this.modelBuilder = modelBuilder || new ModelBuilder();
  this.models = this.modelBuilder.models;
  this.definitions = this.modelBuilder.definitions;
  this.juggler = juggler;

  // operation metadata
  // Initialize it before calling setup as the connector might register operations
  this._operations = {};

  this.setup(name, settings);

  this._setupConnector();

  // connector
  var connector = this.connector;

  // DataAccessObject - connector defined or supply the default
  var dao = (connector &#x26;&#x26; connector.DataAccessObject) || this.constructor.DataAccessObject;
  this.DataAccessObject = function() {
  };

  // define DataAccessObject methods
  Object.keys(dao).forEach(function(name) {
    var fn = dao[name];
    this.DataAccessObject[name] = fn;

    if (typeof fn === &#x27;function&#x27;) {
      this.defineOperation(name, {
        accepts: fn.accepts,
        &#x27;returns&#x27;: fn.returns,
        http: fn.http,
        remoteEnabled: fn.shared ? true : false,
        scope: this.DataAccessObject,
        fnName: name,
      });
    }
  }.bind(this));

  // define DataAccessObject.prototype methods
  Object.keys(dao.prototype).forEach(function(name) {
    var fn = dao.prototype[name];
    this.DataAccessObject.prototype[name] = fn;
    if (typeof fn === &#x27;function&#x27;) {
      this.defineOperation(name, {
        prototype: true,
        accepts: fn.accepts,
        &#x27;returns&#x27;: fn.returns,
        http: fn.http,
        remoteEnabled: fn.shared ? true : false,
        scope: this.DataAccessObject.prototype,
        fnName: name,
      });
    }
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.Any" id="apidoc.element.loopback.DataSource.Any">
        function <span class="apidocSignatureSpan">loopback.</span>DataSource.Any
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Any(value) {
  if (!(this instanceof Any)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject" id="apidoc.element.loopback.DataSource.DataAccessObject">
        function <span class="apidocSignatureSpan">loopback.</span>DataSource.DataAccessObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataAccessObject() {
  if (DataAccessObject._mixins) {
    var self = this;
    var args = arguments;
    DataAccessObject._mixins.forEach(function(m) {
      m.call(self, args);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.JSON" id="apidoc.element.loopback.DataSource.JSON">
        function <span class="apidocSignatureSpan">loopback.</span>DataSource.JSON
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSON(value) {
  if (!(this instanceof JSON)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.Text" id="apidoc.element.loopback.DataSource.Text">
        function <span class="apidocSignatureSpan">loopback.</span>DataSource.Text
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(value) {
  if (!(this instanceof Text)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email" id="apidoc.element.loopback.Email">
        function <span class="apidocSignatureSpan">loopback.</span>Email
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_" id="apidoc.element.loopback.Email.super_">
        function <span class="apidocSignatureSpan">loopback.</span>Email.super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.GeoPoint" id="apidoc.element.loopback.GeoPoint">
        function <span class="apidocSignatureSpan">loopback.</span>GeoPoint
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GeoPoint(data) {
  if (!(this instanceof GeoPoint)) {
    return new GeoPoint(data);
  }

  if (arguments.length === 2) {
    data = {
      lat: arguments[0],
      lng: arguments[1],
    };
  }

  assert(Array.isArray(data) || typeof data === &#x27;object&#x27; || typeof data === &#x27;string&#x27;,
    &#x27;must provide valid geo-coordinates array [lat, lng] or object or a &#x22;lat, lng&#x22; string&#x27;);

  if (typeof data === &#x27;string&#x27;) {
    try {
      data = JSON.parse(data);
    } catch (err) {
      data = data.split(/,\s*/);
      assert(data.length === 2, &#x27;must provide a string &#x22;lat,lng&#x22; creating a GeoPoint with a string&#x27;);
    }
  }
  if (Array.isArray(data)) {
    data = {
      lat: Number(data[0]),
      lng: Number(data[1]),
    };
  } else {
    data.lng = Number(data.lng);
    data.lat = Number(data.lat);
  }

  assert(typeof data === &#x27;object&#x27;, &#x27;must provide a lat and lng object when creating a GeoPoint&#x27;);
  assert(typeof data.lat === &#x27;number&#x27; &#x26;&#x26; !isNaN(data.lat), &#x27;lat must be a number when creating a GeoPoint&#x27;);
  assert(typeof data.lng === &#x27;number&#x27; &#x26;&#x26; !isNaN(data.lng), &#x27;lng must be a number when creating a GeoPoint&#x27;);
  assert(data.lng &#x3c;= 180, &#x27;lng must be &#x3c;= 180&#x27;);
  assert(data.lng &#x3e;= -180, &#x27;lng must be &#x3e;= -180&#x27;);
  assert(data.lat &#x3c;= 90, &#x27;lat must be &#x3c;= 90&#x27;);
  assert(data.lat &#x3e;= -90, &#x27;lat must be &#x3e;= -90&#x27;);

  this.lat = data.lat;
  this.lng = data.lng;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel" id="apidoc.element.loopback.KeyValueModel">
        function <span class="apidocSignatureSpan">loopback.</span>KeyValueModel
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail" id="apidoc.element.loopback.Mail">
        function <span class="apidocSignatureSpan">loopback.</span>Mail
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MailConnector(settings) {
  assert(typeof settings === &#x27;object&#x27;, &#x27;cannot initialize MailConnector without a settings object&#x27;);

  var transports = settings.transports;

  // if transports is not in settings object AND settings.transport exists
  if (!transports &#x26;&#x26; settings.transport) {
    // then wrap single transport in an array and assign to transports
    transports = [settings.transport];
  }

  if (!transports) {
    transports = [];
  }

  this.transportsIndex = {};
  this.transports = [];

  if (loopback.isServer) {
    transports.forEach(this.setupTransport.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.DataAccessObject" id="apidoc.element.loopback.Mail.prototype.DataAccessObject">
        function <span class="apidocSignatureSpan">loopback.</span>Mail.prototype.DataAccessObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mailer() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Memory" id="apidoc.element.loopback.Memory">
        function <span class="apidocSignatureSpan">loopback.</span>Memory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Memory() {
  // TODO implement entire memory connector
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Remote" id="apidoc.element.loopback.Remote">
        function <span class="apidocSignatureSpan">loopback.</span>Remote
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RemoteConnector(settings) {
  assert(typeof settings ===
    &#x27;object&#x27;,
    &#x27;cannot initiaze RemoteConnector without a settings object&#x27;);
  this.client = settings.client;
  this.adapter = settings.adapter || &#x27;rest&#x27;;
  this.protocol = settings.protocol || &#x27;http&#x27;;
  this.root = settings.root || &#x27;&#x27;;
  this.host = settings.host || &#x27;localhost&#x27;;
  this.port = settings.port || 3000;
  this.remotes = remoting.create();
  this.name = &#x27;remote-connector&#x27;;

  if (settings.url) {
    this.url = settings.url;
  } else {
    this.url = this.protocol + &#x27;://&#x27; + this.host + &#x27;:&#x27; + this.port + this.root;
  }

  // handle mixins in the define() method
  var DAO = this.DataAccessObject = function() {
  };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role" id="apidoc.element.loopback.Role">
        function <span class="apidocSignatureSpan">loopback.</span>Role
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping" id="apidoc.element.loopback.RoleMapping">
        function <span class="apidocSignatureSpan">loopback.</span>RoleMapping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route" id="apidoc.element.loopback.Route">
        function <span class="apidocSignatureSpan">loopback.</span>Route
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Route(path) {
  this.path = path;
  this.stack = [];

  debug(&#x27;new %o&#x27;, path)

  // route handlers for various http methods
  this.methods = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router" id="apidoc.element.loopback.Router">
        function <span class="apidocSignatureSpan">loopback.</span>Router
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope" id="apidoc.element.loopback.Scope">
        function <span class="apidocSignatureSpan">loopback.</span>Scope
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User" id="apidoc.element.loopback.User">
        function <span class="apidocSignatureSpan">loopback.</span>User
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ValidationError" id="apidoc.element.loopback.ValidationError">
        function <span class="apidocSignatureSpan">loopback.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ValidationError.super_" id="apidoc.element.loopback.ValidationError.super_">
        function <span class="apidocSignatureSpan">loopback.</span>ValidationError.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.configureModel" id="apidoc.element.loopback.configureModel">
        function <span class="apidocSignatureSpan">loopback.</span>configureModel
        <span class="apidocSignatureSpan">(ModelCtor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configureModel = function (ModelCtor, config) {
  return this.registry.configureModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

config = extend({}, config);
config.dataSource = dataSource;

setSharedMethodSharedProperties(ModelCtor, app, config);

app.registry.<span class="apidocCodeKeywordSpan">configureModel</span>(ModelCtor, config);
}

function setSharedMethodSharedProperties(model, app, modelConfigs) {
var settings = {};

// apply config.json settings
var config = app.get(&#x27;remoting&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.context" id="apidoc.element.loopback.context">
        function <span class="apidocSignatureSpan">loopback.</span>context
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function () {
  throw new Error(g.f(
    &#x27;%s middleware was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback#context&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.createContext" id="apidoc.element.loopback.createContext">
        function <span class="apidocSignatureSpan">loopback.</span>createContext
        <span class="apidocSignatureSpan">(scopeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContext = function (scopeName) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.createContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      &#x27;loopback.runInContext()&#x27;,
      &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
  };

  loopback.createContext = function(scopeName) {
    throw new Error(g.f(
      &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
      &#x27;loopback.<span class="apidocCodeKeywordSpan">createContext</span>()&#x27;,
      &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.createDataSource" id="apidoc.element.loopback.createDataSource">
        function <span class="apidocSignatureSpan">loopback.</span>createDataSource
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDataSource = function (name, options) {
  return this.registry.createDataSource.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      config.connector = require(connectorPath);
    }
  }
  if (config.connector &#x26;&#x26; typeof config.connector === &#x27;object&#x27; &#x26;&#x26; !config.connector.name)
    config.connector.name = name;
}

return registry.<span class="apidocCodeKeywordSpan">createDataSource</span>(config);
}

function configureModel(ModelCtor, config, app) {
assert(ModelCtor.prototype instanceof ModelCtor.registry.getModel(&#x27;Model&#x27;),
  ModelCtor.modelName + &#x27; must be a descendant of loopback.Model&#x27;);

var dataSource = config.dataSource;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.createModel" id="apidoc.element.loopback.createModel">
        function <span class="apidocSignatureSpan">loopback.</span>createModel
        <span class="apidocSignatureSpan">(name, properties, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createModel = function (name, properties, options) {
  return this.registry.createModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

app.model = function(Model, config) {
var isPublic = true;
var registry = this.registry;

if (typeof Model === &#x27;string&#x27;) {
  var msg = &#x27;app.model(modelName, settings) is no longer supported. &#x27; +
    &#x27;Use app.registry.<span class="apidocCodeKeywordSpan">createModel</span>(modelName, definition) and &#x27; +
    &#x27;app.model(ModelCtor, config) instead.&#x27;;
  throw new Error(msg);
}

if (arguments.length &#x3e; 1) {
  config = config || {};
  configureModel(Model, config, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.errorHandler" id="apidoc.element.loopback.errorHandler">
        function <span class="apidocSignatureSpan">loopback.</span>errorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorHandler = function (options) {
  throw new Error(&#x27;loopback.errorHandler is no longer available.&#x27; +
  &#x27; Please use the module &#x22;strong-error-handler&#x22; instead.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.favicon" id="apidoc.element.loopback.favicon">
        function <span class="apidocSignatureSpan">loopback.</span>favicon
        <span class="apidocSignatureSpan">(icon, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">favicon = function (icon, options) {
  icon = icon || path.join(__dirname, &#x27;../../favicon.ico&#x27;);
  return favicon(icon, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x27;use strict&#x27;;
var favicon = require(&#x27;serve-favicon&#x27;);
var path = require(&#x27;path&#x27;);

/**
 * Serve the LoopBack favicon.
 * @header loopback.<span class="apidocCodeKeywordSpan">favicon</span>()
 */
module.exports = function(icon, options) {
  icon = icon || path.join(__dirname, &#x27;../../favicon.ico&#x27;);
  return favicon(icon, options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.findModel" id="apidoc.element.loopback.findModel">
        function <span class="apidocSignatureSpan">loopback.</span>findModel
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModel = function (modelName) {
  return this.registry.findModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // the principalType must either be &#x27;USER&#x27;
    if (p.type === Principal.USER) {
      return {id: p.id, principalType: p.type};
    }

    // or permit to resolve a valid user model
    var userModel = this.registry.<span class="apidocCodeKeywordSpan">findModel</span>(p.type);
    if (!userModel) continue;
    if (userModel.prototype instanceof BaseUser) {
      return {id: p.id, principalType: p.type};
    }
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.getCurrentContext" id="apidoc.element.loopback.getCurrentContext">
        function <span class="apidocSignatureSpan">loopback.</span>getCurrentContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentContext = function () {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.getCurrentContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports = function(loopback) {
juggler.getCurrentContext =
remoting.getCurrentContext =
loopback.getCurrentContext = function() {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.<span class="apidocCodeKeywordSpan">getCurrentContext</span>()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
};

loopback.runInContext = function(fn) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.runInContext()&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.getModel" id="apidoc.element.loopback.getModel">
        function <span class="apidocSignatureSpan">loopback.</span>getModel
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModel = function (modelName) {
  return this.registry.getModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = context || {};

assert(context.registry,
  &#x27;Application registry is mandatory in AccessContext but missing in provided context&#x27;);
this.registry = context.registry;
this.principals = context.principals || [];
var model = context.model;
model = (&#x27;string&#x27; === typeof model) ? this.registry.<span class="apidocCodeKeywordSpan">getModel</span>(model) : model
;
this.model = model;
this.modelName = model &#x26;&#x26; model.modelName;

this.modelId = context.id || context.modelId;
this.property = context.property || AccessContext.ALL;

this.method = context.method;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.getModelByType" id="apidoc.element.loopback.getModelByType">
        function <span class="apidocSignatureSpan">loopback.</span>getModelByType
        <span class="apidocSignatureSpan">(modelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModelByType = function (modelType) {
  return this.registry.getModelByType.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.<span class="apidocCodeKeywordSpan">getModelByType</span>(aclModel);
  return _aclModel;
};

/**
 * Check if the given access token can invoke the specified method.
 *
 * @param {AccessToken} token The access token.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index" id="apidoc.element.loopback.index">
        function <span class="apidocSignatureSpan">loopback.</span>index
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createApplication(options) {
  var app = loopbackExpress();

  merge(app, proto);

  app.loopback = loopback;

  // Create a new instance of models registry per each app instance
  app.models = function() {
    return proto.models.apply(this, arguments);
  };

  // Create a new instance of datasources registry per each app instance
  app.datasources = app.dataSources = {};

  // Create a new instance of connector registry per each app instance
  app.connectors = {};

  // Register built-in connectors. It&#x27;s important to keep this code
  // hand-written, so that all require() calls are static
  // and thus browserify can process them (include connectors in the bundle)
  app.connector(&#x27;memory&#x27;, loopback.Memory);
  app.connector(&#x27;remote&#x27;, loopback.Remote);
  app.connector(&#x27;kv-memory&#x27;,
    require(&#x27;loopback-datasource-juggler/lib/connectors/kv-memory&#x27;));

  if (loopback.localRegistry || options &#x26;&#x26; options.localRegistry === true) {
    // setup the app registry
    var registry = app.registry = new Registry();
    if (options &#x26;&#x26; options.loadBuiltinModels === true) {
      require(&#x27;./builtin-models&#x27;)(registry);
    }
  } else {
    app.registry = loopback.registry;
  }

  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.memory" id="apidoc.element.loopback.memory">
        function <span class="apidocSignatureSpan">loopback.</span>memory
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memory = function (name) {
  return this.registry.memory.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.query" id="apidoc.element.loopback.query">
        function <span class="apidocSignatureSpan">loopback.</span>query
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(options) {
  var opts = Object.create(options || null);
  var queryparse = qs.parse;

  if (typeof options === &#x27;function&#x27;) {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined &#x26;&#x26; opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next){
    if (!req.query) {
      var val = parseUrl(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.remoteMethod" id="apidoc.element.loopback.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.</span>remoteMethod
        <span class="apidocSignatureSpan">(fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (fn, options) {
  fn.shared = true;
  if (typeof options === &#x27;object&#x27;) {
    Object.keys(options).forEach(function(key) {
      fn[key] = options[key];
    });
  }
  fn.http = fn.http || {verb: &#x27;get&#x27;};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.rest" id="apidoc.element.loopback.rest">
        function <span class="apidocSignatureSpan">loopback.</span>rest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rest() {
  var handlers; // Cached handlers

  return function restApiHandler(req, res, next) {
    var app = req.app;
    var registry = app.registry;

    if (!handlers) {
      handlers = [];
      var remotingOptions = app.get(&#x27;remoting&#x27;) || {};

      var contextOptions = remotingOptions.context;
      if (contextOptions !== undefined &#x26;&#x26; contextOptions !== false) {
        throw new Error(g.f(
          &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
          &#x27;remoting.context option&#x27;,
          &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
      }

      if (app.isAuthEnabled) {
        var AccessToken = registry.getModelByType(&#x27;AccessToken&#x27;);
        handlers.push(loopback.token({model: AccessToken, app: app}));
      }

      handlers.push(function(req, res, next) {
        // Need to get an instance of the REST handler per request
        return app.handler(&#x27;rest&#x27;)(req, res, next);
      });
    }
    if (handlers.length === 1) {
      return handlers[0](req, res, next);
    }
    async.eachSeries(handlers, function(handler, done) {
      handler(req, res, done);
    }, next);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = rest;

/**
 * Expose models over REST.
 *
 * For example:
 * ```js
 * app.use(loopback.<span class="apidocCodeKeywordSpan">rest</span>());
 * ```
 * For more information, see [Exposing models over a REST API](http://loopback.io/doc/en/lb2/Exposing-models-over-REST.html).
 * @header loopback.rest()
 */

function rest() {
var handlers; // Cached handlers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.runInContext" id="apidoc.element.loopback.runInContext">
        function <span class="apidocSignatureSpan">loopback.</span>runInContext
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runInContext = function (fn) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.runInContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;loopback.getCurrentContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
};

loopback.runInContext = function(fn) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.<span class="apidocCodeKeywordSpan">runInContext</span>()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
};

loopback.createContext = function(scopeName) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.createContext()&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.static" id="apidoc.element.loopback.static">
        function <span class="apidocSignatureSpan">loopback.</span>static
        <span class="apidocSignatureSpan">(root, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serveStatic(root, options) {
  if (!root) {
    throw new TypeError(&#x27;root path required&#x27;)
  }

  if (typeof root !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;root path must be a string&#x27;)
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders &#x26;&#x26; typeof setHeaders !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;option setHeaders must be function&#x27;)
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== &#x27;GET&#x27; &#x26;&#x26; req.method !== &#x27;HEAD&#x27;) {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader(&#x27;Allow&#x27;, &#x27;GET, HEAD&#x27;)
      res.setHeader(&#x27;Content-Length&#x27;, &#x27;0&#x27;)
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === &#x27;/&#x27; &#x26;&#x26; originalUrl.pathname.substr(-1) !== &#x27;/&#x27;) {
      path = &#x27;&#x27;
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on(&#x27;directory&#x27;, onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on(&#x27;headers&#x27;, setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on(&#x27;file&#x27;, function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on(&#x27;error&#x27;, function error (err) {
      if (forwardError || !(err.statusCode &#x3c; 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Serve static assets of a LoopBack application.
 *
 * @param {string} root The root directory from which the static assets are to
 * be served.
 * @param {object} options Refer to
 *   [express documentation](http://expressjs.com/4x/api.html#express.static)
 *   for the full list of available options.
 * @header loopback.<span class="apidocCodeKeywordSpan">static</span>(root, [options])
 */
&#x27;use strict&#x27;;
module.exports = require(&#x27;express&#x27;).static;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.status" id="apidoc.element.loopback.status">
        function <span class="apidocSignatureSpan">loopback.</span>status
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function status() {
  var started = new Date();

  return function(req, res) {
    res.send({
      started: started,
      uptime: (Date.now() - Number(started)) / 1000,
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

UserModel.afterRemote(&#x27;confirm&#x27;, function(ctx, inst, next) {
  if (ctx.args.redirect !== undefined) {
    if (!ctx.res) {
      return next(new Error(g.f(&#x27;The transport does not support HTTP redirects.&#x27;)));
    }
    ctx.res.location(ctx.args.redirect);
    ctx.res.<span class="apidocCodeKeywordSpan">status</span>(302);
  }
  next();
});

// default models
assert(loopback.Email, &#x27;Email model must be defined before User model&#x27;);
UserModel.email = loopback.Email;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.template" id="apidoc.element.loopback.template">
        function <span class="apidocSignatureSpan">loopback.</span>template
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">template = function (file) {
  var templates = this._templates || (this._templates = {});
  var str = templates[file] || (templates[file] = fs.readFileSync(file, &#x27;utf8&#x27;));
  return ejs.compile(str, {
    filename: file,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
    }
  }
  return fn.promise;
};

function createVerificationEmailBody(options, cb) {
  var template = loopback.<span class="apidocCodeKeywordSpan">template</span>(options.template);
  var body = template(options);
  cb(null, body);
}

/**
 * A default verification token generator which accepts the user the token is
 * being generated for and a callback function to indicate completion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.token" id="apidoc.element.loopback.token">
        function <span class="apidocSignatureSpan">loopback.</span>token
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(options) {
  options = options || {};
  var TokenModel;

  var currentUserLiteral = options.currentUserLiteral;
  if (currentUserLiteral &#x26;&#x26; (typeof currentUserLiteral !== &#x27;string&#x27;)) {
    debug(&#x27;Set currentUserLiteral to \&#x27;me\&#x27; as the value is not a string.&#x27;);
    currentUserLiteral = &#x27;me&#x27;;
  }
  if (typeof currentUserLiteral === &#x27;string&#x27;) {
    currentUserLiteral = escapeRegExp(currentUserLiteral);
  }

  var enableDoublecheck = !!options.enableDoublecheck;
  var overwriteExistingToken = !!options.overwriteExistingToken;

  return function(req, res, next) {
    var app = req.app;
    var registry = app.registry;
    if (!TokenModel) {
      TokenModel = registry.getModel(options.model || &#x27;AccessToken&#x27;);
    }

    assert(typeof TokenModel === &#x27;function&#x27;,
      &#x27;loopback.token() middleware requires a AccessToken model&#x27;);

    if (req.accessToken !== undefined) {
      if (!enableDoublecheck) {
        // req.accessToken is defined already (might also be &#x22;null&#x22; or &#x22;false&#x22;) and enableDoublecheck
        // has not been set --&#x3e; skip searching for credentials
        rewriteUserLiteral(req, currentUserLiteral);
        return next();
      }
      if (req.accessToken &#x26;&#x26; req.accessToken.id &#x26;&#x26; !overwriteExistingToken) {
        // req.accessToken.id is defined, which means that some other middleware has identified a valid user.
        // when overwriteExistingToken is not set to a truthy value, skip searching for credentials.
        rewriteUserLiteral(req, currentUserLiteral);
        return next();
      }
      // continue normal operation (as if req.accessToken was undefined)
    }
    TokenModel.findForRequest(req, options, function(err, token) {
      req.accessToken = token || null;
      rewriteUserLiteral(req, currentUserLiteral);
      var ctx = req.loopbackContext;
      if (ctx &#x26;&#x26; ctx.active) ctx.set(&#x27;accessToken&#x27;, token);
      next(err);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
      &#x27;remoting.context option&#x27;,
      &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
  }

  if (app.isAuthEnabled) {
    var AccessToken = registry.getModelByType(&#x27;AccessToken&#x27;);
    handlers.push(loopback.<span class="apidocCodeKeywordSpan">token</span>({model: AccessToken, app: app}));
  }

  handlers.push(function(req, res, next) {
    // Need to get an instance of the REST handler per request
    return app.handler(&#x27;rest&#x27;)(req, res, next);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.urlNotFound" id="apidoc.element.loopback.urlNotFound">
        function <span class="apidocSignatureSpan">loopback.</span>urlNotFound
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlNotFound() {
  return function raiseUrlNotFoundError(req, res, next) {
    var error = new Error(&#x27;Cannot &#x27; + req.method + &#x27; &#x27; + req.url);
    error.status = 404;
    next(error);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
&#x27;use strict&#x27;;
module.exports = urlNotFound;

/**
 * Convert any request not handled so far to a 404 error
 * to be handled by error-handling middleware.
 * @header loopback.<span class="apidocCodeKeywordSpan">urlNotFound</span>()
 */
function urlNotFound() {
return function raiseUrlNotFoundError(req, res, next) {
  var error = new Error(&#x27;Cannot &#x27; + req.method + &#x27; &#x27; + req.url);
  error.status = 404;
  next(error);
};
...</pre></li>
    </ul>
















































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ACL" id="apidoc.module.loopback.ACL">module loopback.ACL</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ACL.ACL" id="apidoc.element.loopback.ACL.ACL">
        function <span class="apidocSignatureSpan">loopback.</span>ACL
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.ValidationError" id="apidoc.element.loopback.ACL.ValidationError">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL._ACL" id="apidoc.element.loopback.ACL._ACL">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL._defineChangeModel" id="apidoc.element.loopback.ACL._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL._getAccessTypeForMethod" id="apidoc.element.loopback.ACL._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL._notifyBaseObservers" id="apidoc.element.loopback.ACL._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL._runWhenAttachedToApp" id="apidoc.element.loopback.ACL._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.addListener" id="apidoc.element.loopback.ACL.addListener">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.afterRemote" id="apidoc.element.loopback.ACL.afterRemote">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.afterRemoteError" id="apidoc.element.loopback.ACL.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.attachTo" id="apidoc.element.loopback.ACL.attachTo">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.beforeRemote" id="apidoc.element.loopback.ACL.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.belongsToRemoting" id="apidoc.element.loopback.ACL.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.bulkUpdate" id="apidoc.element.loopback.ACL.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.changes" id="apidoc.element.loopback.ACL.changes">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.checkAccess" id="apidoc.element.loopback.ACL.checkAccess">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.checkAccessForContext" id="apidoc.element.loopback.ACL.checkAccessForContext">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>checkAccessForContext
        <span class="apidocSignatureSpan">(context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccessForContext = function (context, callback) {
  if (!callback) callback = utils.createPromiseCallback();
  var self = this;
  self.resolveRelatedModels();
  var roleModel = self.roleModel;

  if (!(context instanceof AccessContext)) {
    context.registry = this.registry;
    context = new AccessContext(context);
  }

  var authorizedRoles = {};
  var remotingContext = context.remotingContext;
  var model = context.model;
  var modelDefaultPermission = model &#x26;&#x26; model.settings.defaultPermission;
  var property = context.property;
  var accessType = context.accessType;
  var modelName = context.modelName;

  var methodNames = context.methodNames;
  var propertyQuery = (property === ACL.ALL) ? undefined : {inq: methodNames.concat([ACL.ALL])};

  var accessTypeQuery = (accessType === ACL.ALL) ?
    undefined :
    (accessType === ACL.REPLICATE) ?
      {inq: [ACL.REPLICATE, ACL.WRITE, ACL.ALL]} :
      {inq: [accessType, ACL.ALL]};

  var req = new AccessRequest({
    model: modelName,
    property,
    accessType,
    permission: ACL.DEFAULT,
    methodNames,
    registry: this.registry});

  var effectiveACLs = [];
  var staticACLs = self.getStaticACLs(model.modelName, property);

  this.find({where: {model: model.modelName, property: propertyQuery,
    accessType: accessTypeQuery}}, function(err, acls) {
    if (err) return callback(err);
    var inRoleTasks = [];

    acls = acls.concat(staticACLs);

    acls.forEach(function(acl) {
      // Check exact matches
      for (var i = 0; i &#x3c; context.principals.length; i++) {
        var p = context.principals[i];
        var typeMatch = p.type === acl.principalType;
        var idMatch = String(p.id) === String(acl.principalId);
        if (typeMatch &#x26;&#x26; idMatch) {
          effectiveACLs.push(acl);
          return;
        }
      }

      // Check role matches
      if (acl.principalType === ACL.ROLE) {
        inRoleTasks.push(function(done) {
          roleModel.isInRole(acl.principalId, context,
            function(err, inRole) {
              if (!err &#x26;&#x26; inRole) {
                effectiveACLs.push(acl);
                // add the role to authorizedRoles if allowed
                if (acl.isAllowed(modelDefaultPermission))
                  authorizedRoles[acl.principalId] = true;
              }
              done(err, acl);
            });
        });
      }
    });

    async.parallel(inRoleTasks, function(err, results) {
      if (err) return callback(err, null);

      // resolved is an instance of AccessRequest
      var resolved = self.resolvePermission(effectiveACLs, req);
      debug(&#x27;---Resolved---&#x27;);
      resolved.debug();

      // set authorizedRoles in remotingContext options argument if
      // resolved AccessRequest permission is ALLOW, else set it to empty object
      authorizedRoles = resolved.isAllowed() ? authorizedRoles : {};
      saveAuthorizedRolesToRemotingContext(remotingContext, authorizedRoles);
      return callback(null, resolved);
    });
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}

aclModel.<span class="apidocCodeKeywordSpan">checkAccessForContext</span>({
  accessToken: token,
  model: this,
  property: sharedMethod.name,
  method: sharedMethod.name,
  sharedMethod: sharedMethod,
  modelId: modelId,
  accessType: this._getAccessTypeForMethod(sharedMethod),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.checkAccessForToken" id="apidoc.element.loopback.ACL.checkAccessForToken">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>checkAccessForToken
        <span class="apidocSignatureSpan">(token, model, modelId, method, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccessForToken = function (token, model, modelId, method, callback) {
  assert(token, &#x27;Access token is required&#x27;);
  if (!callback) callback = utils.createPromiseCallback();
  var context = new AccessContext({
    registry: this.registry,
    accessToken: token,
    model: model,
    property: method,
    method: method,
    modelId: modelId,
  });

  this.checkAccessForContext(context, function(err, accessRequest) {
    if (err) callback(err);
    else callback(null, accessRequest.isAllowed());
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.checkPermission" id="apidoc.element.loopback.ACL.checkPermission">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>checkPermission
        <span class="apidocSignatureSpan">(principalType, principalId, model, property, accessType, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkPermission(principalType, principalId, model, property, accessType, callback) {
  if (!callback) callback = utils.createPromiseCallback();
  if (principalId !== null &#x26;&#x26; principalId !== undefined &#x26;&#x26; (typeof principalId !== &#x27;string&#x27;)) {
    principalId = principalId.toString();
  }
  property = property || ACL.ALL;
  var propertyQuery = (property === ACL.ALL) ? undefined : {inq: [property, ACL.ALL]};
  accessType = accessType || ACL.ALL;
  var accessTypeQuery = (accessType === ACL.ALL) ? undefined :
    {inq: [accessType, ACL.ALL, ACL.EXECUTE]};

  var req = new AccessRequest({model, property, accessType, registry: this.registry});

  var acls = this.getStaticACLs(model, property);

  // resolved is an instance of AccessRequest
  var resolved = this.resolvePermission(acls, req);

  if (resolved &#x26;&#x26; resolved.permission === ACL.DENY) {
    debug(&#x27;Permission denied by statically resolved permission&#x27;);
    debug(&#x27; Resolved Permission: %j&#x27;, resolved);
    process.nextTick(function() {
      callback(null, resolved);
    });
    return callback.promise;
  }

  var self = this;
  this.find({where: {principalType: principalType, principalId: principalId,
    model: model, property: propertyQuery, accessType: accessTypeQuery}},
    function(err, dynACLs) {
      if (err) {
        return callback(err);
      }
      acls = acls.concat(dynACLs);
      // resolved is an instance of AccessRequest
      resolved = self.resolvePermission(acls, req);
      return callback(null, resolved);
    });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    assert(aclModel,
      &#x27;ACL model must be defined before Scope.checkPermission is called&#x27;);

    this.findOne({where: {name: scope}}, function(err, scope) {
      if (err) {
        if (callback) callback(err);
      } else {
        aclModel.<span class="apidocCodeKeywordSpan">checkPermission</span>(
          aclModel.SCOPE, scope.id, model, property, accessType, callback);
      }
    });
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.checkpoint" id="apidoc.element.loopback.ACL.checkpoint">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.clearObservers" id="apidoc.element.loopback.ACL.clearObservers">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.count" id="apidoc.element.loopback.ACL.count">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.create" id="apidoc.element.loopback.ACL.create">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.createChangeFilter" id="apidoc.element.loopback.ACL.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.createChangeStream" id="apidoc.element.loopback.ACL.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.createOptionsFromRemotingContext" id="apidoc.element.loopback.ACL.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.createUpdates" id="apidoc.element.loopback.ACL.createUpdates">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.currentCheckpoint" id="apidoc.element.loopback.ACL.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.defineProperty" id="apidoc.element.loopback.ACL.defineProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.deleteAll" id="apidoc.element.loopback.ACL.deleteAll">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.deleteById" id="apidoc.element.loopback.ACL.deleteById">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.destroyAll" id="apidoc.element.loopback.ACL.destroyAll">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.destroyById" id="apidoc.element.loopback.ACL.destroyById">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.diff" id="apidoc.element.loopback.ACL.diff">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.disableRemoteMethod" id="apidoc.element.loopback.ACL.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.disableRemoteMethodByName" id="apidoc.element.loopback.ACL.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.emit" id="apidoc.element.loopback.ACL.emit">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.enableChangeTracking" id="apidoc.element.loopback.ACL.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.eventNames" id="apidoc.element.loopback.ACL.eventNames">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.exists" id="apidoc.element.loopback.ACL.exists">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.extend" id="apidoc.element.loopback.ACL.extend">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.find" id="apidoc.element.loopback.ACL.find">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.findById" id="apidoc.element.loopback.ACL.findById">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.ACL.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.findLastChange" id="apidoc.element.loopback.ACL.findLastChange">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.findOne" id="apidoc.element.loopback.ACL.findOne">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.findOrCreate" id="apidoc.element.loopback.ACL.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.forEachProperty" id="apidoc.element.loopback.ACL.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getApp" id="apidoc.element.loopback.ACL.getApp">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getChangeModel" id="apidoc.element.loopback.ACL.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getDataSource" id="apidoc.element.loopback.ACL.getDataSource">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getIdName" id="apidoc.element.loopback.ACL.getIdName">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getMatchingScore" id="apidoc.element.loopback.ACL.getMatchingScore">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getMatchingScore
        <span class="apidocSignatureSpan">(rule, req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMatchingScore(rule, req) {
  var props = [&#x27;model&#x27;, &#x27;property&#x27;, &#x27;accessType&#x27;];
  var score = 0;

  for (var i = 0; i &#x3c; props.length; i++) {
    // Shift the score by 4 for each of the properties as the weight
    score = score * 4;
    var ruleValue = rule[props[i]] || ACL.ALL;
    var requestedValue = req[props[i]] || ACL.ALL;
    var isMatchingMethodName = props[i] === &#x27;property&#x27; &#x26;&#x26;
      req.methodNames.indexOf(ruleValue) !== -1;

    var isMatchingAccessType = ruleValue === requestedValue;
    if (props[i] === &#x27;accessType&#x27; &#x26;&#x26; !isMatchingAccessType) {
      switch (ruleValue) {
        case ACL.EXECUTE:
          // EXECUTE should match READ, REPLICATE and WRITE
          isMatchingAccessType = true;
          break;
        case ACL.WRITE:
          // WRITE should match REPLICATE too
          isMatchingAccessType = requestedValue === ACL.REPLICATE;
          break;
      }
    }

    if (isMatchingMethodName || isMatchingAccessType) {
      // Exact match
      score += 3;
    } else if (ruleValue === ACL.ALL) {
      // Wildcard match
      score += 2;
    } else if (requestedValue === ACL.ALL) {
      score += 1;
    } else {
      // Doesn&#x27;t match at all
      return -1;
    }
  }

  // Weigh against the principal type into 4 levels
  // - user level (explicitly allow/deny a given user)
  // - app level (explicitly allow/deny a given app)
  // - role level (role based authorization)
  // - other
  // user &#x3e; app &#x3e; role &#x3e; ...
  score = score * 4;
  switch (rule.principalType) {
    case ACL.USER:
      score += 4;
      break;
    case ACL.APP:
      score += 3;
      break;
    case ACL.ROLE:
      score += 2;
      break;
    default:
      score += 1;
  }

  // Weigh against the roles
  // everyone &#x3c; authenticated/unauthenticated &#x3c; related &#x3c; owner &#x3c; ...
  score = score * 8;
  if (rule.principalType === ACL.ROLE) {
    switch (rule.principalId) {
      case Role.OWNER:
        score += 4;
        break;
      case Role.RELATED:
        score += 3;
        break;
      case Role.AUTHENTICATED:
      case Role.UNAUTHENTICATED:
        score += 2;
        break;
      case Role.EVERYONE:
        score += 1;
        break;
      default:
        score += 5;
    }
  }
  score = score * 4;
  score += AccessContext.permissionOrder[rule.permission || ACL.ALLOW] - 1;
  return score;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Get matching score for the given `AccessRequest`.
 * @param {AccessRequest} req The request
 * @returns {Number} score
 */

ACL.prototype.score = function(req) {
  return this.constructor.<span class="apidocCodeKeywordSpan">getMatchingScore</span>(this, req);
};

/*!
 * Resolve permission from the ACLs
 * @param {Object[]) acls The list of ACLs
 * @param {AccessRequest} req The access request
 * @returns {AccessRequest} result The resolved access request
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getMaxListeners" id="apidoc.element.loopback.ACL.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getPropertyType" id="apidoc.element.loopback.ACL.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getSourceId" id="apidoc.element.loopback.ACL.getSourceId">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.getStaticACLs" id="apidoc.element.loopback.ACL.getStaticACLs">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>getStaticACLs
        <span class="apidocSignatureSpan">(model, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStaticACLs(model, property) {
  var modelClass = this.registry.findModel(model);
  var staticACLs = [];
  if (modelClass &#x26;&#x26; modelClass.settings.acls) {
    modelClass.settings.acls.forEach(function(acl) {
      var prop = acl.property;
      // We support static ACL property with array of string values.
      if (Array.isArray(prop) &#x26;&#x26; prop.indexOf(property) &#x3e;= 0)
        prop = property;
      if (!prop || prop === ACL.ALL || property === prop) {
        staticACLs.push(new ACL({
          model: model,
          property: prop || ACL.ALL,
          principalType: acl.principalType,
          principalId: acl.principalId, // TODO: Should it be a name?
          accessType: acl.accessType || ACL.ALL,
          permission: acl.permission,
        }));
      }
    });
  }
  var prop = modelClass &#x26;&#x26; (
    // regular property
    modelClass.definition.properties[property] ||
    // relation/scope
    (modelClass._scopeMeta &#x26;&#x26; modelClass._scopeMeta[property]) ||
    // static method
    modelClass[property] ||
    // prototype method
    modelClass.prototype[property]);
  if (prop &#x26;&#x26; prop.acls) {
    prop.acls.forEach(function(acl) {
      staticACLs.push(new ACL({
        model: modelClass.modelName,
        property: property,
        principalType: acl.principalType,
        principalId: acl.principalId,
        accessType: acl.accessType,
        permission: acl.permission,
      }));
    });
  }
  return staticACLs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var propertyQuery = (property === ACL.ALL) ? undefined : {inq: [property, ACL.ALL]};
accessType = accessType || ACL.ALL;
var accessTypeQuery = (accessType === ACL.ALL) ? undefined :
  {inq: [accessType, ACL.ALL, ACL.EXECUTE]};

var req = new AccessRequest({model, property, accessType, registry: this.registry});

var acls = this.<span class="apidocCodeKeywordSpan">getStaticACLs</span>(model, property);

// resolved is an instance of AccessRequest
var resolved = this.resolvePermission(acls, req);

if (resolved &#x26;&#x26; resolved.permission === ACL.DENY) {
  debug(&#x27;Permission denied by statically resolved permission&#x27;);
  debug(&#x27; Resolved Permission: %j&#x27;, resolved);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.handleChangeError" id="apidoc.element.loopback.ACL.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.hasManyRemoting" id="apidoc.element.loopback.ACL.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.hasOneRemoting" id="apidoc.element.loopback.ACL.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.isAllowed" id="apidoc.element.loopback.ACL.isAllowed">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>isAllowed
        <span class="apidocSignatureSpan">(permission, defaultPermission)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAllowed = function (permission, defaultPermission) {
  if (permission === ACL.DEFAULT) {
    permission = defaultPermission || ACL.ALLOW;
  }
  return permission !== loopback.ACL.DENY;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (debug.enabled) {
    debug(&#x27;---AccessRequest---&#x27;);
    debug(&#x27; model %s&#x27;, this.model);
    debug(&#x27; property %s&#x27;, this.property);
    debug(&#x27; accessType %s&#x27;, this.accessType);
    debug(&#x27; permission %s&#x27;, this.permission);
    debug(&#x27; isWildcard() %s&#x27;, this.isWildcard());
    debug(&#x27; isAllowed() %s&#x27;, this.<span class="apidocCodeKeywordSpan">isAllowed</span>());
  }
};

module.exports.AccessContext = AccessContext;
module.exports.Principal = Principal;
module.exports.AccessRequest = AccessRequest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.isHiddenProperty" id="apidoc.element.loopback.ACL.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.isMappedToRole" id="apidoc.element.loopback.ACL.isMappedToRole">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>isMappedToRole
        <span class="apidocSignatureSpan">(principalType, principalId, role, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMappedToRole = function (principalType, principalId, role, cb) {
  cb = cb || utils.createPromiseCallback();
  var self = this;
  this.resolvePrincipal(principalType, principalId,
    function(err, principal) {
      if (err) return cb(err);
      if (principal != null) {
        principalId = principal.id;
      }
      principalType = principalType || &#x27;ROLE&#x27;;
      self.resolvePrincipal(&#x27;ROLE&#x27;, role, function(err, role) {
        if (err || !role) return cb(err, role);
        self.roleMappingModel.findOne({
          where: {
            roleId: role.id,
            principalType: principalType,
            principalId: String(principalId),
          },
        }, function(err, result) {
          if (err) return cb(err);
          return cb(null, !!result);
        });
      });
    });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.isProtectedProperty" id="apidoc.element.loopback.ACL.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.listenerCount" id="apidoc.element.loopback.ACL.listenerCount">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.listeners" id="apidoc.element.loopback.ACL.listeners">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.mixin" id="apidoc.element.loopback.ACL.mixin">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.nestRemoting" id="apidoc.element.loopback.ACL.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.notifyObserversAround" id="apidoc.element.loopback.ACL.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.notifyObserversOf" id="apidoc.element.loopback.ACL.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.observe" id="apidoc.element.loopback.ACL.observe">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.on" id="apidoc.element.loopback.ACL.on">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.once" id="apidoc.element.loopback.ACL.once">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.patchOrCreate" id="apidoc.element.loopback.ACL.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.patchOrCreateWithWhere" id="apidoc.element.loopback.ACL.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.prependListener" id="apidoc.element.loopback.ACL.prependListener">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.prependOnceListener" id="apidoc.element.loopback.ACL.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.rectifyAllChanges" id="apidoc.element.loopback.ACL.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.rectifyChange" id="apidoc.element.loopback.ACL.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.registerProperty" id="apidoc.element.loopback.ACL.registerProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.remoteMethod" id="apidoc.element.loopback.ACL.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.remove" id="apidoc.element.loopback.ACL.remove">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.removeAllListeners" id="apidoc.element.loopback.ACL.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.removeById" id="apidoc.element.loopback.ACL.removeById">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.removeListener" id="apidoc.element.loopback.ACL.removeListener">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.removeObserver" id="apidoc.element.loopback.ACL.removeObserver">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.replaceById" id="apidoc.element.loopback.ACL.replaceById">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.replaceOrCreate" id="apidoc.element.loopback.ACL.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.replicate" id="apidoc.element.loopback.ACL.replicate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.resolvePermission" id="apidoc.element.loopback.ACL.resolvePermission">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>resolvePermission
        <span class="apidocSignatureSpan">(acls, req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolvePermission(acls, req) {
  if (!(req instanceof AccessRequest)) {
    req.registry = this.registry;
    req = new AccessRequest(req);
  }
  // Sort by the matching score in descending order
  acls = acls.sort(function(rule1, rule2) {
    return ACL.getMatchingScore(rule2, req) - ACL.getMatchingScore(rule1, req);
  });
  var permission = ACL.DEFAULT;
  var score = 0;

  for (var i = 0; i &#x3c; acls.length; i++) {
    var candidate = acls[i];
    score = ACL.getMatchingScore(candidate, req);
    if (score &#x3c; 0) {
      // the highest scored ACL did not match
      break;
    }
    if (!req.isWildcard()) {
      // We should stop from the first match for non-wildcard
      permission = candidate.permission;
      break;
    } else {
      if (req.exactlyMatches(candidate)) {
        permission = candidate.permission;
        break;
      }
      // For wildcard match, find the strongest permission
      var candidateOrder = AccessContext.permissionOrder[candidate.permission];
      var permissionOrder = AccessContext.permissionOrder[permission];
      if (candidateOrder &#x3e; permissionOrder) {
        permission = candidate.permission;
      }
    }
  }

  if (debug.enabled) {
    debug(&#x27;The following ACLs were searched: &#x27;);
    acls.forEach(function(acl) {
      acl.debug();
      debug(&#x27;with score:&#x27;, acl.score(req));
    });
  }
  var res = new AccessRequest({
    model: req.model,
    property: req.property,
    accessType: req.accessType,
    permission: permission || ACL.DEFAULT,
    registry: this.registry});

  // Elucidate permission status if DEFAULT
  res.settleDefaultPermission();

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {inq: [accessType, ACL.ALL, ACL.EXECUTE]};

var req = new AccessRequest({model, property, accessType, registry: this.registry});

var acls = this.getStaticACLs(model, property);

// resolved is an instance of AccessRequest
var resolved = this.<span class="apidocCodeKeywordSpan">resolvePermission</span>(acls, req);

if (resolved &#x26;&#x26; resolved.permission === ACL.DENY) {
  debug(&#x27;Permission denied by statically resolved permission&#x27;);
  debug(&#x27; Resolved Permission: %j&#x27;, resolved);
  process.nextTick(function() {
    callback(null, resolved);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.resolvePrincipal" id="apidoc.element.loopback.ACL.resolvePrincipal">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>resolvePrincipal
        <span class="apidocSignatureSpan">(type, id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolvePrincipal = function (type, id, cb) {
  cb = cb || utils.createPromiseCallback();
  type = type || ACL.ROLE;
  this.resolveRelatedModels();

  switch (type) {
    case ACL.ROLE:
      this.roleModel.findOne({where: {or: [{name: id}, {id: id}]}}, cb);
      break;
    case ACL.USER:
      this.userModel.findOne(
        {where: {or: [{username: id}, {email: id}, {id: id}]}}, cb);
      break;
    case ACL.APP:
      this.applicationModel.findOne(
        {where: {or: [{name: id}, {email: id}, {id: id}]}}, cb);
      break;
    default:
      // try resolving a user model with a name matching the principalType
      var userModel = this.registry.findModel(type);
      if (userModel) {
        userModel.findOne(
          {where: {or: [{username: id}, {email: id}, {id: id}]}},
          cb);
      } else {
        process.nextTick(function() {
          var err = new Error(g.f(&#x27;Invalid principal type: %s&#x27;, type));
          err.statusCode = 400;
          err.code = &#x27;INVALID_PRINCIPAL_TYPE&#x27;;
          cb(err);
        });
      }
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @callback {Function} callback Callback function
 * @param {String|Error} err The error object
 * @param {Boolean} isMapped is the ACL mapped to the role
 */
ACL.isMappedToRole = function(principalType, principalId, role, cb) {
  cb = cb || utils.createPromiseCallback();
  var self = this;
  this.<span class="apidocCodeKeywordSpan">resolvePrincipal</span>(principalType, principalId,
    function(err, principal) {
      if (err) return cb(err);
      if (principal != null) {
        principalId = principal.id;
      }
      principalType = principalType || &#x27;ROLE&#x27;;
      self.resolvePrincipal(&#x27;ROLE&#x27;, role, function(err, role) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.resolveRelatedModels" id="apidoc.element.loopback.ACL.resolveRelatedModels">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>resolveRelatedModels
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveRelatedModels = function () {
  if (!this.roleModel) {
    var reg = this.registry;
    this.roleModel = reg.getModelByType(&#x27;Role&#x27;);
    this.roleMappingModel = reg.getModelByType(&#x27;RoleMapping&#x27;);
    this.userModel = reg.getModelByType(&#x27;User&#x27;);
    this.applicationModel = reg.getModelByType(&#x27;Application&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @callback {Function} callback Callback function
   * @param {String|Error} err The error object.
   * @param {AccessRequest} result The resolved access request.
   */
  ACL.checkAccessForContext = function(context, callback) {
if (!callback) callback = utils.createPromiseCallback();
var self = this;
self.<span class="apidocCodeKeywordSpan">resolveRelatedModels</span>();
var roleModel = self.roleModel;

if (!(context instanceof AccessContext)) {
  context.registry = this.registry;
  context = new AccessContext(context);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.scopeRemoting" id="apidoc.element.loopback.ACL.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.setMaxListeners" id="apidoc.element.loopback.ACL.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.setup" id="apidoc.element.loopback.ACL.setup">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.setupRemoting" id="apidoc.element.loopback.ACL.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.sharedCtor" id="apidoc.element.loopback.ACL.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.ACL.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.ACL.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_" id="apidoc.element.loopback.ACL.super_">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.update" id="apidoc.element.loopback.ACL.update">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.updateAll" id="apidoc.element.loopback.ACL.updateAll">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.updateLastChange" id="apidoc.element.loopback.ACL.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.updateOrCreate" id="apidoc.element.loopback.ACL.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.upsert" id="apidoc.element.loopback.ACL.upsert">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.upsertWithWhere" id="apidoc.element.loopback.ACL.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validate" id="apidoc.element.loopback.ACL.validate">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validateAsync" id="apidoc.element.loopback.ACL.validateAsync">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesAbsenceOf" id="apidoc.element.loopback.ACL.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesExclusionOf" id="apidoc.element.loopback.ACL.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesFormatOf" id="apidoc.element.loopback.ACL.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesInclusionOf" id="apidoc.element.loopback.ACL.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesLengthOf" id="apidoc.element.loopback.ACL.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesNumericalityOf" id="apidoc.element.loopback.ACL.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesPresenceOf" id="apidoc.element.loopback.ACL.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.validatesUniquenessOf" id="apidoc.element.loopback.ACL.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>


































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ACL.prototype" id="apidoc.module.loopback.ACL.prototype">module loopback.ACL.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ACL.prototype.debug" id="apidoc.element.loopback.ACL.prototype.debug">
        function <span class="apidocSignatureSpan">loopback.ACL.prototype.</span>debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debug = function () {
  if (debug.enabled) {
    debug(&#x27;---ACL---&#x27;);
    debug(&#x27;model %s&#x27;, this.model);
    debug(&#x27;property %s&#x27;, this.property);
    debug(&#x27;principalType %s&#x27;, this.principalType);
    debug(&#x27;principalId %s&#x27;, this.principalId);
    debug(&#x27;accessType %s&#x27;, this.accessType);
    debug(&#x27;permission %s&#x27;, this.permission);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
}

if (debug.enabled) {
  debug(&#x27;The following ACLs were searched: &#x27;);
  acls.forEach(function(acl) {
    acl.<span class="apidocCodeKeywordSpan">debug</span>();
    debug(&#x27;with score:&#x27;, acl.score(req));
  });
}
var res = new AccessRequest({
  model: req.model,
  property: req.property,
  accessType: req.accessType,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.prototype.isAllowed" id="apidoc.element.loopback.ACL.prototype.isAllowed">
        function <span class="apidocSignatureSpan">loopback.ACL.prototype.</span>isAllowed
        <span class="apidocSignatureSpan">(defaultPermission)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAllowed = function (defaultPermission) {
  return this.constructor.isAllowed(this.permission, defaultPermission);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (debug.enabled) {
    debug(&#x27;---AccessRequest---&#x27;);
    debug(&#x27; model %s&#x27;, this.model);
    debug(&#x27; property %s&#x27;, this.property);
    debug(&#x27; accessType %s&#x27;, this.accessType);
    debug(&#x27; permission %s&#x27;, this.permission);
    debug(&#x27; isWildcard() %s&#x27;, this.isWildcard());
    debug(&#x27; isAllowed() %s&#x27;, this.<span class="apidocCodeKeywordSpan">isAllowed</span>());
  }
};

module.exports.AccessContext = AccessContext;
module.exports.Principal = Principal;
module.exports.AccessRequest = AccessRequest;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.prototype.score" id="apidoc.element.loopback.ACL.prototype.score">
        function <span class="apidocSignatureSpan">loopback.ACL.prototype.</span>score
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">score = function (req) {
  return this.constructor.getMatchingScore(this, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

if (debug.enabled) {
  debug(&#x27;The following ACLs were searched: &#x27;);
  acls.forEach(function(acl) {
    acl.debug();
    debug(&#x27;with score:&#x27;, acl.<span class="apidocCodeKeywordSpan">score</span>(req));
  });
}
var res = new AccessRequest({
  model: req.model,
  property: req.property,
  accessType: req.accessType,
  permission: permission || ACL.DEFAULT,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ACL.settings" id="apidoc.module.loopback.ACL.settings">module loopback.ACL.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.ACL.settings.base" id="apidoc.element.loopback.ACL.settings.base">
        function <span class="apidocSignatureSpan">loopback.ACL.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ACL.sharedClass" id="apidoc.module.loopback.ACL.sharedClass">module loopback.ACL.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ACL.sharedClass.ctor" id="apidoc.element.loopback.ACL.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.ACL.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ACL.super_" id="apidoc.module.loopback.ACL.super_">module loopback.ACL.super_</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.super_" id="apidoc.element.loopback.ACL.super_.super_">
        function <span class="apidocSignatureSpan">loopback.ACL.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.ValidationError" id="apidoc.element.loopback.ACL.super_.ValidationError">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_._ACL" id="apidoc.element.loopback.ACL.super_._ACL">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_._defineChangeModel" id="apidoc.element.loopback.ACL.super_._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_._getAccessTypeForMethod" id="apidoc.element.loopback.ACL.super_._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_._notifyBaseObservers" id="apidoc.element.loopback.ACL.super_._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_._runWhenAttachedToApp" id="apidoc.element.loopback.ACL.super_._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.addListener" id="apidoc.element.loopback.ACL.super_.addListener">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.afterRemote" id="apidoc.element.loopback.ACL.super_.afterRemote">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.afterRemoteError" id="apidoc.element.loopback.ACL.super_.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.attachTo" id="apidoc.element.loopback.ACL.super_.attachTo">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.beforeRemote" id="apidoc.element.loopback.ACL.super_.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.belongsToRemoting" id="apidoc.element.loopback.ACL.super_.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.bulkUpdate" id="apidoc.element.loopback.ACL.super_.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.changes" id="apidoc.element.loopback.ACL.super_.changes">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.checkAccess" id="apidoc.element.loopback.ACL.super_.checkAccess">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.checkpoint" id="apidoc.element.loopback.ACL.super_.checkpoint">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.clearObservers" id="apidoc.element.loopback.ACL.super_.clearObservers">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.count" id="apidoc.element.loopback.ACL.super_.count">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.create" id="apidoc.element.loopback.ACL.super_.create">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.createChangeFilter" id="apidoc.element.loopback.ACL.super_.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.createChangeStream" id="apidoc.element.loopback.ACL.super_.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.createOptionsFromRemotingContext" id="apidoc.element.loopback.ACL.super_.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.createUpdates" id="apidoc.element.loopback.ACL.super_.createUpdates">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.currentCheckpoint" id="apidoc.element.loopback.ACL.super_.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.defineProperty" id="apidoc.element.loopback.ACL.super_.defineProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.deleteAll" id="apidoc.element.loopback.ACL.super_.deleteAll">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.deleteById" id="apidoc.element.loopback.ACL.super_.deleteById">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.destroyAll" id="apidoc.element.loopback.ACL.super_.destroyAll">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.destroyById" id="apidoc.element.loopback.ACL.super_.destroyById">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.diff" id="apidoc.element.loopback.ACL.super_.diff">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.disableRemoteMethod" id="apidoc.element.loopback.ACL.super_.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.disableRemoteMethodByName" id="apidoc.element.loopback.ACL.super_.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.emit" id="apidoc.element.loopback.ACL.super_.emit">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.enableChangeTracking" id="apidoc.element.loopback.ACL.super_.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.eventNames" id="apidoc.element.loopback.ACL.super_.eventNames">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.exists" id="apidoc.element.loopback.ACL.super_.exists">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.extend" id="apidoc.element.loopback.ACL.super_.extend">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.find" id="apidoc.element.loopback.ACL.super_.find">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.findById" id="apidoc.element.loopback.ACL.super_.findById">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.ACL.super_.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.findLastChange" id="apidoc.element.loopback.ACL.super_.findLastChange">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.findOne" id="apidoc.element.loopback.ACL.super_.findOne">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.findOrCreate" id="apidoc.element.loopback.ACL.super_.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.forEachProperty" id="apidoc.element.loopback.ACL.super_.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getApp" id="apidoc.element.loopback.ACL.super_.getApp">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getChangeModel" id="apidoc.element.loopback.ACL.super_.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getDataSource" id="apidoc.element.loopback.ACL.super_.getDataSource">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getIdName" id="apidoc.element.loopback.ACL.super_.getIdName">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getMaxListeners" id="apidoc.element.loopback.ACL.super_.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getPropertyType" id="apidoc.element.loopback.ACL.super_.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.getSourceId" id="apidoc.element.loopback.ACL.super_.getSourceId">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.handleChangeError" id="apidoc.element.loopback.ACL.super_.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.hasManyRemoting" id="apidoc.element.loopback.ACL.super_.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.hasOneRemoting" id="apidoc.element.loopback.ACL.super_.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.isHiddenProperty" id="apidoc.element.loopback.ACL.super_.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.isProtectedProperty" id="apidoc.element.loopback.ACL.super_.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.listenerCount" id="apidoc.element.loopback.ACL.super_.listenerCount">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.listeners" id="apidoc.element.loopback.ACL.super_.listeners">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.mixin" id="apidoc.element.loopback.ACL.super_.mixin">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.nestRemoting" id="apidoc.element.loopback.ACL.super_.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.notifyObserversAround" id="apidoc.element.loopback.ACL.super_.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.notifyObserversOf" id="apidoc.element.loopback.ACL.super_.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.observe" id="apidoc.element.loopback.ACL.super_.observe">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.on" id="apidoc.element.loopback.ACL.super_.on">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.once" id="apidoc.element.loopback.ACL.super_.once">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.patchOrCreate" id="apidoc.element.loopback.ACL.super_.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.patchOrCreateWithWhere" id="apidoc.element.loopback.ACL.super_.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prependListener" id="apidoc.element.loopback.ACL.super_.prependListener">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prependOnceListener" id="apidoc.element.loopback.ACL.super_.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.rectifyAllChanges" id="apidoc.element.loopback.ACL.super_.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.rectifyChange" id="apidoc.element.loopback.ACL.super_.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.registerProperty" id="apidoc.element.loopback.ACL.super_.registerProperty">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.remoteMethod" id="apidoc.element.loopback.ACL.super_.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.remove" id="apidoc.element.loopback.ACL.super_.remove">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.removeAllListeners" id="apidoc.element.loopback.ACL.super_.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.removeById" id="apidoc.element.loopback.ACL.super_.removeById">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.removeListener" id="apidoc.element.loopback.ACL.super_.removeListener">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.removeObserver" id="apidoc.element.loopback.ACL.super_.removeObserver">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.replaceById" id="apidoc.element.loopback.ACL.super_.replaceById">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.replaceOrCreate" id="apidoc.element.loopback.ACL.super_.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.replicate" id="apidoc.element.loopback.ACL.super_.replicate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.scopeRemoting" id="apidoc.element.loopback.ACL.super_.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.setMaxListeners" id="apidoc.element.loopback.ACL.super_.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.setup" id="apidoc.element.loopback.ACL.super_.setup">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.setupRemoting" id="apidoc.element.loopback.ACL.super_.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.sharedCtor" id="apidoc.element.loopback.ACL.super_.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.ACL.super_.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.ACL.super_.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.update" id="apidoc.element.loopback.ACL.super_.update">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.updateAll" id="apidoc.element.loopback.ACL.super_.updateAll">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.updateLastChange" id="apidoc.element.loopback.ACL.super_.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.updateOrCreate" id="apidoc.element.loopback.ACL.super_.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.upsert" id="apidoc.element.loopback.ACL.super_.upsert">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.upsertWithWhere" id="apidoc.element.loopback.ACL.super_.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validate" id="apidoc.element.loopback.ACL.super_.validate">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validateAsync" id="apidoc.element.loopback.ACL.super_.validateAsync">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesAbsenceOf" id="apidoc.element.loopback.ACL.super_.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesExclusionOf" id="apidoc.element.loopback.ACL.super_.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesFormatOf" id="apidoc.element.loopback.ACL.super_.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesInclusionOf" id="apidoc.element.loopback.ACL.super_.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesLengthOf" id="apidoc.element.loopback.ACL.super_.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesNumericalityOf" id="apidoc.element.loopback.ACL.super_.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesPresenceOf" id="apidoc.element.loopback.ACL.super_.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.validatesUniquenessOf" id="apidoc.element.loopback.ACL.super_.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ACL.super_.prototype" id="apidoc.module.loopback.ACL.super_.prototype">module loopback.ACL.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.delete" id="apidoc.element.loopback.ACL.super_.prototype.delete">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>delete
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (cb) {
  throwNotAttached(this.constructor.modelName, &#x27;destroy&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.destroy" id="apidoc.element.loopback.ACL.super_.prototype.destroy">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>destroy
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (cb) {
  throwNotAttached(this.constructor.modelName, &#x27;destroy&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    elapsedSeconds &#x3c; secondsToLive;

  if (isValid) {
    process.nextTick(function() {
      cb(null, isValid);
    });
  } else {
    this.<span class="apidocCodeKeywordSpan">destroy</span>(function(err) {
      cb(err, isValid);
    });
  }
} catch (e) {
  process.nextTick(function() {
    cb(e);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.fillCustomChangeProperties" id="apidoc.element.loopback.ACL.super_.prototype.fillCustomChangeProperties">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>fillCustomChangeProperties
        <span class="apidocSignatureSpan">(change, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillCustomChangeProperties = function (change, cb) {
  // no-op by default
  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const model = this.getModelCtor();
const id = this.getModelId();

model.findById(id, function(err, inst) {
  if (err) return cb(err);

  if (inst) {
    inst.<span class="apidocCodeKeywordSpan">fillCustomChangeProperties</span>(change, function() {
      const rev = Change.revisionForInst(inst);
      prepareAndDoRectify(rev);
    });
  } else {
    prepareAndDoRectify(null);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.getId" id="apidoc.element.loopback.ACL.super_.prototype.getId">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>getId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getId = function () {
  var data = this.toObject();
  if (!data) return;
  return data[this.getIdName()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (!(&#x27;throws&#x27; in options)) {
  options.throws = false;
}

var inst = this;
var data = inst.toObject(true);
var id = this.<span class="apidocCodeKeywordSpan">getId</span>();

if (!id) {
  return Model.create(this, callback);
}

// validate first
if (!options.validate) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.getIdName" id="apidoc.element.loopback.ACL.super_.prototype.getIdName">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  return this.constructor.getIdName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.isNewRecord" id="apidoc.element.loopback.ACL.super_.prototype.isNewRecord">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>isNewRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNewRecord = function () {
  throwNotAttached(this.constructor.modelName, &#x27;isNewRecord&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.patchAttributes" id="apidoc.element.loopback.ACL.super_.prototype.patchAttributes">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>patchAttributes
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAttributes(data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAttributes&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    try {
      User.validatePassword(newPassword);
    } catch (err) {
      return cb(err);
    }

    const delta = {password: newPassword};
    this.<span class="apidocCodeKeywordSpan">patchAttributes</span>(delta, options, (err, updated) =&#x3e; cb(err));
  });
  return cb.promise;
};

/**
 * Verify a user&#x27;s identity by sending them a confirmation email.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.reload" id="apidoc.element.loopback.ACL.super_.prototype.reload">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>reload
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reload(callback) {
  throwNotAttached(this.constructor.modelName, &#x27;reload&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.remove" id="apidoc.element.loopback.ACL.super_.prototype.remove">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>remove
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (cb) {
  throwNotAttached(this.constructor.modelName, &#x27;destroy&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.replaceAttributes" id="apidoc.element.loopback.ACL.super_.prototype.replaceAttributes">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>replaceAttributes
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceAttributes(data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceAttributes&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.save" id="apidoc.element.loopback.ACL.super_.prototype.save">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>save
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function (options, callback) {
  var Model = this.constructor;

  if (typeof options == &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  callback = callback || function() {
  };
  options = options || {};

  if (!(&#x27;validate&#x27; in options)) {
    options.validate = true;
  }
  if (!(&#x27;throws&#x27; in options)) {
    options.throws = false;
  }

  var inst = this;
  var data = inst.toObject(true);
  var id = this.getId();

  if (!id) {
    return Model.create(this, callback);
  }

  // validate first
  if (!options.validate) {
    return save();
  }

  inst.isValid(function(valid) {
    if (valid) {
      save();
    } else {
      var err = new Model.ValidationError(inst);
      // throws option is dangerous for async usage
      if (options.throws) {
        throw err;
      }
      callback(err, inst);
    }
  });

  // then save
  function save() {
    inst.trigger(&#x27;save&#x27;, function(saveDone) {
      inst.trigger(&#x27;update&#x27;, function(updateDone) {
        Model.upsert(inst, function(err) {
          inst._initProperties(data);
          updateDone.call(inst, function() {
            saveDone.call(inst, function() {
              callback(err, inst);
            });
          });
        });
      }, data);
    }, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.remove(cb);
    } else {
      change.<span class="apidocCodeKeywordSpan">save</span>(cb);
    }
  }
};

/**
 * Get a change&#x27;s current revision based on current data.
 * @callback  {Function} callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.setId" id="apidoc.element.loopback.ACL.super_.prototype.setId">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>setId
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setId = function (val) {
  var ds = this.getDataSource();
  this[this.getIdName()] = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Change.prototype.getModelId = function() {
  // TODO(ritch) get rid of the need to create an instance
  var Model = this.getModelCtor();
  var id = this.modelId;
  var m = new Model();
  m.<span class="apidocCodeKeywordSpan">setId</span>(id);
  return m.getId();
};

Change.prototype.getModel = function(callback) {
  var Model = this.constructor.settings.trackModel;
  var id = this.getModelId();
  Model.findById(id, callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.updateAttribute" id="apidoc.element.loopback.ACL.super_.prototype.updateAttribute">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>updateAttribute
        <span class="apidocSignatureSpan">(name, value, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAttribute(name, value, callback) {
  throwNotAttached(this.constructor.modelName, &#x27;updateAttribute&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ACL.super_.prototype.updateAttributes" id="apidoc.element.loopback.ACL.super_.prototype.updateAttributes">
        function <span class="apidocSignatureSpan">loopback.ACL.super_.prototype.</span>updateAttributes
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAttributes(data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAttributes&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.<span class="apidocCodeKeywordSpan">updateAttributes</span>(data, cb);
  });
};

/**
 * Create a change stream. [See here for more info](http://loopback.io/doc/en/lb2/Realtime-server-sent-events.html)
 *
 * @param {Object} options
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.AccessToken" id="apidoc.module.loopback.AccessToken">module loopback.AccessToken</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.AccessToken.AccessToken" id="apidoc.element.loopback.AccessToken.AccessToken">
        function <span class="apidocSignatureSpan">loopback.</span>AccessToken
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.ValidationError" id="apidoc.element.loopback.AccessToken.ValidationError">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken._ACL" id="apidoc.element.loopback.AccessToken._ACL">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken._defineChangeModel" id="apidoc.element.loopback.AccessToken._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken._getAccessTypeForMethod" id="apidoc.element.loopback.AccessToken._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken._notifyBaseObservers" id="apidoc.element.loopback.AccessToken._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken._runWhenAttachedToApp" id="apidoc.element.loopback.AccessToken._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.addListener" id="apidoc.element.loopback.AccessToken.addListener">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.afterRemote" id="apidoc.element.loopback.AccessToken.afterRemote">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.afterRemoteError" id="apidoc.element.loopback.AccessToken.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.attachTo" id="apidoc.element.loopback.AccessToken.attachTo">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.beforeRemote" id="apidoc.element.loopback.AccessToken.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.belongsToRemoting" id="apidoc.element.loopback.AccessToken.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.bulkUpdate" id="apidoc.element.loopback.AccessToken.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.changes" id="apidoc.element.loopback.AccessToken.changes">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.checkAccess" id="apidoc.element.loopback.AccessToken.checkAccess">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.checkpoint" id="apidoc.element.loopback.AccessToken.checkpoint">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.clearObservers" id="apidoc.element.loopback.AccessToken.clearObservers">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.count" id="apidoc.element.loopback.AccessToken.count">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.create" id="apidoc.element.loopback.AccessToken.create">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.createAccessTokenId" id="apidoc.element.loopback.AccessToken.createAccessTokenId">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createAccessTokenId
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createAccessTokenId = function (fn) {
  uid(this.settings.accessTokenIdLength || DEFAULT_TOKEN_LEN, function(err, guid) {
    if (err) {
      fn(err);
    } else {
      fn(null, guid);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
AccessToken.observe(&#x27;before save&#x27;, function(ctx, next) {
  if (!ctx.instance || ctx.instance.id) {
    // We are running a partial update or the instance already has an id
    return next();
  }

  AccessToken.<span class="apidocCodeKeywordSpan">createAccessTokenId</span>(function(err, id) {
    if (err) return next(err);
    ctx.instance.id = id;
    next();
  });
});

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.createChangeFilter" id="apidoc.element.loopback.AccessToken.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.createChangeStream" id="apidoc.element.loopback.AccessToken.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.createOptionsFromRemotingContext" id="apidoc.element.loopback.AccessToken.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.createUpdates" id="apidoc.element.loopback.AccessToken.createUpdates">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.currentCheckpoint" id="apidoc.element.loopback.AccessToken.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.defineProperty" id="apidoc.element.loopback.AccessToken.defineProperty">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.deleteAll" id="apidoc.element.loopback.AccessToken.deleteAll">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.deleteById" id="apidoc.element.loopback.AccessToken.deleteById">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.destroyAll" id="apidoc.element.loopback.AccessToken.destroyAll">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.destroyById" id="apidoc.element.loopback.AccessToken.destroyById">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.diff" id="apidoc.element.loopback.AccessToken.diff">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.disableRemoteMethod" id="apidoc.element.loopback.AccessToken.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.disableRemoteMethodByName" id="apidoc.element.loopback.AccessToken.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.emit" id="apidoc.element.loopback.AccessToken.emit">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.enableChangeTracking" id="apidoc.element.loopback.AccessToken.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.eventNames" id="apidoc.element.loopback.AccessToken.eventNames">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.exists" id="apidoc.element.loopback.AccessToken.exists">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.extend" id="apidoc.element.loopback.AccessToken.extend">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.find" id="apidoc.element.loopback.AccessToken.find">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.findById" id="apidoc.element.loopback.AccessToken.findById">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.AccessToken.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.findForRequest" id="apidoc.element.loopback.AccessToken.findForRequest">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findForRequest
        <span class="apidocSignatureSpan">(req, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findForRequest = function (req, options, cb) {
  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  var id = tokenIdForRequest(req, options);

  if (id) {
    this.findById(id, function(err, token) {
      if (err) {
        cb(err);
      } else if (token) {
        token.validate(function(err, isValid) {
          if (err) {
            cb(err);
          } else if (isValid) {
            cb(null, token);
          } else {
            var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
            e.status = e.statusCode = 401;
            e.code = &#x27;INVALID_TOKEN&#x27;;
            cb(e);
          }
        });
      } else {
        cb();
      }
    });
  } else {
    process.nextTick(function() {
      cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // req.accessToken.id is defined, which means that some other middleware has identified a valid user.
      // when overwriteExistingToken is not set to a truthy value, skip searching for credentials.
      rewriteUserLiteral(req, currentUserLiteral);
      return next();
    }
    // continue normal operation (as if req.accessToken was undefined)
  }
  TokenModel.<span class="apidocCodeKeywordSpan">findForRequest</span>(req, options, function(err, token) {
    req.accessToken = token || null;
    rewriteUserLiteral(req, currentUserLiteral);
    var ctx = req.loopbackContext;
    if (ctx &#x26;&#x26; ctx.active) ctx.set(&#x27;accessToken&#x27;, token);
    next(err);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.findLastChange" id="apidoc.element.loopback.AccessToken.findLastChange">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.findOne" id="apidoc.element.loopback.AccessToken.findOne">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.findOrCreate" id="apidoc.element.loopback.AccessToken.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.forEachProperty" id="apidoc.element.loopback.AccessToken.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getApp" id="apidoc.element.loopback.AccessToken.getApp">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getChangeModel" id="apidoc.element.loopback.AccessToken.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getDataSource" id="apidoc.element.loopback.AccessToken.getDataSource">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getIdName" id="apidoc.element.loopback.AccessToken.getIdName">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getMaxListeners" id="apidoc.element.loopback.AccessToken.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getPropertyType" id="apidoc.element.loopback.AccessToken.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.getSourceId" id="apidoc.element.loopback.AccessToken.getSourceId">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.handleChangeError" id="apidoc.element.loopback.AccessToken.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.hasManyRemoting" id="apidoc.element.loopback.AccessToken.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.hasOneRemoting" id="apidoc.element.loopback.AccessToken.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.isHiddenProperty" id="apidoc.element.loopback.AccessToken.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.isProtectedProperty" id="apidoc.element.loopback.AccessToken.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.listenerCount" id="apidoc.element.loopback.AccessToken.listenerCount">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.listeners" id="apidoc.element.loopback.AccessToken.listeners">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.mixin" id="apidoc.element.loopback.AccessToken.mixin">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.nestRemoting" id="apidoc.element.loopback.AccessToken.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.notifyObserversAround" id="apidoc.element.loopback.AccessToken.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.notifyObserversOf" id="apidoc.element.loopback.AccessToken.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.observe" id="apidoc.element.loopback.AccessToken.observe">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.on" id="apidoc.element.loopback.AccessToken.on">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.once" id="apidoc.element.loopback.AccessToken.once">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.patchOrCreate" id="apidoc.element.loopback.AccessToken.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.patchOrCreateWithWhere" id="apidoc.element.loopback.AccessToken.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.prependListener" id="apidoc.element.loopback.AccessToken.prependListener">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.prependOnceListener" id="apidoc.element.loopback.AccessToken.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.rectifyAllChanges" id="apidoc.element.loopback.AccessToken.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.rectifyChange" id="apidoc.element.loopback.AccessToken.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.registerProperty" id="apidoc.element.loopback.AccessToken.registerProperty">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.remoteMethod" id="apidoc.element.loopback.AccessToken.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.remove" id="apidoc.element.loopback.AccessToken.remove">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.removeAllListeners" id="apidoc.element.loopback.AccessToken.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.removeById" id="apidoc.element.loopback.AccessToken.removeById">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.removeListener" id="apidoc.element.loopback.AccessToken.removeListener">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.removeObserver" id="apidoc.element.loopback.AccessToken.removeObserver">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.replaceById" id="apidoc.element.loopback.AccessToken.replaceById">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.replaceOrCreate" id="apidoc.element.loopback.AccessToken.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.replicate" id="apidoc.element.loopback.AccessToken.replicate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.scopeRemoting" id="apidoc.element.loopback.AccessToken.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.setMaxListeners" id="apidoc.element.loopback.AccessToken.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.setup" id="apidoc.element.loopback.AccessToken.setup">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.setupRemoting" id="apidoc.element.loopback.AccessToken.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.sharedCtor" id="apidoc.element.loopback.AccessToken.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.AccessToken.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.AccessToken.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.super_" id="apidoc.element.loopback.AccessToken.super_">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.update" id="apidoc.element.loopback.AccessToken.update">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.updateAll" id="apidoc.element.loopback.AccessToken.updateAll">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.updateLastChange" id="apidoc.element.loopback.AccessToken.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.updateOrCreate" id="apidoc.element.loopback.AccessToken.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.upsert" id="apidoc.element.loopback.AccessToken.upsert">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.upsertWithWhere" id="apidoc.element.loopback.AccessToken.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validate" id="apidoc.element.loopback.AccessToken.validate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validateAsync" id="apidoc.element.loopback.AccessToken.validateAsync">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesAbsenceOf" id="apidoc.element.loopback.AccessToken.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesExclusionOf" id="apidoc.element.loopback.AccessToken.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesFormatOf" id="apidoc.element.loopback.AccessToken.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesInclusionOf" id="apidoc.element.loopback.AccessToken.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesLengthOf" id="apidoc.element.loopback.AccessToken.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesNumericalityOf" id="apidoc.element.loopback.AccessToken.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesPresenceOf" id="apidoc.element.loopback.AccessToken.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.AccessToken.validatesUniquenessOf" id="apidoc.element.loopback.AccessToken.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.AccessToken.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>






































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.AccessToken.prototype" id="apidoc.module.loopback.AccessToken.prototype">module loopback.AccessToken.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.AccessToken.prototype.validate" id="apidoc.element.loopback.AccessToken.prototype.validate">
        function <span class="apidocSignatureSpan">loopback.AccessToken.prototype.</span>validate
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (cb) {
  try {
    assert(
        this.created &#x26;&#x26; typeof this.created.getTime === &#x27;function&#x27;,
      &#x27;token.created must be a valid Date&#x27;
    );
    assert(this.ttl !== 0, &#x27;token.ttl must be not be 0&#x27;);
    assert(this.ttl, &#x27;token.ttl must exist&#x27;);
    assert(this.ttl &#x3e;= -1, &#x27;token.ttl must be &#x3e;= -1&#x27;);

    var AccessToken = this.constructor;
    var userRelation = AccessToken.relations.user; // may not be set up
    var User = userRelation &#x26;&#x26; userRelation.modelTo;

    // redefine user model if accessToken&#x27;s principalType is available
    if (this.principalType) {
      User = AccessToken.registry.findModel(this.principalType);
      if (!User) {
        process.nextTick(function() {
          return cb(null, false);
        });
      }
    }

    var now = Date.now();
    var created = this.created.getTime();
    var elapsedSeconds = (now - created) / 1000;
    var secondsToLive = this.ttl;
    var eternalTokensAllowed = !!(User &#x26;&#x26; User.settings.allowEternalTokens);
    var isEternalToken = secondsToLive === -1;
    var isValid = isEternalToken ?
      eternalTokensAllowed :
      elapsedSeconds &#x3c; secondsToLive;

    if (isValid) {
      process.nextTick(function() {
        cb(null, isValid);
      });
    } else {
      this.destroy(function(err) {
        cb(err, isValid);
      });
    }
  } catch (e) {
    process.nextTick(function() {
      cb(e);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.AccessToken.settings" id="apidoc.module.loopback.AccessToken.settings">module loopback.AccessToken.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.AccessToken.settings.base" id="apidoc.element.loopback.AccessToken.settings.base">
        function <span class="apidocSignatureSpan">loopback.AccessToken.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.AccessToken.sharedClass" id="apidoc.module.loopback.AccessToken.sharedClass">module loopback.AccessToken.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.AccessToken.sharedClass.ctor" id="apidoc.element.loopback.AccessToken.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.AccessToken.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Application" id="apidoc.module.loopback.Application">module loopback.Application</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Application.Application" id="apidoc.element.loopback.Application.Application">
        function <span class="apidocSignatureSpan">loopback.</span>Application
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.ValidationError" id="apidoc.element.loopback.Application.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Application.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application._ACL" id="apidoc.element.loopback.Application._ACL">
        function <span class="apidocSignatureSpan">loopback.Application.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application._defineChangeModel" id="apidoc.element.loopback.Application._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.Application.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application._getAccessTypeForMethod" id="apidoc.element.loopback.Application._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Application.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application._notifyBaseObservers" id="apidoc.element.loopback.Application._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Application.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application._runWhenAttachedToApp" id="apidoc.element.loopback.Application._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Application.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.addListener" id="apidoc.element.loopback.Application.addListener">
        function <span class="apidocSignatureSpan">loopback.Application.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.afterRemote" id="apidoc.element.loopback.Application.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Application.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.afterRemoteError" id="apidoc.element.loopback.Application.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Application.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.attachTo" id="apidoc.element.loopback.Application.attachTo">
        function <span class="apidocSignatureSpan">loopback.Application.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.authenticate" id="apidoc.element.loopback.Application.authenticate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>authenticate
        <span class="apidocSignatureSpan">(appId, key, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authenticate = function (appId, key, cb) {
  cb = cb || utils.createPromiseCallback();

  this.findById(appId, function(err, app) {
    if (err || !app) {
      cb(err, null);
      return cb.promise;
    }
    var result = null;
    var keyNames = [&#x27;clientKey&#x27;, &#x27;javaScriptKey&#x27;, &#x27;restApiKey&#x27;, &#x27;windowsKey&#x27;, &#x27;masterKey&#x27;];
    for (var i = 0; i &#x3c; keyNames.length; i++) {
      if (app[keyNames[i]] === key) {
        result = {
          application: app,
          keyType: keyNames[i],
        };
        break;
      }
    }
    cb(null, result);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.beforeRemote" id="apidoc.element.loopback.Application.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Application.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.belongsToRemoting" id="apidoc.element.loopback.Application.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Application.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.bulkUpdate" id="apidoc.element.loopback.Application.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.changes" id="apidoc.element.loopback.Application.changes">
        function <span class="apidocSignatureSpan">loopback.Application.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.checkAccess" id="apidoc.element.loopback.Application.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Application.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.checkpoint" id="apidoc.element.loopback.Application.checkpoint">
        function <span class="apidocSignatureSpan">loopback.Application.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.clearObservers" id="apidoc.element.loopback.Application.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Application.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.count" id="apidoc.element.loopback.Application.count">
        function <span class="apidocSignatureSpan">loopback.Application.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.create" id="apidoc.element.loopback.Application.create">
        function <span class="apidocSignatureSpan">loopback.Application.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.createChangeFilter" id="apidoc.element.loopback.Application.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.Application.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.createChangeStream" id="apidoc.element.loopback.Application.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.Application.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.createOptionsFromRemotingContext" id="apidoc.element.loopback.Application.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Application.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.createUpdates" id="apidoc.element.loopback.Application.createUpdates">
        function <span class="apidocSignatureSpan">loopback.Application.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.currentCheckpoint" id="apidoc.element.loopback.Application.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.Application.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.defineProperty" id="apidoc.element.loopback.Application.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Application.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.deleteAll" id="apidoc.element.loopback.Application.deleteAll">
        function <span class="apidocSignatureSpan">loopback.Application.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.deleteById" id="apidoc.element.loopback.Application.deleteById">
        function <span class="apidocSignatureSpan">loopback.Application.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.destroyAll" id="apidoc.element.loopback.Application.destroyAll">
        function <span class="apidocSignatureSpan">loopback.Application.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.destroyById" id="apidoc.element.loopback.Application.destroyById">
        function <span class="apidocSignatureSpan">loopback.Application.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.diff" id="apidoc.element.loopback.Application.diff">
        function <span class="apidocSignatureSpan">loopback.Application.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.disableRemoteMethod" id="apidoc.element.loopback.Application.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Application.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.disableRemoteMethodByName" id="apidoc.element.loopback.Application.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Application.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.emit" id="apidoc.element.loopback.Application.emit">
        function <span class="apidocSignatureSpan">loopback.Application.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.enableChangeTracking" id="apidoc.element.loopback.Application.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.Application.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.eventNames" id="apidoc.element.loopback.Application.eventNames">
        function <span class="apidocSignatureSpan">loopback.Application.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.exists" id="apidoc.element.loopback.Application.exists">
        function <span class="apidocSignatureSpan">loopback.Application.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.extend" id="apidoc.element.loopback.Application.extend">
        function <span class="apidocSignatureSpan">loopback.Application.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.find" id="apidoc.element.loopback.Application.find">
        function <span class="apidocSignatureSpan">loopback.Application.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.findById" id="apidoc.element.loopback.Application.findById">
        function <span class="apidocSignatureSpan">loopback.Application.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Application.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.findLastChange" id="apidoc.element.loopback.Application.findLastChange">
        function <span class="apidocSignatureSpan">loopback.Application.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.findOne" id="apidoc.element.loopback.Application.findOne">
        function <span class="apidocSignatureSpan">loopback.Application.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.findOrCreate" id="apidoc.element.loopback.Application.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.forEachProperty" id="apidoc.element.loopback.Application.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Application.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getApp" id="apidoc.element.loopback.Application.getApp">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getChangeModel" id="apidoc.element.loopback.Application.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getDataSource" id="apidoc.element.loopback.Application.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getIdName" id="apidoc.element.loopback.Application.getIdName">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getMaxListeners" id="apidoc.element.loopback.Application.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getPropertyType" id="apidoc.element.loopback.Application.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.getSourceId" id="apidoc.element.loopback.Application.getSourceId">
        function <span class="apidocSignatureSpan">loopback.Application.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.handleChangeError" id="apidoc.element.loopback.Application.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.Application.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.hasManyRemoting" id="apidoc.element.loopback.Application.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Application.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.hasOneRemoting" id="apidoc.element.loopback.Application.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Application.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.isHiddenProperty" id="apidoc.element.loopback.Application.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Application.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.isProtectedProperty" id="apidoc.element.loopback.Application.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Application.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.listenerCount" id="apidoc.element.loopback.Application.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Application.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.listeners" id="apidoc.element.loopback.Application.listeners">
        function <span class="apidocSignatureSpan">loopback.Application.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.mixin" id="apidoc.element.loopback.Application.mixin">
        function <span class="apidocSignatureSpan">loopback.Application.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.nestRemoting" id="apidoc.element.loopback.Application.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Application.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.notifyObserversAround" id="apidoc.element.loopback.Application.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Application.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.notifyObserversOf" id="apidoc.element.loopback.Application.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.observe" id="apidoc.element.loopback.Application.observe">
        function <span class="apidocSignatureSpan">loopback.Application.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.on" id="apidoc.element.loopback.Application.on">
        function <span class="apidocSignatureSpan">loopback.Application.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.once" id="apidoc.element.loopback.Application.once">
        function <span class="apidocSignatureSpan">loopback.Application.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.patchOrCreate" id="apidoc.element.loopback.Application.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.patchOrCreateWithWhere" id="apidoc.element.loopback.Application.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.Application.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.prependListener" id="apidoc.element.loopback.Application.prependListener">
        function <span class="apidocSignatureSpan">loopback.Application.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.prependOnceListener" id="apidoc.element.loopback.Application.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Application.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.rectifyAllChanges" id="apidoc.element.loopback.Application.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.Application.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.rectifyChange" id="apidoc.element.loopback.Application.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.Application.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.register" id="apidoc.element.loopback.Application.register">
        function <span class="apidocSignatureSpan">loopback.Application.</span>register
        <span class="apidocSignatureSpan">(owner, name, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (owner, name, options, cb) {
  assert(owner, &#x27;owner is required&#x27;);
  assert(name, &#x27;name is required&#x27;);

  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !cb) {
    cb = options;
    options = {};
  }
  cb = cb || utils.createPromiseCallback();

  var props = {owner: owner, name: name};
  for (var p in options) {
    if (!(p in props)) {
      props[p] = options[p];
    }
  }
  this.create(props, cb);
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.registerProperty" id="apidoc.element.loopback.Application.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Application.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.remoteMethod" id="apidoc.element.loopback.Application.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Application.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.remove" id="apidoc.element.loopback.Application.remove">
        function <span class="apidocSignatureSpan">loopback.Application.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.removeAllListeners" id="apidoc.element.loopback.Application.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Application.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.removeById" id="apidoc.element.loopback.Application.removeById">
        function <span class="apidocSignatureSpan">loopback.Application.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.removeListener" id="apidoc.element.loopback.Application.removeListener">
        function <span class="apidocSignatureSpan">loopback.Application.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.removeObserver" id="apidoc.element.loopback.Application.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Application.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.replaceById" id="apidoc.element.loopback.Application.replaceById">
        function <span class="apidocSignatureSpan">loopback.Application.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.replaceOrCreate" id="apidoc.element.loopback.Application.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.replicate" id="apidoc.element.loopback.Application.replicate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.resetKeys" id="apidoc.element.loopback.Application.resetKeys">
        function <span class="apidocSignatureSpan">loopback.Application.</span>resetKeys
        <span class="apidocSignatureSpan">(appId, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetKeys = function (appId, cb) {
  cb = cb || utils.createPromiseCallback();
  this.findById(appId, function(err, app) {
    if (err) {
      if (cb) cb(err, app);
      return;
    }
    app.resetKeys(cb);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.scopeRemoting" id="apidoc.element.loopback.Application.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Application.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.setMaxListeners" id="apidoc.element.loopback.Application.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Application.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.setup" id="apidoc.element.loopback.Application.setup">
        function <span class="apidocSignatureSpan">loopback.Application.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.setupRemoting" id="apidoc.element.loopback.Application.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.Application.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.sharedCtor" id="apidoc.element.loopback.Application.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Application.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Application.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Application.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.super_" id="apidoc.element.loopback.Application.super_">
        function <span class="apidocSignatureSpan">loopback.Application.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.update" id="apidoc.element.loopback.Application.update">
        function <span class="apidocSignatureSpan">loopback.Application.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.updateAll" id="apidoc.element.loopback.Application.updateAll">
        function <span class="apidocSignatureSpan">loopback.Application.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.updateLastChange" id="apidoc.element.loopback.Application.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.Application.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.updateOrCreate" id="apidoc.element.loopback.Application.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.upsert" id="apidoc.element.loopback.Application.upsert">
        function <span class="apidocSignatureSpan">loopback.Application.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.upsertWithWhere" id="apidoc.element.loopback.Application.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.Application.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validate" id="apidoc.element.loopback.Application.validate">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validateAsync" id="apidoc.element.loopback.Application.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesAbsenceOf" id="apidoc.element.loopback.Application.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesExclusionOf" id="apidoc.element.loopback.Application.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesFormatOf" id="apidoc.element.loopback.Application.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesInclusionOf" id="apidoc.element.loopback.Application.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesLengthOf" id="apidoc.element.loopback.Application.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesNumericalityOf" id="apidoc.element.loopback.Application.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesPresenceOf" id="apidoc.element.loopback.Application.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Application.validatesUniquenessOf" id="apidoc.element.loopback.Application.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Application.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Application.prototype" id="apidoc.module.loopback.Application.prototype">module loopback.Application.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Application.prototype.resetKeys" id="apidoc.element.loopback.Application.prototype.resetKeys">
        function <span class="apidocSignatureSpan">loopback.Application.prototype.</span>resetKeys
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetKeys = function (cb) {
  this.clientKey = generateKey(&#x27;client&#x27;);
  this.javaScriptKey = generateKey(&#x27;javaScript&#x27;);
  this.restApiKey = generateKey(&#x27;restApi&#x27;);
  this.windowsKey = generateKey(&#x27;windows&#x27;);
  this.masterKey = generateKey(&#x27;master&#x27;);
  this.modified = new Date();
  this.save(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Application.settings" id="apidoc.module.loopback.Application.settings">module loopback.Application.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.Application.settings.base" id="apidoc.element.loopback.Application.settings.base">
        function <span class="apidocSignatureSpan">loopback.Application.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Application.sharedClass" id="apidoc.module.loopback.Application.sharedClass">module loopback.Application.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Application.sharedClass.ctor" id="apidoc.element.loopback.Application.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.Application.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change" id="apidoc.module.loopback.Change">module loopback.Change</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Change.Change" id="apidoc.element.loopback.Change.Change">
        function <span class="apidocSignatureSpan">loopback.</span>Change
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict" id="apidoc.element.loopback.Change.Conflict">
        function <span class="apidocSignatureSpan">loopback.Change.</span>Conflict
        <span class="apidocSignatureSpan">(modelId, SourceModel, TargetModel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Conflict(modelId, SourceModel, TargetModel) {
  this.SourceModel = SourceModel;
  this.TargetModel = TargetModel;
  this.SourceChange = SourceModel.getChangeModel();
  this.TargetChange = TargetModel.getChangeModel();
  this.modelId = modelId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
debug(&#x27;\treplication finished&#x27;);
debug(&#x27;\t\t%s conflict(s) detected&#x27;, diff.conflicts.length);
debug(&#x27;\t\t%s change(s) applied&#x27;, updates ? updates.length : 0);
debug(&#x27;\t\tnew checkpoints: { source: %j, target: %j }&#x27;,
  newSourceCp, newTargetCp);

var conflicts = diff.conflicts.map(function(change) {
  return new Change.<span class="apidocCodeKeywordSpan">Conflict</span>(
    change.modelId, sourceModel, targetModel
  );
});

if (conflicts.length) {
  sourceModel.emit(&#x27;conflicts&#x27;, conflicts);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.ValidationError" id="apidoc.element.loopback.Change.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Change.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change._ACL" id="apidoc.element.loopback.Change._ACL">
        function <span class="apidocSignatureSpan">loopback.Change.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change._defineChangeModel" id="apidoc.element.loopback.Change._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.Change.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change._getAccessTypeForMethod" id="apidoc.element.loopback.Change._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Change.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change._notifyBaseObservers" id="apidoc.element.loopback.Change._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Change.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change._runWhenAttachedToApp" id="apidoc.element.loopback.Change._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Change.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.addListener" id="apidoc.element.loopback.Change.addListener">
        function <span class="apidocSignatureSpan">loopback.Change.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.afterRemote" id="apidoc.element.loopback.Change.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Change.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.afterRemoteError" id="apidoc.element.loopback.Change.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Change.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.attachTo" id="apidoc.element.loopback.Change.attachTo">
        function <span class="apidocSignatureSpan">loopback.Change.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.beforeRemote" id="apidoc.element.loopback.Change.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Change.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.belongsToRemoting" id="apidoc.element.loopback.Change.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Change.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.bothDeleted" id="apidoc.element.loopback.Change.bothDeleted">
        function <span class="apidocSignatureSpan">loopback.Change.</span>bothDeleted
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bothDeleted = function (a, b) {
  return a.type() === Change.DELETE &#x26;&#x26;
    b.type() === Change.DELETE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Change} change
 * @return {Boolean}
 */

Change.prototype.conflictsWith = function(change) {
  if (!change) return false;
  if (this.equals(change)) return false;
  if (Change.<span class="apidocCodeKeywordSpan">bothDeleted</span>(this, change)) return false;
  if (this.isBasedOn(change)) return false;
  return true;
};

/**
 * Are both changes deletes?
 * @param  {Change} a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.bulkUpdate" id="apidoc.element.loopback.Change.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.changes" id="apidoc.element.loopback.Change.changes">
        function <span class="apidocSignatureSpan">loopback.Change.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.checkAccess" id="apidoc.element.loopback.Change.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Change.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.checkpoint" id="apidoc.element.loopback.Change.checkpoint">
        function <span class="apidocSignatureSpan">loopback.Change.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.clearObservers" id="apidoc.element.loopback.Change.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Change.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.count" id="apidoc.element.loopback.Change.count">
        function <span class="apidocSignatureSpan">loopback.Change.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.create" id="apidoc.element.loopback.Change.create">
        function <span class="apidocSignatureSpan">loopback.Change.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.createChangeFilter" id="apidoc.element.loopback.Change.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.Change.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.createChangeStream" id="apidoc.element.loopback.Change.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.Change.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.createOptionsFromRemotingContext" id="apidoc.element.loopback.Change.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Change.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.createUpdates" id="apidoc.element.loopback.Change.createUpdates">
        function <span class="apidocSignatureSpan">loopback.Change.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.currentCheckpoint" id="apidoc.element.loopback.Change.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.Change.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.defineProperty" id="apidoc.element.loopback.Change.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Change.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.deleteAll" id="apidoc.element.loopback.Change.deleteAll">
        function <span class="apidocSignatureSpan">loopback.Change.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.deleteById" id="apidoc.element.loopback.Change.deleteById">
        function <span class="apidocSignatureSpan">loopback.Change.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.destroyAll" id="apidoc.element.loopback.Change.destroyAll">
        function <span class="apidocSignatureSpan">loopback.Change.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.destroyById" id="apidoc.element.loopback.Change.destroyById">
        function <span class="apidocSignatureSpan">loopback.Change.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.diff" id="apidoc.element.loopback.Change.diff">
        function <span class="apidocSignatureSpan">loopback.Change.</span>diff
        <span class="apidocSignatureSpan">(modelName, since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (modelName, since, remoteChanges, callback) {
  callback = callback || utils.createPromiseCallback();

  if (!Array.isArray(remoteChanges) || remoteChanges.length === 0) {
    callback(null, {deltas: [], conflicts: []});
    return callback.promise;
  }
  var remoteChangeIndex = {};
  var modelIds = [];
  remoteChanges.forEach(function(ch) {
    modelIds.push(ch.modelId);
    remoteChangeIndex[ch.modelId] = new Change(ch);
  });

  // normalize `since`
  since = Number(since) || 0;
  this.find({
    where: {
      modelName: modelName,
      modelId: {inq: modelIds},
    },
  }, function(err, allLocalChanges) {
    if (err) return callback(err);
    var deltas = [];
    var conflicts = [];
    var localModelIds = [];

    var localChanges = allLocalChanges.filter(function(c) {
      return c.checkpoint &#x3e;= since;
    });

    localChanges.forEach(function(localChange) {
      localChange = new Change(localChange);
      localModelIds.push(localChange.modelId);
      var remoteChange = remoteChangeIndex[localChange.modelId];
      if (remoteChange &#x26;&#x26; !localChange.equals(remoteChange)) {
        if (remoteChange.conflictsWith(localChange)) {
          remoteChange.debug(&#x27;remote conflict&#x27;);
          localChange.debug(&#x27;local conflict&#x27;);
          conflicts.push(localChange);
        } else {
          remoteChange.debug(&#x27;remote delta&#x27;);
          deltas.push(remoteChange);
        }
      }
    });

    modelIds.forEach(function(id) {
      if (localModelIds.indexOf(id) !== -1) return;

      var d = remoteChangeIndex[id];
      var oldChange = allLocalChanges.filter(function(c) {
        return c.modelId === id;
      })[0];

      if (oldChange) {
        d.prev = oldChange.rev;
      } else {
        d.prev = null;
      }

      deltas.push(d);
    });

    callback(null, {
      deltas: deltas,
      conflicts: conflicts,
    });
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.disableRemoteMethod" id="apidoc.element.loopback.Change.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Change.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.disableRemoteMethodByName" id="apidoc.element.loopback.Change.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Change.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.emit" id="apidoc.element.loopback.Change.emit">
        function <span class="apidocSignatureSpan">loopback.Change.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.enableChangeTracking" id="apidoc.element.loopback.Change.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.Change.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.eventNames" id="apidoc.element.loopback.Change.eventNames">
        function <span class="apidocSignatureSpan">loopback.Change.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.exists" id="apidoc.element.loopback.Change.exists">
        function <span class="apidocSignatureSpan">loopback.Change.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.extend" id="apidoc.element.loopback.Change.extend">
        function <span class="apidocSignatureSpan">loopback.Change.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.find" id="apidoc.element.loopback.Change.find">
        function <span class="apidocSignatureSpan">loopback.Change.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.findById" id="apidoc.element.loopback.Change.findById">
        function <span class="apidocSignatureSpan">loopback.Change.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Change.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.findLastChange" id="apidoc.element.loopback.Change.findLastChange">
        function <span class="apidocSignatureSpan">loopback.Change.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.findOne" id="apidoc.element.loopback.Change.findOne">
        function <span class="apidocSignatureSpan">loopback.Change.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.findOrCreate" id="apidoc.element.loopback.Change.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.findOrCreateChange" id="apidoc.element.loopback.Change.findOrCreateChange">
        function <span class="apidocSignatureSpan">loopback.Change.</span>findOrCreateChange
        <span class="apidocSignatureSpan">(modelName, modelId, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOrCreateChange = function (modelName, modelId, callback) {
  assert(this.registry.findModel(modelName), modelName + &#x27; does not exist&#x27;);
  callback = callback || utils.createPromiseCallback();
  var id = this.idForModel(modelName, modelId);
  var Change = this;

  this.findById(id, function(err, change) {
    if (err) return callback(err);
    if (change) {
      callback(null, change);
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.updateOrCreate(ch, callback);
    }
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var Change = this;
    var errors = [];

    callback = callback || utils.createPromiseCallback();

    var tasks = modelIds.map(function(id) {
      return function(cb) {
Change.<span class="apidocCodeKeywordSpan">findOrCreateChange</span>(modelName, id, function(err, change) {
  if (err) return next(err);
  change.rectify(next);
});

function next(err) {
  if (err) {
    err.modelName = modelName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.forEachProperty" id="apidoc.element.loopback.Change.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Change.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getApp" id="apidoc.element.loopback.Change.getApp">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getChangeModel" id="apidoc.element.loopback.Change.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getCheckpointModel" id="apidoc.element.loopback.Change.getCheckpointModel">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getCheckpointModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCheckpointModel = function () {
  var checkpointModel = this.Checkpoint;
  if (checkpointModel) return checkpointModel;
  // FIXME(bajtos) This code creates multiple different models with the same
  // model name, which is not a valid supported usage of juggler&#x27;s API.
  this.Checkpoint = checkpointModel = loopback.Checkpoint.extend(&#x27;checkpoint&#x27;);
  assert(this.dataSource, &#x27;Cannot getCheckpointModel(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);
  checkpointModel.attachTo(this.dataSource);
  return checkpointModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Create a checkpoint.
 *
 * @param  {Function} callback
 */

PersistedModel.checkpoint = function(cb) {
  var Checkpoint = this.getChangeModel().<span class="apidocCodeKeywordSpan">getCheckpointModel</span>();
  Checkpoint.bumpLastSeq(cb);
};

/**
 * Get the current checkpoint ID.
 *
 * @callback {Function} callback Callback function called with `(err, currentCheckpointId)` arguments.  Required.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getDataSource" id="apidoc.element.loopback.Change.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getIdName" id="apidoc.element.loopback.Change.getIdName">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getMaxListeners" id="apidoc.element.loopback.Change.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getPropertyType" id="apidoc.element.loopback.Change.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.getSourceId" id="apidoc.element.loopback.Change.getSourceId">
        function <span class="apidocSignatureSpan">loopback.Change.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.handleChangeError" id="apidoc.element.loopback.Change.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.Change.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.hasManyRemoting" id="apidoc.element.loopback.Change.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Change.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.hasOneRemoting" id="apidoc.element.loopback.Change.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Change.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.hash" id="apidoc.element.loopback.Change.hash">
        function <span class="apidocSignatureSpan">loopback.Change.</span>hash
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hash = function (str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .update(str)
    .digest(&#x27;hex&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {String} modelName
 * @param  {String} modelId
 * @return {String}
 */

Change.idForModel = function(modelName, modelId) {
  return this.<span class="apidocCodeKeywordSpan">hash</span>([modelName, modelId].join(&#x27;-&#x27;));
};

/**
 * Find or create a change for the given model.
 *
 * @param  {String}   modelName
 * @param  {String}   modelId
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.idForModel" id="apidoc.element.loopback.Change.idForModel">
        function <span class="apidocSignatureSpan">loopback.Change.</span>idForModel
        <span class="apidocSignatureSpan">(modelName, modelId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idForModel = function (modelName, modelId) {
  return this.hash([modelName, modelId].join(&#x27;-&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  PersistedModel.setup.call(this);
  var Change = this;

  Change.getter.id = function() {
    var hasModel = this.modelName &#x26;&#x26; this.modelId;
    if (!hasModel) return null;

    return Change.<span class="apidocCodeKeywordSpan">idForModel</span>(this.modelName, this.modelId);
  };
};
Change.setup();

/**
 * Track the recent change of the given modelIds.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.isHiddenProperty" id="apidoc.element.loopback.Change.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Change.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.isProtectedProperty" id="apidoc.element.loopback.Change.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Change.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.listenerCount" id="apidoc.element.loopback.Change.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Change.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.listeners" id="apidoc.element.loopback.Change.listeners">
        function <span class="apidocSignatureSpan">loopback.Change.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.mixin" id="apidoc.element.loopback.Change.mixin">
        function <span class="apidocSignatureSpan">loopback.Change.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.nestRemoting" id="apidoc.element.loopback.Change.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Change.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.notifyObserversAround" id="apidoc.element.loopback.Change.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Change.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.notifyObserversOf" id="apidoc.element.loopback.Change.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.observe" id="apidoc.element.loopback.Change.observe">
        function <span class="apidocSignatureSpan">loopback.Change.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.on" id="apidoc.element.loopback.Change.on">
        function <span class="apidocSignatureSpan">loopback.Change.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.once" id="apidoc.element.loopback.Change.once">
        function <span class="apidocSignatureSpan">loopback.Change.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.patchOrCreate" id="apidoc.element.loopback.Change.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.patchOrCreateWithWhere" id="apidoc.element.loopback.Change.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.Change.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prependListener" id="apidoc.element.loopback.Change.prependListener">
        function <span class="apidocSignatureSpan">loopback.Change.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prependOnceListener" id="apidoc.element.loopback.Change.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Change.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.rectifyAll" id="apidoc.element.loopback.Change.rectifyAll">
        function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyAll
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAll = function (cb) {
  debug(&#x27;rectify all&#x27;);
  var Change = this;
  // this should be optimized
  this.find(function(err, changes) {
    if (err) return cb(err);
    async.each(
      changes,
      function(c, next) { c.rectify(next); },
      cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().<span class="apidocCodeKeywordSpan">rectifyAll</span>(callback);
};

/**
 * Handle a change error. Override this method in a subclassing model to customize
 * change error handling.
 *
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.rectifyAllChanges" id="apidoc.element.loopback.Change.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.rectifyChange" id="apidoc.element.loopback.Change.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.rectifyModelChanges" id="apidoc.element.loopback.Change.rectifyModelChanges">
        function <span class="apidocSignatureSpan">loopback.Change.</span>rectifyModelChanges
        <span class="apidocSignatureSpan">(modelName, modelIds, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyModelChanges = function (modelName, modelIds, callback) {
  var Change = this;
  var errors = [];

  callback = callback || utils.createPromiseCallback();

  var tasks = modelIds.map(function(id) {
    return function(cb) {
      Change.findOrCreateChange(modelName, id, function(err, change) {
        if (err) return next(err);
        change.rectify(next);
      });

      function next(err) {
        if (err) {
          err.modelName = modelName;
          err.modelId = id;
          errors.push(err);
        }
        cb();
      }
    };
  });

  async.parallel(tasks, function(err) {
    if (err) return callback(err);
    if (errors.length) {
      var desc = errors
        .map(function(e) {
          return &#x27;#&#x27; + e.modelId + &#x27; - &#x27; + e.toString();
        })
        .join(&#x27;\n&#x27;);

      var msg = g.f(&#x27;Cannot rectify %s changes:\n%s&#x27;, modelName, desc);
      err = new Error(msg);
      err.details = {errors: errors};
      return callback(err);
    }
    callback();
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (rev !== change.prev) {
  debug(&#x27;Detected non-rectified change of %s %j&#x27;,
    Model.modelName, id);
  debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
  debug(&#x27;\tActual revision:   %s&#x27;, rev);
  conflicts.push(change);
  return Change.<span class="apidocCodeKeywordSpan">rectifyModelChanges</span>(Model.modelName, [id], cb);
}

// TODO(bajtos) modify `data` so that it instructs
// the connector to remove any properties included in &#x22;inst&#x22;
// but not included in `data`
// See https://github.com/strongloop/loopback/issues/1215
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.registerProperty" id="apidoc.element.loopback.Change.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Change.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.remoteMethod" id="apidoc.element.loopback.Change.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Change.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.remove" id="apidoc.element.loopback.Change.remove">
        function <span class="apidocSignatureSpan">loopback.Change.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.removeAllListeners" id="apidoc.element.loopback.Change.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Change.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.removeById" id="apidoc.element.loopback.Change.removeById">
        function <span class="apidocSignatureSpan">loopback.Change.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.removeListener" id="apidoc.element.loopback.Change.removeListener">
        function <span class="apidocSignatureSpan">loopback.Change.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.removeObserver" id="apidoc.element.loopback.Change.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Change.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.replaceById" id="apidoc.element.loopback.Change.replaceById">
        function <span class="apidocSignatureSpan">loopback.Change.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.replaceOrCreate" id="apidoc.element.loopback.Change.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.replicate" id="apidoc.element.loopback.Change.replicate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.revisionForInst" id="apidoc.element.loopback.Change.revisionForInst">
        function <span class="apidocSignatureSpan">loopback.Change.</span>revisionForInst
        <span class="apidocSignatureSpan">(inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">revisionForInst = function (inst) {
  assert(inst, &#x27;Change.revisionForInst() requires an instance object.&#x27;);
  return this.hash(CJSON.stringify(inst));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  callback(null, dataLookup);
});
  }

  function applyUpdate(Model, id, current, data, change, conflicts, options, cb) {
var Change = Model.getChangeModel();
var rev = current ?  Change.<span class="apidocCodeKeywordSpan">revisionForInst</span>(current) : null;

if (rev !== change.prev) {
  debug(&#x27;Detected non-rectified change of %s %j&#x27;,
    Model.modelName, id);
  debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
  debug(&#x27;\tActual revision:   %s&#x27;, rev);
  conflicts.push(change);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.scopeRemoting" id="apidoc.element.loopback.Change.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Change.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.setMaxListeners" id="apidoc.element.loopback.Change.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Change.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.setup" id="apidoc.element.loopback.Change.setup">
        function <span class="apidocSignatureSpan">loopback.Change.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function () {
  PersistedModel.setup.call(this);
  var Change = this;

  Change.getter.id = function() {
    var hasModel = this.modelName &#x26;&#x26; this.modelId;
    if (!hasModel) return null;

    return Change.idForModel(this.modelName, this.modelId);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.setupRemoting" id="apidoc.element.loopback.Change.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.Change.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.sharedCtor" id="apidoc.element.loopback.Change.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Change.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Change.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Change.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.super_" id="apidoc.element.loopback.Change.super_">
        function <span class="apidocSignatureSpan">loopback.Change.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.update" id="apidoc.element.loopback.Change.update">
        function <span class="apidocSignatureSpan">loopback.Change.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.updateAll" id="apidoc.element.loopback.Change.updateAll">
        function <span class="apidocSignatureSpan">loopback.Change.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.updateLastChange" id="apidoc.element.loopback.Change.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.Change.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.updateOrCreate" id="apidoc.element.loopback.Change.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.upsert" id="apidoc.element.loopback.Change.upsert">
        function <span class="apidocSignatureSpan">loopback.Change.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.upsertWithWhere" id="apidoc.element.loopback.Change.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.Change.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validate" id="apidoc.element.loopback.Change.validate">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validateAsync" id="apidoc.element.loopback.Change.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesAbsenceOf" id="apidoc.element.loopback.Change.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesExclusionOf" id="apidoc.element.loopback.Change.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesFormatOf" id="apidoc.element.loopback.Change.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesInclusionOf" id="apidoc.element.loopback.Change.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesLengthOf" id="apidoc.element.loopback.Change.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesNumericalityOf" id="apidoc.element.loopback.Change.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesPresenceOf" id="apidoc.element.loopback.Change.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.validatesUniquenessOf" id="apidoc.element.loopback.Change.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Change.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>












































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change.Conflict" id="apidoc.module.loopback.Change.Conflict">module loopback.Change.Conflict</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.Conflict" id="apidoc.element.loopback.Change.Conflict.Conflict">
        function <span class="apidocSignatureSpan">loopback.Change.</span>Conflict
        <span class="apidocSignatureSpan">(modelId, SourceModel, TargetModel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Conflict(modelId, SourceModel, TargetModel) {
  this.SourceModel = SourceModel;
  this.TargetModel = TargetModel;
  this.SourceChange = SourceModel.getChangeModel();
  this.TargetChange = TargetModel.getChangeModel();
  this.modelId = modelId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
debug(&#x27;\treplication finished&#x27;);
debug(&#x27;\t\t%s conflict(s) detected&#x27;, diff.conflicts.length);
debug(&#x27;\t\t%s change(s) applied&#x27;, updates ? updates.length : 0);
debug(&#x27;\t\tnew checkpoints: { source: %j, target: %j }&#x27;,
  newSourceCp, newTargetCp);

var conflicts = diff.conflicts.map(function(change) {
  return new Change.<span class="apidocCodeKeywordSpan">Conflict</span>(
    change.modelId, sourceModel, targetModel
  );
});

if (conflicts.length) {
  sourceModel.emit(&#x27;conflicts&#x27;, conflicts);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change.Conflict.prototype" id="apidoc.module.loopback.Change.Conflict.prototype">module loopback.Change.Conflict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.changes" id="apidoc.element.loopback.Change.Conflict.prototype.changes">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>changes
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (cb) {
  var conflict = this;
  var sourceChange, targetChange;

  async.parallel([
    getSourceChange,
    getTargetChange,
  ], done);

  function getSourceChange(cb) {
    var SourceModel = conflict.SourceModel;
    SourceModel.findLastChange(conflict.modelId, function(err, change) {
      if (err) return cb(err);
      sourceChange = change;
      cb();
    });
  }

  function getTargetChange(cb) {
    var TargetModel = conflict.TargetModel;
    TargetModel.findLastChange(conflict.modelId, function(err, change) {
      if (err) return cb(err);
      targetChange = change;
      cb();
    });
  }

  function done(err) {
    if (err) return cb(err);
    cb(null, sourceChange, targetChange);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.models" id="apidoc.element.loopback.Change.Conflict.prototype.models">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>models
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">models = function (cb) {
  var conflict = this;
  var SourceModel = this.SourceModel;
  var TargetModel = this.TargetModel;
  var source, target;

  async.parallel([
    getSourceModel,
    getTargetModel,
  ], done);

  function getSourceModel(cb) {
    SourceModel.findById(conflict.modelId, function(err, model) {
      if (err) return cb(err);
      source = model;
      cb();
    });
  }

  function getTargetModel(cb) {
    TargetModel.findById(conflict.modelId, function(err, model) {
      if (err) return cb(err);
      target = model;
      cb();
    });
  }

  function done(err) {
    if (err) return cb(err);
    cb(null, source, target);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var modelName = Model.modelName;
this.models[modelName] =
  this.models[classify(modelName)] =
    this.models[camelize(modelName)] = Model;

this.<span class="apidocCodeKeywordSpan">models</span>().push(Model);

if (isPublic &#x26;&#x26; Model.sharedClass) {
  this.remotes().defineObjectType(Model.modelName, function(data) {
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.resolve" id="apidoc.element.loopback.Change.Conflict.prototype.resolve">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolve
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.updateLastChange(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },
},
mochaTest: {
  &#x27;unit&#x27;: {
    src: &#x27;test/*.js&#x27;,
    options: {
      reporter: &#x27;dot&#x27;,
      require: require.<span class="apidocCodeKeywordSpan">resolve</span>(&#x27;./test/helpers/use-english.js&#x27;),
    },
  },
  &#x27;unit-xml&#x27;: {
    src: &#x27;test/*.js&#x27;,
    options: {
      reporter: &#x27;xunit&#x27;,
      captureFile: &#x27;xunit.xml&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.resolveManually" id="apidoc.element.loopback.Change.Conflict.prototype.resolveManually">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolveManually
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveManually = function (data, cb) {
  var conflict = this;
  if (!data) {
    return conflict.SourceModel.deleteById(conflict.modelId, done);
  }

  conflict.models(function(err, source, target) {
    if (err) return done(err);
    var inst = source || new conflict.SourceModel(target);
    inst.setAttributes(data);
    inst.save(function(err) {
      if (err) return done(err);
      conflict.resolve(done);
    });
  });

  function done(err) {
    // don&#x27;t forward any cb arguments from internal calls
    cb(err);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.resolveUsingSource" id="apidoc.element.loopback.Change.Conflict.prototype.resolveUsingSource">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolveUsingSource
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveUsingSource = function (cb) {
  this.resolve(function(err) {
    // don&#x27;t forward any cb arguments from resolve()
    cb(err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.resolveUsingTarget" id="apidoc.element.loopback.Change.Conflict.prototype.resolveUsingTarget">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>resolveUsingTarget
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveUsingTarget = function (cb) {
  var conflict = this;

  conflict.models(function(err, source, target) {
    if (err) return done(err);
    if (target === null) {
      return conflict.SourceModel.deleteById(conflict.modelId, done);
    }
    var inst = new conflict.SourceModel(
      target.toObject(),
      {persisted: true});
    inst.save(done);
  });

  function done(err) {
    // don&#x27;t forward any cb arguments from internal calls
    cb(err);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Return a new Conflict instance with swapped Source and Target models.
 *
 * This is useful when resolving a conflict in one-way
 * replication, where the source data must not be changed:
 *
 * ```js
 * conflict.swapParties().<span class="apidocCodeKeywordSpan">resolveUsingTarget</span>(cb);
 * ```
 *
 * @returns {Conflict} A new Conflict instance.
 */
Conflict.prototype.swapParties = function() {
  var Ctor = this.constructor;
  return new Ctor(this.modelId, this.TargetModel, this.SourceModel);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.swapParties" id="apidoc.element.loopback.Change.Conflict.prototype.swapParties">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>swapParties
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swapParties = function () {
  var Ctor = this.constructor;
  return new Ctor(this.modelId, this.TargetModel, this.SourceModel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Return a new Conflict instance with swapped Source and Target models.
 *
 * This is useful when resolving a conflict in one-way
 * replication, where the source data must not be changed:
 *
 * ```js
 * conflict.<span class="apidocCodeKeywordSpan">swapParties</span>().resolveUsingTarget(cb);
 * ```
 *
 * @returns {Conflict} A new Conflict instance.
 */
Conflict.prototype.swapParties = function() {
  var Ctor = this.constructor;
  return new Ctor(this.modelId, this.TargetModel, this.SourceModel);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.Conflict.prototype.type" id="apidoc.element.loopback.Change.Conflict.prototype.type">
        function <span class="apidocSignatureSpan">loopback.Change.Conflict.prototype.</span>type
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function (cb) {
  var conflict = this;
  this.changes(function(err, sourceChange, targetChange) {
    if (err) return cb(err);
    var sourceChangeType = sourceChange.type();
    var targetChangeType = targetChange.type();
    if (sourceChangeType === Change.UPDATE &#x26;&#x26; targetChangeType === Change.UPDATE) {
      return cb(null, Change.UPDATE);
    }
    if (sourceChangeType === Change.DELETE || targetChangeType === Change.DELETE) {
      return cb(null, Change.DELETE);
    }
    return cb(null, Change.UNKNOWN);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.<span class="apidocCodeKeywordSpan">type</span>() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
};

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change.getter" id="apidoc.module.loopback.Change.getter">module loopback.Change.getter</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Change.getter.id" id="apidoc.element.loopback.Change.getter.id">
        function <span class="apidocSignatureSpan">loopback.Change.getter.</span>id
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">id = function () {
  var hasModel = this.modelName &#x26;&#x26; this.modelId;
  if (!hasModel) return null;

  return Change.idForModel(this.modelName, this.modelId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change.prototype" id="apidoc.module.loopback.Change.prototype">module loopback.Change.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.conflictsWith" id="apidoc.element.loopback.Change.prototype.conflictsWith">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>conflictsWith
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conflictsWith = function (change) {
  if (!change) return false;
  if (this.equals(change)) return false;
  if (Change.bothDeleted(this, change)) return false;
  if (this.isBasedOn(change)) return false;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

localChanges.forEach(function(localChange) {
  localChange = new Change(localChange);
  localModelIds.push(localChange.modelId);
  var remoteChange = remoteChangeIndex[localChange.modelId];
  if (remoteChange &#x26;&#x26; !localChange.equals(remoteChange)) {
    if (remoteChange.<span class="apidocCodeKeywordSpan">conflictsWith</span>(localChange)) {
      remoteChange.debug(&#x27;remote conflict&#x27;);
      localChange.debug(&#x27;local conflict&#x27;);
      conflicts.push(localChange);
    } else {
      remoteChange.debug(&#x27;remote delta&#x27;);
      deltas.push(remoteChange);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.currentRevision" id="apidoc.element.loopback.Change.prototype.currentRevision">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>currentRevision
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentRevision = function (cb) {
  cb = cb || utils.createPromiseCallback();
  var model = this.getModelCtor();
  var id = this.getModelId();
  model.findById(id, function(err, inst) {
    if (err) return cb(err);
    if (inst) {
      cb(null, Change.revisionForInst(inst));
    } else {
      cb(null, null);
    }
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.debug" id="apidoc.element.loopback.Change.prototype.debug">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debug = function () {
  if (debug.enabled) {
    var args = Array.prototype.slice.call(arguments);
    args[0] = args[0] + &#x27; %s&#x27;;
    args.push(this.modelName);
    debug.apply(this, args);
    debug(&#x27;\tid&#x27;, this.id);
    debug(&#x27;\trev&#x27;, this.rev);
    debug(&#x27;\tprev&#x27;, this.prev);
    debug(&#x27;\tcheckpoint&#x27;, this.checkpoint);
    debug(&#x27;\tmodelName&#x27;, this.modelName);
    debug(&#x27;\tmodelId&#x27;, this.modelId);
    debug(&#x27;\ttype&#x27;, this.type());
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
}

if (debug.enabled) {
  debug(&#x27;The following ACLs were searched: &#x27;);
  acls.forEach(function(acl) {
    acl.<span class="apidocCodeKeywordSpan">debug</span>();
    debug(&#x27;with score:&#x27;, acl.score(req));
  });
}
var res = new AccessRequest({
  model: req.model,
  property: req.property,
  accessType: req.accessType,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.equals" id="apidoc.element.loopback.Change.prototype.equals">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>equals
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (change) {
  if (!change) return false;
  var thisRev = this.rev || null;
  var thatRev = change.rev || null;
  return thisRev === thatRev;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} [principalName] The principal name
 * @returns {boolean}
 */
AccessContext.prototype.addPrincipal = function(principalType, principalId, principalName) {
  var principal = new Principal(principalType, principalId, principalName);
  for (var i = 0; i &#x3c; this.principals.length; i++) {
    var p = this.principals[i];
    if (p.<span class="apidocCodeKeywordSpan">equals</span>(principal)) {
      return false;
    }
  }
  this.principals.push(principal);
  return true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.getModel" id="apidoc.element.loopback.Change.prototype.getModel">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>getModel
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModel = function (callback) {
  var Model = this.constructor.settings.trackModel;
  var id = this.getModelId();
  Model.findById(id, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = context || {};

assert(context.registry,
  &#x27;Application registry is mandatory in AccessContext but missing in provided context&#x27;);
this.registry = context.registry;
this.principals = context.principals || [];
var model = context.model;
model = (&#x27;string&#x27; === typeof model) ? this.registry.<span class="apidocCodeKeywordSpan">getModel</span>(model) : model
;
this.model = model;
this.modelName = model &#x26;&#x26; model.modelName;

this.modelId = context.id || context.modelId;
this.property = context.property || AccessContext.ALL;

this.method = context.method;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.getModelCtor" id="apidoc.element.loopback.Change.prototype.getModelCtor">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>getModelCtor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModelCtor = function () {
  return this.constructor.settings.trackModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var change = this;
    var currentRev = this.rev;

    change.debug(&#x27;rectify change&#x27;);

    cb = cb || utils.createPromiseCallback();

    const model = this.<span class="apidocCodeKeywordSpan">getModelCtor</span>();
    const id = this.getModelId();

    model.findById(id, function(err, inst) {
if (err) return cb(err);

if (inst) {
  inst.fillCustomChangeProperties(change, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.getModelId" id="apidoc.element.loopback.Change.prototype.getModelId">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>getModelId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModelId = function () {
  // TODO(ritch) get rid of the need to create an instance
  var Model = this.getModelCtor();
  var id = this.modelId;
  var m = new Model();
  m.setId(id);
  return m.getId();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.find(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.<span class="apidocCodeKeywordSpan">getModelId</span>();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
    if (err) return callback(err);
    var modelIds = models.map(function(m) {
      return m[idName].toString();
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.isBasedOn" id="apidoc.element.loopback.Change.prototype.isBasedOn">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>isBasedOn
        <span class="apidocSignatureSpan">(change)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBasedOn = function (change) {
  return this.prev === change.rev;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Boolean}
 */

Change.prototype.conflictsWith = function(change) {
  if (!change) return false;
  if (this.equals(change)) return false;
  if (Change.bothDeleted(this, change)) return false;
  if (this.<span class="apidocCodeKeywordSpan">isBasedOn</span>(change)) return false;
  return true;
};

/**
 * Are both changes deletes?
 * @param  {Change} a
 * @param  {Change} b
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.rectify" id="apidoc.element.loopback.Change.prototype.rectify">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>rectify
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectify = function (cb) {
  var change = this;
  var currentRev = this.rev;

  change.debug(&#x27;rectify change&#x27;);

  cb = cb || utils.createPromiseCallback();

  const model = this.getModelCtor();
  const id = this.getModelId();

  model.findById(id, function(err, inst) {
    if (err) return cb(err);

    if (inst) {
      inst.fillCustomChangeProperties(change, function() {
        const rev = Change.revisionForInst(inst);
        prepareAndDoRectify(rev);
      });
    } else {
      prepareAndDoRectify(null);
    }
  });

  return cb.promise;

  function prepareAndDoRectify(rev) {
    // avoid setting rev and prev to the same value
    if (currentRev === rev) {
      change.debug(&#x27;rev and prev are equal (not updating anything)&#x27;);
      return cb(null, change);
    }

    // FIXME(@bajtos) Allow callers to pass in the checkpoint value
    // (or even better - a memoized async function to get the cp value)
    // That will enable `rectifyAll` to cache the checkpoint value
    change.constructor.getCheckpointModel().current(
      function(err, checkpoint) {
        if (err) return cb(err);
        doRectify(checkpoint, rev);
      }
    );
  }

  function doRectify(checkpoint, rev) {
    if (rev) {
      if (currentRev === rev) {
        change.debug(&#x27;ASSERTION FAILED: Change currentRev==rev &#x27; +
          &#x27;should have been already handled&#x27;);
        return cb(null, change);
      } else {
        change.rev = rev;
        change.debug(&#x27;updated revision (was &#x27; + currentRev + &#x27;)&#x27;);
        if (change.checkpoint !== checkpoint) {
          // previous revision is updated only across checkpoints
          change.prev = currentRev;
          change.debug(&#x27;updated prev&#x27;);
        }
      }
    } else {
      change.rev = null;
      change.debug(&#x27;updated revision (was &#x27; + currentRev + &#x27;)&#x27;);
      if (change.checkpoint !== checkpoint) {
        // previous revision is updated only across checkpoints
        if (currentRev) {
          change.prev = currentRev;
        } else if (!change.prev) {
          change.debug(&#x27;ERROR - could not determine prev&#x27;);
          change.prev = Change.UNKNOWN;
        }
        change.debug(&#x27;updated prev&#x27;);
      }
    }

    if (change.checkpoint != checkpoint) {
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.remove(cb);
    } else {
      change.save(cb);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    callback = callback || utils.createPromiseCallback();

    var tasks = modelIds.map(function(id) {
      return function(cb) {
Change.findOrCreateChange(modelName, id, function(err, change) {
  if (err) return next(err);
  change.<span class="apidocCodeKeywordSpan">rectify</span>(next);
});

function next(err) {
  if (err) {
    err.modelName = modelName;
    err.modelId = id;
    errors.push(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Change.prototype.type" id="apidoc.element.loopback.Change.prototype.type">
        function <span class="apidocSignatureSpan">loopback.Change.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
  if (this.rev &#x26;&#x26; this.prev) {
    return Change.UPDATE;
  }
  if (this.rev &#x26;&#x26; !this.prev) {
    return Change.CREATE;
  }
  if (!this.rev &#x26;&#x26; this.prev) {
    return Change.DELETE;
  }
  return Change.UNKNOWN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.<span class="apidocCodeKeywordSpan">type</span>() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
};

/**
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change.settings" id="apidoc.module.loopback.Change.settings">module loopback.Change.settings</a></h1>








    <h2>
        <a href="#apidoc.element.loopback.Change.settings.base" id="apidoc.element.loopback.Change.settings.base">
        function <span class="apidocSignatureSpan">loopback.Change.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Change.sharedClass" id="apidoc.module.loopback.Change.sharedClass">module loopback.Change.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Change.sharedClass.ctor" id="apidoc.element.loopback.Change.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.Change.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Checkpoint" id="apidoc.module.loopback.Checkpoint">module loopback.Checkpoint</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.Checkpoint" id="apidoc.element.loopback.Checkpoint.Checkpoint">
        function <span class="apidocSignatureSpan">loopback.</span>Checkpoint
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.ValidationError" id="apidoc.element.loopback.Checkpoint.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint._ACL" id="apidoc.element.loopback.Checkpoint._ACL">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint._defineChangeModel" id="apidoc.element.loopback.Checkpoint._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint._getAccessTypeForMethod" id="apidoc.element.loopback.Checkpoint._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint._getSingleton" id="apidoc.element.loopback.Checkpoint._getSingleton">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_getSingleton
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSingleton = function (cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.findOrCreate(query, initialData, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Get the current checkpoint id
 * @callback {Function} callback
 * @param {Error} err
 * @param {Number} checkpoint The current checkpoint seq
 */
Checkpoint.current = function(cb) {
  var Checkpoint = this;
  Checkpoint.<span class="apidocCodeKeywordSpan">_getSingleton</span>(function(err, cp) {
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint._notifyBaseObservers" id="apidoc.element.loopback.Checkpoint._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint._runWhenAttachedToApp" id="apidoc.element.loopback.Checkpoint._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.addListener" id="apidoc.element.loopback.Checkpoint.addListener">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.afterRemote" id="apidoc.element.loopback.Checkpoint.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.afterRemoteError" id="apidoc.element.loopback.Checkpoint.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.attachTo" id="apidoc.element.loopback.Checkpoint.attachTo">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.beforeRemote" id="apidoc.element.loopback.Checkpoint.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.belongsToRemoting" id="apidoc.element.loopback.Checkpoint.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.bulkUpdate" id="apidoc.element.loopback.Checkpoint.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.bumpLastSeq" id="apidoc.element.loopback.Checkpoint.bumpLastSeq">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>bumpLastSeq
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bumpLastSeq = function (cb) {
  var Checkpoint = this;
  Checkpoint._getSingleton(function(err, cp) {
    if (err) return cb(err);
    var originalSeq = cp.seq;
    cp.seq++;
    // Update the checkpoint but only if it was not changed under our hands
    Checkpoint.updateAll({id: cp.id, seq: originalSeq}, {seq: cp.seq}, function(err, info) {
      if (err) return cb(err);
      // possible outcomes
      // 1) seq was updated to seq+1 - exactly what we wanted!
      // 2) somebody else already updated seq to seq+1 and our call was a no-op.
      //   That should be ok, checkpoints are time based, so we reuse the one created just now
      //  3) seq was bumped more than once, so we will be using a value that is behind the latest seq.
      //    @bajtos is not entirely sure if this is ok, but since it wasn&#x27;t handled by the current implementation either,
      //    he thinks we can keep it this way.
      cb(null, cp);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Create a checkpoint.
 *
 * @param  {Function} callback
 */

PersistedModel.checkpoint = function(cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.<span class="apidocCodeKeywordSpan">bumpLastSeq</span>(cb);
};

/**
 * Get the current checkpoint ID.
 *
 * @callback {Function} callback Callback function called with `(err, currentCheckpointId)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.changes" id="apidoc.element.loopback.Checkpoint.changes">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.checkAccess" id="apidoc.element.loopback.Checkpoint.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.checkpoint" id="apidoc.element.loopback.Checkpoint.checkpoint">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.clearObservers" id="apidoc.element.loopback.Checkpoint.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.count" id="apidoc.element.loopback.Checkpoint.count">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.create" id="apidoc.element.loopback.Checkpoint.create">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.createChangeFilter" id="apidoc.element.loopback.Checkpoint.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.createChangeStream" id="apidoc.element.loopback.Checkpoint.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.createOptionsFromRemotingContext" id="apidoc.element.loopback.Checkpoint.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.createUpdates" id="apidoc.element.loopback.Checkpoint.createUpdates">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.current" id="apidoc.element.loopback.Checkpoint.current">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>current
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">current = function (cb) {
  var Checkpoint = this;
  Checkpoint._getSingleton(function(err, cp) {
    cb(err, cp.seq);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @callback {Function} callback Callback function called with `(err, currentCheckpointId)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Number} currentCheckpointId Current checkpoint ID.
 */

PersistedModel.currentCheckpoint = function(cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.<span class="apidocCodeKeywordSpan">current</span>(cb);
};

/**
 * Replicate changes since the given checkpoint to the given target model.
 *
 * @param  {Number}   [since]  Since this checkpoint
 * @param  {Model}    targetModel  Target this model class
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.currentCheckpoint" id="apidoc.element.loopback.Checkpoint.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.defineProperty" id="apidoc.element.loopback.Checkpoint.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.deleteAll" id="apidoc.element.loopback.Checkpoint.deleteAll">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.deleteById" id="apidoc.element.loopback.Checkpoint.deleteById">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.destroyAll" id="apidoc.element.loopback.Checkpoint.destroyAll">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.destroyById" id="apidoc.element.loopback.Checkpoint.destroyById">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.diff" id="apidoc.element.loopback.Checkpoint.diff">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.disableRemoteMethod" id="apidoc.element.loopback.Checkpoint.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.disableRemoteMethodByName" id="apidoc.element.loopback.Checkpoint.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.emit" id="apidoc.element.loopback.Checkpoint.emit">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.enableChangeTracking" id="apidoc.element.loopback.Checkpoint.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.eventNames" id="apidoc.element.loopback.Checkpoint.eventNames">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.exists" id="apidoc.element.loopback.Checkpoint.exists">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.extend" id="apidoc.element.loopback.Checkpoint.extend">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.find" id="apidoc.element.loopback.Checkpoint.find">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.findById" id="apidoc.element.loopback.Checkpoint.findById">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Checkpoint.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.findLastChange" id="apidoc.element.loopback.Checkpoint.findLastChange">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.findOne" id="apidoc.element.loopback.Checkpoint.findOne">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.findOrCreate" id="apidoc.element.loopback.Checkpoint.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.forEachProperty" id="apidoc.element.loopback.Checkpoint.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getApp" id="apidoc.element.loopback.Checkpoint.getApp">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getChangeModel" id="apidoc.element.loopback.Checkpoint.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getDataSource" id="apidoc.element.loopback.Checkpoint.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getIdName" id="apidoc.element.loopback.Checkpoint.getIdName">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getMaxListeners" id="apidoc.element.loopback.Checkpoint.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getPropertyType" id="apidoc.element.loopback.Checkpoint.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.getSourceId" id="apidoc.element.loopback.Checkpoint.getSourceId">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.handleChangeError" id="apidoc.element.loopback.Checkpoint.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.hasManyRemoting" id="apidoc.element.loopback.Checkpoint.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.hasOneRemoting" id="apidoc.element.loopback.Checkpoint.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.isHiddenProperty" id="apidoc.element.loopback.Checkpoint.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.isProtectedProperty" id="apidoc.element.loopback.Checkpoint.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.listenerCount" id="apidoc.element.loopback.Checkpoint.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.listeners" id="apidoc.element.loopback.Checkpoint.listeners">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.mixin" id="apidoc.element.loopback.Checkpoint.mixin">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.nestRemoting" id="apidoc.element.loopback.Checkpoint.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.notifyObserversAround" id="apidoc.element.loopback.Checkpoint.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.notifyObserversOf" id="apidoc.element.loopback.Checkpoint.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.observe" id="apidoc.element.loopback.Checkpoint.observe">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.on" id="apidoc.element.loopback.Checkpoint.on">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.once" id="apidoc.element.loopback.Checkpoint.once">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.patchOrCreate" id="apidoc.element.loopback.Checkpoint.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.patchOrCreateWithWhere" id="apidoc.element.loopback.Checkpoint.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.prependListener" id="apidoc.element.loopback.Checkpoint.prependListener">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.prependOnceListener" id="apidoc.element.loopback.Checkpoint.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.rectifyAllChanges" id="apidoc.element.loopback.Checkpoint.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.rectifyChange" id="apidoc.element.loopback.Checkpoint.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.registerProperty" id="apidoc.element.loopback.Checkpoint.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.remoteMethod" id="apidoc.element.loopback.Checkpoint.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.remove" id="apidoc.element.loopback.Checkpoint.remove">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.removeAllListeners" id="apidoc.element.loopback.Checkpoint.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.removeById" id="apidoc.element.loopback.Checkpoint.removeById">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.removeListener" id="apidoc.element.loopback.Checkpoint.removeListener">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.removeObserver" id="apidoc.element.loopback.Checkpoint.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.replaceById" id="apidoc.element.loopback.Checkpoint.replaceById">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.replaceOrCreate" id="apidoc.element.loopback.Checkpoint.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.replicate" id="apidoc.element.loopback.Checkpoint.replicate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.scopeRemoting" id="apidoc.element.loopback.Checkpoint.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.setMaxListeners" id="apidoc.element.loopback.Checkpoint.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.setup" id="apidoc.element.loopback.Checkpoint.setup">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.setupRemoting" id="apidoc.element.loopback.Checkpoint.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.sharedCtor" id="apidoc.element.loopback.Checkpoint.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Checkpoint.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Checkpoint.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.super_" id="apidoc.element.loopback.Checkpoint.super_">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.update" id="apidoc.element.loopback.Checkpoint.update">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.updateAll" id="apidoc.element.loopback.Checkpoint.updateAll">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.updateLastChange" id="apidoc.element.loopback.Checkpoint.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.updateOrCreate" id="apidoc.element.loopback.Checkpoint.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.upsert" id="apidoc.element.loopback.Checkpoint.upsert">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.upsertWithWhere" id="apidoc.element.loopback.Checkpoint.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validate" id="apidoc.element.loopback.Checkpoint.validate">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validateAsync" id="apidoc.element.loopback.Checkpoint.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesAbsenceOf" id="apidoc.element.loopback.Checkpoint.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesExclusionOf" id="apidoc.element.loopback.Checkpoint.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesFormatOf" id="apidoc.element.loopback.Checkpoint.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesInclusionOf" id="apidoc.element.loopback.Checkpoint.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesLengthOf" id="apidoc.element.loopback.Checkpoint.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesNumericalityOf" id="apidoc.element.loopback.Checkpoint.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesPresenceOf" id="apidoc.element.loopback.Checkpoint.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.validatesUniquenessOf" id="apidoc.element.loopback.Checkpoint.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Checkpoint.settings" id="apidoc.module.loopback.Checkpoint.settings">module loopback.Checkpoint.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.settings.base" id="apidoc.element.loopback.Checkpoint.settings.base">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Checkpoint.sharedClass" id="apidoc.module.loopback.Checkpoint.sharedClass">module loopback.Checkpoint.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Checkpoint.sharedClass.ctor" id="apidoc.element.loopback.Checkpoint.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.Checkpoint.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Connector" id="apidoc.module.loopback.Connector">module loopback.Connector</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Connector.Connector" id="apidoc.element.loopback.Connector.Connector">
        function <span class="apidocSignatureSpan">loopback.</span>Connector
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connector(options) {
  EventEmitter.apply(this, arguments);
  this.options = options;

  debug(&#x27;created with options&#x27;, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Connector._createJDBAdapter" id="apidoc.element.loopback.Connector._createJDBAdapter">
        function <span class="apidocSignatureSpan">loopback.Connector.</span>_createJDBAdapter
        <span class="apidocSignatureSpan">(jdbModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createJDBAdapter = function (jdbModule) {
  var fauxSchema = {};
  jdbModule.initialize(fauxSchema, function() {
    // connected
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Connector.super_" id="apidoc.element.loopback.Connector.super_">
        function <span class="apidocSignatureSpan">loopback.Connector.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Connector.prototype" id="apidoc.module.loopback.Connector.prototype">module loopback.Connector.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Connector.prototype._addCrudOperationsFromJDBAdapter" id="apidoc.element.loopback.Connector.prototype._addCrudOperationsFromJDBAdapter">
        function <span class="apidocSignatureSpan">loopback.Connector.prototype.</span>_addCrudOperationsFromJDBAdapter
        <span class="apidocSignatureSpan">(connector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addCrudOperationsFromJDBAdapter = function (connector) {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource" id="apidoc.module.loopback.DataSource">module loopback.DataSource</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataSource" id="apidoc.element.loopback.DataSource.DataSource">
        function <span class="apidocSignatureSpan">loopback.</span>DataSource
        <span class="apidocSignatureSpan">(name, settings, modelBuilder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataSource(name, settings, modelBuilder) {
  if (!(this instanceof DataSource)) {
    return new DataSource(name, settings);
  }

  // Check if the settings object is passed as the first argument
  if (typeof name === &#x27;object&#x27; &#x26;&#x26; settings === undefined) {
    settings = name;
    name = undefined;
  }

  // Check if the first argument is a URL
  if (typeof name === &#x27;string&#x27; &#x26;&#x26; name.indexOf(&#x27;://&#x27;) !== -1) {
    name = utils.parseSettings(name);
  }

  // Check if the settings is in the form of URL string
  if (typeof settings === &#x27;string&#x27; &#x26;&#x26; settings.indexOf(&#x27;://&#x27;) !== -1) {
    settings = utils.parseSettings(settings);
  }

  this.modelBuilder = modelBuilder || new ModelBuilder();
  this.models = this.modelBuilder.models;
  this.definitions = this.modelBuilder.definitions;
  this.juggler = juggler;

  // operation metadata
  // Initialize it before calling setup as the connector might register operations
  this._operations = {};

  this.setup(name, settings);

  this._setupConnector();

  // connector
  var connector = this.connector;

  // DataAccessObject - connector defined or supply the default
  var dao = (connector &#x26;&#x26; connector.DataAccessObject) || this.constructor.DataAccessObject;
  this.DataAccessObject = function() {
  };

  // define DataAccessObject methods
  Object.keys(dao).forEach(function(name) {
    var fn = dao[name];
    this.DataAccessObject[name] = fn;

    if (typeof fn === &#x27;function&#x27;) {
      this.defineOperation(name, {
        accepts: fn.accepts,
        &#x27;returns&#x27;: fn.returns,
        http: fn.http,
        remoteEnabled: fn.shared ? true : false,
        scope: this.DataAccessObject,
        fnName: name,
      });
    }
  }.bind(this));

  // define DataAccessObject.prototype methods
  Object.keys(dao.prototype).forEach(function(name) {
    var fn = dao.prototype[name];
    this.DataAccessObject.prototype[name] = fn;
    if (typeof fn === &#x27;function&#x27;) {
      this.defineOperation(name, {
        prototype: true,
        accepts: fn.accepts,
        &#x27;returns&#x27;: fn.returns,
        http: fn.http,
        remoteEnabled: fn.shared ? true : false,
        scope: this.DataAccessObject.prototype,
        fnName: name,
      });
    }
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.Any" id="apidoc.element.loopback.DataSource.Any">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>Any
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Any(value) {
  if (!(this instanceof Any)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject" id="apidoc.element.loopback.DataSource.DataAccessObject">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>DataAccessObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataAccessObject() {
  if (DataAccessObject._mixins) {
    var self = this;
    var args = arguments;
    DataAccessObject._mixins.forEach(function(m) {
      m.call(self, args);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.JSON" id="apidoc.element.loopback.DataSource.JSON">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>JSON
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSON(value) {
  if (!(this instanceof JSON)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.Text" id="apidoc.element.loopback.DataSource.Text">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>Text
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(value) {
  if (!(this instanceof Text)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource._resolveConnector" id="apidoc.element.loopback.DataSource._resolveConnector">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>_resolveConnector
        <span class="apidocSignatureSpan">(name, loader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resolveConnector = function (name, loader) {
  var names = connectorModuleNames(name);
  var connector = tryModules(names, loader);
  var error = null;
  if (!connector) {
    error = g.f(&#x27;\nWARNING: {{LoopBack}} connector &#x22;%s&#x22; is not installed &#x27; +
      &#x27;as any of the following modules:\n\n %s\n\nTo fix, run:\n\n    {{npm install %s --save}}\n&#x27;,
      name, names.join(&#x27;\n&#x27;), names[names.length - 1]);
  }
  return {
    connector: connector,
    error: error,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.super_" id="apidoc.element.loopback.DataSource.super_">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.Any" id="apidoc.module.loopback.DataSource.Any">module loopback.DataSource.Any</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.Any.Any" id="apidoc.element.loopback.DataSource.Any.Any">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>Any
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Any(value) {
  if (!(this instanceof Any)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.Any.prototype" id="apidoc.module.loopback.DataSource.Any.prototype">module loopback.DataSource.Any.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.Any.prototype.toJSON" id="apidoc.element.loopback.DataSource.Any.prototype.toJSON">
        function <span class="apidocSignatureSpan">loopback.DataSource.Any.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err) {
    if (done) done(err);
    return;
  }
  mappings.forEach(function(m) {
    var role;
    if (options.returnOnlyRoleNames === true) {
      role = m.<span class="apidocCodeKeywordSpan">toJSON</span>().role.name;
    } else {
      role = m.roleId;
    }
    addRole(role);
  });
  if (done) done();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.Any.prototype.toObject" id="apidoc.element.loopback.DataSource.Any.prototype.toObject">
        function <span class="apidocSignatureSpan">loopback.DataSource.Any.prototype.</span>toObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.validate = true;
}
if (!(&#x27;throws&#x27; in options)) {
  options.throws = false;
}

var inst = this;
var data = inst.<span class="apidocCodeKeywordSpan">toObject</span>(true);
var id = this.getId();

if (!id) {
  return Model.create(this, callback);
}

// validate first
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.DataAccessObject" id="apidoc.module.loopback.DataSource.DataAccessObject">module loopback.DataSource.DataAccessObject</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.DataAccessObject" id="apidoc.element.loopback.DataSource.DataAccessObject.DataAccessObject">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>DataAccessObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataAccessObject() {
  if (DataAccessObject._mixins) {
    var self = this;
    var args = arguments;
    DataAccessObject._mixins.forEach(function(m) {
      m.call(self, args);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>Transaction
        <span class="apidocSignatureSpan">(connector, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Transaction(connector, connection) {
  this.connector = connector;
  this.connection = connection;
  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject._allowExtendedOperators" id="apidoc.element.loopback.DataSource.DataAccessObject._allowExtendedOperators">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_allowExtendedOperators
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_allowExtendedOperators = function (options) {
  options = options || {};

  var Model = this;
  var dsSettings = this.getDataSource().settings;
  var allowExtendedOperators = dsSettings.allowExtendedOperators;
  // options settings enable allowExtendedOperators per request (for example if
  // enable allowExtendedOperators only server side);
  // model settings enable allowExtendedOperators only for specific model.
  // dataSource settings enable allowExtendedOperators globally (all models);
  // options -&#x3e; model -&#x3e; dataSource (connector)
  if (options.hasOwnProperty(&#x27;allowExtendedOperators&#x27;)) {
    allowExtendedOperators = options.allowExtendedOperators === true;
  } else if (Model.settings &#x26;&#x26; Model.settings.hasOwnProperty(&#x27;allowExtendedOperators&#x27;)) {
    allowExtendedOperators = Model.settings.allowExtendedOperators === true;
  }
  return allowExtendedOperators;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject._coerce" id="apidoc.element.loopback.DataSource.DataAccessObject._coerce">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_coerce
        <span class="apidocSignatureSpan">(where, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_coerce = function (where, options) {
  var self = this;
  if (!where) {
    return where;
  }

  options = options || {};

  var err;
  if (typeof where !== &#x27;object&#x27; || Array.isArray(where)) {
    err = new Error(g.f(&#x27;The where clause %j is not an {{object}}&#x27;, where));
    err.statusCode = 400;
    throw err;
  }

  var props = self.definition.properties;
  for (var p in where) {
    // Handle logical operators
    if (p === &#x27;and&#x27; || p === &#x27;or&#x27; || p === &#x27;nor&#x27;) {
      var clauses = where[p];
      try {
        clauses = coerceArray(clauses);
      } catch (e) {
        err = new Error(g.f(&#x27;The %s operator has invalid clauses %j: %s&#x27;, p, clauses, e.message));
        err.statusCode = 400;
        throw err;
      }

      for (var k = 0; k &#x3c; clauses.length; k++) {
        self._coerce(clauses[k], options);
      }

      continue;
    }
    var DataType = props[p] &#x26;&#x26; props[p].type;
    if (!DataType) {
      continue;
    }
    if (Array.isArray(DataType) || DataType === Array) {
      DataType = DataType[0];
    }
    if (DataType === Date) {
      DataType = DateType;
    } else if (DataType === Boolean) {
      DataType = BooleanType;
    } else if (DataType === Number) {
      // This fixes a regression in mongodb connector
      // For numbers, only convert it produces a valid number
      // LoopBack by default injects a number id. We should fix it based
      // on the connector&#x27;s input, for example, MongoDB should use string
      // while RDBs typically use number
      DataType = NumberType;
    }

    if (!DataType) {
      continue;
    }

    if (DataType.prototype instanceof BaseModel) {
      continue;
    }

    if (DataType === geo.GeoPoint) {
      // Skip the GeoPoint as the near operator breaks the assumption that
      // an operation has only one property
      // We should probably fix it based on
      // http://docs.mongodb.org/manual/reference/operator/query/near/
      // The other option is to make operators start with $
      continue;
    }

    var val = where[p];
    if (val === null || val === undefined) {
      continue;
    }
    // Check there is an operator
    var operator = null;
    var exp = val;
    if (val.constructor === Object) {
      for (var op in operators) {
        if (op in val) {
          val = val[op];
          operator = op;
          switch (operator) {
            case &#x27;inq&#x27;:
            case &#x27;nin&#x27;:
            case &#x27;between&#x27;:
              try {
                val = coerceArray(val);
              } catch (e) {
                err = new Error(g.f(&#x27;The %s property has invalid clause %j: %s&#x27;, p, where[p], e));
                err.statusCode = 400;
                throw err;
              }

              if (operator === &#x27;between&#x27; &#x26;&#x26; val.length !== 2) {
                err = new Error(g.f(
                  &#x27;The %s property has invalid clause %j: Expected precisely 2 values, received %d&#x27;,
                  p,
                  where[p],
                  val.length));
                err.statusCode = 400;
                throw err;
              }
              break;
            case &#x27;like&#x27;:
            case &#x27;nlike&#x27;:
            case &#x27;ilike&#x27;:
            case &#x27;nilike&#x27;:
              if (!(typeof val === &#x27;string&#x27; || val instanceof RegExp)) {
                err = new Error(g.f(
                  &#x27;The %s property has invalid clause %j: Expected a string or RegExp&#x27;,
                  p,
                  where[p]));
                err.statusCode = 400;
                throw err;
              }
              break;
            case &#x27;regexp&#x27;:
              val = utils.toRegExp(val);
              if (val instanceof Error) {
                val.statusCode = 400;
                throw err;
              }
              break;
          }
          break;
        }
      }
    }

    try {
      // Coerce val into an array if it resembles an array-like object
      val = coerceArray(val);
    } catch (e) {
      // NOOP when not coercable into an array.
    }

    // Coerce the array items
    if (Array.isArray(val)) {
      for (var i = 0; i &#x3c; val.length; i++) {
        if (v ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject._forDB" id="apidoc.element.loopback.DataSource.DataAccessObject._forDB">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_forDB
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_forDB = function (data) {
  if (!(this.getDataSource().isRelational &#x26;&#x26; this.getDataSource().isRelational())) {
    return data;
  }
  var res = {};
  for (var propName in data) {
    var type = this.getPropertyType(propName);
    if (type === &#x27;JSON&#x27; || type === &#x27;Any&#x27; || type === &#x27;Object&#x27; || data[propName] instanceof Array) {
      res[propName] = JSON.stringify(data[propName]);
    } else {
      res[propName] = data[propName];
    }
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject._getSetting" id="apidoc.element.loopback.DataSource.DataAccessObject._getSetting">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_getSetting
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSetting = function (key) {
  // Check for settings in model
  var m = this.definition;
  if (m &#x26;&#x26; m.settings &#x26;&#x26; m.settings[key]) {
    return m.settings[key];
  }

  // Check for settings in connector
  var ds = this.getDataSource();
  if (ds &#x26;&#x26; ds.settings &#x26;&#x26; ds.settings[key]) {
    return ds.settings[key];
  }

  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject._normalize" id="apidoc.element.loopback.DataSource.DataAccessObject._normalize">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>_normalize
        <span class="apidocSignatureSpan">(filter, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_normalize = function (filter, options) {
  if (!filter) {
    return undefined;
  }
  var err = null;
  if ((typeof filter !== &#x27;object&#x27;) || Array.isArray(filter)) {
    err = new Error(g.f(&#x27;The query filter %j is not an {{object}}&#x27;, filter));
    err.statusCode = 400;
    throw err;
  }
  if (filter.limit || filter.skip || filter.offset) {
    var limit = Number(filter.limit || 100);
    var offset = Number(filter.skip || filter.offset || 0);
    if (isNaN(limit) || limit &#x3c;= 0 || Math.ceil(limit) !== limit) {
      err = new Error(g.f(&#x27;The {{limit}} parameter %j is not valid&#x27;,
        filter.limit));
      err.statusCode = 400;
      throw err;
    }
    if (isNaN(offset) || offset &#x3c; 0 || Math.ceil(offset) !== offset) {
      err = new Error(g.f(&#x27;The {{offset/skip}} parameter %j is not valid&#x27;,
          filter.skip || filter.offset));
      err.statusCode = 400;
      throw err;
    }
    filter.limit = limit;
    filter.offset = offset;
    filter.skip = offset;
  }

  if (filter.order) {
    var order = filter.order;
    if (!Array.isArray(order)) {
      order = [order];
    }
    var fields = [];
    for (var i = 0, m = order.length; i &#x3c; m; i++) {
      if (typeof order[i] === &#x27;string&#x27;) {
        // Normalize &#x27;f1 ASC, f2 DESC, f3&#x27; to [&#x27;f1 ASC&#x27;, &#x27;f2 DESC&#x27;, &#x27;f3&#x27;]
        var tokens = order[i].split(/(?:\s*,\s*)+/);
        for (var t = 0, n = tokens.length; t &#x3c; n; t++) {
          var token = tokens[t];
          if (token.length === 0) {
            // Skip empty token
            continue;
          }
          var parts = token.split(/\s+/);
          if (parts.length &#x3e;= 2) {
            var dir = parts[1].toUpperCase();
            if (dir === &#x27;ASC&#x27; || dir === &#x27;DESC&#x27;) {
              token = parts[0] + &#x27; &#x27; + dir;
            } else {
              err = new Error(g.f(&#x27;The {{order}} %j has invalid direction&#x27;, token));
              err.statusCode = 400;
              throw err;
            }
          }
          fields.push(token);
        }
      } else {
        err = new Error(g.f(&#x27;The order %j is not valid&#x27;, order[i]));
        err.statusCode = 400;
        throw err;
      }
    }
    if (fields.length === 1 &#x26;&#x26; typeof filter.order === &#x27;string&#x27;) {
      filter.order = fields[0];
    } else {
      filter.order = fields;
    }
  }

  // normalize fields as array of included property names
  if (filter.fields) {
    filter.fields = fieldsToArray(filter.fields,
      Object.keys(this.definition.properties), this.settings.strict);
  }

  var handleUndefined =  this._getSetting(&#x27;normalizeUndefinedInQuery&#x27;);
  // alter configuration of how removeUndefined handles undefined values
  filter = removeUndefined(filter, handleUndefined);
  this._coerce(filter.where, options);
  return filter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.all" id="apidoc.element.loopback.DataSource.DataAccessObject.all">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function () {
  return DataAccessObject.find.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.applyProperties" id="apidoc.element.loopback.DataSource.DataAccessObject.applyProperties">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>applyProperties
        <span class="apidocSignatureSpan">(data, inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyProperties = function (data, inst) {
  var properties = this.definition.settings.properties;
  properties = properties || this.definition.settings.attributes;
  if (typeof properties === &#x27;object&#x27;) {
    util._extend(data, properties);
  } else if (typeof properties === &#x27;function&#x27;) {
    util._extend(data, properties.call(this, data, inst) || {});
  } else if (properties !== false) {
    var scope = this.defaultScope(data, inst) || {};
    if (typeof scope.where === &#x27;object&#x27;) {
      setScopeValuesFromWhere(data, scope.where, this);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.applyScope" id="apidoc.element.loopback.DataSource.DataAccessObject.applyScope">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>applyScope
        <span class="apidocSignatureSpan">(query, inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyScope = function (query, inst) {
  var scope = this.defaultScope(query, inst) || {};
  if (typeof scope === &#x27;object&#x27;) {
    mergeQuery(query, scope || {}, this.definition.settings.scope);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.beginTransaction" id="apidoc.element.loopback.DataSource.DataAccessObject.beginTransaction">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>beginTransaction
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beginTransaction = function (options, cb) {
  cb = cb || utils.createPromiseCallback();
  if (Transaction) {
    var connector = this.getConnector();
    Transaction.begin(connector, options, function(err, transaction) {
      if (err) return cb(err);
      if (transaction) {
        // Set an informational transaction id
        transaction.id = uuid.v1();
      }
      if (options.timeout) {
        setTimeout(function() {
          var context = {
            transaction: transaction,
            operation: &#x27;timeout&#x27;,
          };
          transaction.notifyObserversOf(&#x27;timeout&#x27;, context, function(err) {
            if (!err) {
              transaction.rollback(function() {
                debug(&#x27;Transaction %s is rolled back due to timeout&#x27;,
                  transaction.id);
              });
            }
          });
        }, options.timeout);
      }
      cb(err, transaction);
    });
  } else {
    process.nextTick(function() {
      var err = new Error(g.f(&#x27;{{Transaction}} is not supported&#x27;));
      cb(err);
    });
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.belongsTo" id="apidoc.element.loopback.DataSource.DataAccessObject.belongsTo">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>belongsTo
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsTo = function (modelTo, params) {
  return RelationDefinition.belongsTo(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.count" id="apidoc.element.loopback.DataSource.DataAccessObject.count">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>count
        <span class="apidocSignatureSpan">(where, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof where === &#x27;function&#x27;) {
      // count(cb)
      cb = where;
      where = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // count(where, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  where = where || {};
  options = options || {};

  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var Model = this;
  var connector = Model.getConnector();
  assert(typeof connector.count === &#x27;function&#x27;,
    &#x27;count() must be implemented by the connector&#x27;);
  assert(connector.count.length &#x3e;= 3,
    &#x27;count() must take at least 3 arguments&#x27;);

  var hookState = {};

  var query = {where: where};
  this.applyScope(query);
  where = query.where;

  try {
    where = removeUndefined(where);
    where = this._coerce(where, options);
  } catch (err) {
    process.nextTick(function() {
      cb(err);
    });
    return cb.promise;
  }

  var context = {
    Model: Model,
    query: {where: where},
    hookState: hookState,
    options: options,
  };
  this.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    where = ctx.query.where;

    if (connector.count.length &#x3c;= 3) {
      // Old signature, please note where is the last
      // count(model, cb, where)
      connector.count(Model.modelName, cb, where);
    } else {
      // New signature
      // count(model, where, options, cb)
      connector.count(Model.modelName, where, options, cb);
    }
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.create" id="apidoc.element.loopback.DataSource.DataAccessObject.create">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>create
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  var Model = this;
  var connector = Model.getConnector();
  assert(typeof connector.create === &#x27;function&#x27;,
    &#x27;create() must be implemented by the connector&#x27;);

  var self = this;

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // create(cb)
      cb = data;
      data = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // create(data, cb);
      cb = options;
      options = {};
    }
  }

  data = data || {};
  options = options || {};
  cb = cb || (Array.isArray(data) ? noCallback : utils.createPromiseCallback());

  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object or array&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};

  if (Array.isArray(data)) {
    // Undefined item will be skipped by async.map() which internally uses
    // Array.prototype.map(). The following loop makes sure all items are
    // iterated
    for (var i = 0, n = data.length; i &#x3c; n; i++) {
      if (data[i] === undefined) {
        data[i] = {};
      }
    }
    async.map(data, function(item, done) {
      self.create(item, options, function(err, result) {
        // Collect all errors and results
        done(null, {err: err, result: result || item});
      });
    }, function(err, results) {
      if (err) {
        return cb(err, results);
      }
      // Convert the results into two arrays
      var errors = null;
      var data = [];
      for (var i = 0, n = results.length; i &#x3c; n; i++) {
        if (results[i].err) {
          if (!errors) {
            errors = [];
          }
          errors[i] = results[i].err;
        }
        data[i] = results[i].result;
      }
      cb(errors, data);
    });
    return;
  }

  var enforced = {};
  var obj;
  var idValue = getIdValue(this, data);

  // if we come from save
  if (data instanceof Model &#x26;&#x26; !idValue) {
    obj = data;
  } else {
    obj = new Model(data);
  }

  this.applyProperties(enforced, obj);
  obj.setAttributes(enforced);

  Model = this.lookupModel(data); // data-specific
  if (Model !== obj.constructor) obj = new Model(data);

  var context = {
    Model: Model,
    instance: obj,
    isNewInstance: true,
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err) {
    if (err) return cb(err);

    data = obj.toObject(true);

    // options has precedence on model-setting
    if (options.validate === false) {
      return create();
    }

    // only when options.validate is not set, take model-setting into consideration
    if (options.validate === undefined &#x26;&#x26; Model.settings.automaticValidation === false) {
      return create();
    }

    // validation required
    obj.isValid(function(valid) {
      if (valid) {
        create();
      } else {
        cb(new ValidationError(obj), obj);
      }
    }, data, options);
  });

  function create() {
    obj.trigger(&#x27;create&#x27;, function(createDone) {
      obj.trigger(&#x27;save&#x27;, function(saveDone) {
        var _idName = idName(Model);
        var modelName = Model.modelName;
        var val = removeUndefined(obj.toObject(true));
        function createCallback(err, id, rev) {
          if (id) {
            obj.__data[_idName] = id;
            defineReadonlyProp(obj, _idName, id);
          }
          if (rev) {
            obj._rev = rev;
          }
          if (err) {
            return cb(err, obj);
          }
          obj.__persisted = true;

          var context = {
            Model: Model,
            data: val,
            isNewInstance: true,
            hookState: hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;loaded&#x27;, context, function(err) {
            if (err) return cb(err);

            // By def ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.defaultScope" id="apidoc.element.loopback.DataSource.DataAccessObject.defaultScope">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>defaultScope
        <span class="apidocSignatureSpan">(target, inst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultScope = function (target, inst) {
  var scope = this.definition.settings.scope;
  if (typeof scope === &#x27;function&#x27;) {
    scope = this.definition.settings.scope.call(this, target, inst);
  }
  return scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.deleteAll" id="apidoc.element.loopback.DataSource.DataAccessObject.deleteAll">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>deleteAll
        <span class="apidocSignatureSpan">(where, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  var Model = this;
  var connector = Model.getConnector();

  assert(typeof connector.destroyAll === &#x27;function&#x27;,
    &#x27;destroyAll() must be implemented by the connector&#x27;);

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof where === &#x27;function&#x27;) {
      cb = where;
      where = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  where = where || {};
  options = options || {};

  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};

  var query = {where: where};
  this.applyScope(query);
  where = query.where;

  if (options.notify === false) {
    doDelete(where);
  } else {
    query = {where: whereIsEmpty(where) ? {} : where};
    var context = {
      Model: Model,
      query: query,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
      if (err) return cb(err);
      var context = {
        Model: Model,
        where: ctx.query.where,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before delete&#x27;, context, function(err, ctx) {
        if (err) return cb(err);
        doDelete(ctx.where);
      });
    });
  }

  function doDelete(where) {
    var context = {
      Model: Model,
      where: whereIsEmpty(where) ? {} : where,
      hookState: hookState,
      options: options,
    };

    if (whereIsEmpty(where)) {
      if (connector.destroyAll.length === 4) {
        connector.destroyAll(Model.modelName, {}, options, done);
      } else {
        connector.destroyAll(Model.modelName, {}, done);
      }
    } else {
      try {
        // Support an optional where object
        where = removeUndefined(where);
        where = Model._coerce(where, options);
      } catch (err) {
        return process.nextTick(function() {
          cb(err);
        });
      }

      if (connector.destroyAll.length === 4) {
        connector.destroyAll(Model.modelName, where, options, done);
      } else {
        connector.destroyAll(Model.modelName, where, done);
      }
    }

    function done(err, info) {
      if (err) return cb(err);

      if (options.notify === false) {
        return cb(err, info);
      }

      var context = {
        Model: Model,
        where: where,
        hookState: hookState,
        options: options,
        info: info,
      };
      Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
        cb(err, info);
      });
    }
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.deleteById" id="apidoc.element.loopback.DataSource.DataAccessObject.deleteById">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>deleteById
        <span class="apidocSignatureSpan">(id, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;The id argument is required&#x27;);
  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // destroyById(id, cb)
      cb = options;
      options = {};
    }
  }

  options = options || {};
  cb = cb || utils.createPromiseCallback();

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (isPKMissing(this, cb)) {
    return cb.promise;
  } else if (id == null || id === &#x27;&#x27;) {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;{{Model::deleteById}} requires the apidoc.element.loopback.DataSource.DataAccessObject.deleteById argument&#x27;)));
    });
    return cb.promise;
  }

  var Model = this;

  this.remove(byIdQuery(this, id).where, options, function(err, info) {
    if (err) return cb(err);
    var deleted = info &#x26;&#x26; info.count &#x3e; 0;
    if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
      err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.deleteById %s found for %s&#x27;, id, Model.modelName));
      err.code = &#x27;NOT_FOUND&#x27;;
      err.statusCode = 404;
      return cb(err);
    }

    cb(null, info);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.destroyAll" id="apidoc.element.loopback.DataSource.DataAccessObject.destroyAll">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>destroyAll
        <span class="apidocSignatureSpan">(where, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  var Model = this;
  var connector = Model.getConnector();

  assert(typeof connector.destroyAll === &#x27;function&#x27;,
    &#x27;destroyAll() must be implemented by the connector&#x27;);

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof where === &#x27;function&#x27;) {
      cb = where;
      where = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  where = where || {};
  options = options || {};

  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};

  var query = {where: where};
  this.applyScope(query);
  where = query.where;

  if (options.notify === false) {
    doDelete(where);
  } else {
    query = {where: whereIsEmpty(where) ? {} : where};
    var context = {
      Model: Model,
      query: query,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
      if (err) return cb(err);
      var context = {
        Model: Model,
        where: ctx.query.where,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before delete&#x27;, context, function(err, ctx) {
        if (err) return cb(err);
        doDelete(ctx.where);
      });
    });
  }

  function doDelete(where) {
    var context = {
      Model: Model,
      where: whereIsEmpty(where) ? {} : where,
      hookState: hookState,
      options: options,
    };

    if (whereIsEmpty(where)) {
      if (connector.destroyAll.length === 4) {
        connector.destroyAll(Model.modelName, {}, options, done);
      } else {
        connector.destroyAll(Model.modelName, {}, done);
      }
    } else {
      try {
        // Support an optional where object
        where = removeUndefined(where);
        where = Model._coerce(where, options);
      } catch (err) {
        return process.nextTick(function() {
          cb(err);
        });
      }

      if (connector.destroyAll.length === 4) {
        connector.destroyAll(Model.modelName, where, options, done);
      } else {
        connector.destroyAll(Model.modelName, where, done);
      }
    }

    function done(err, info) {
      if (err) return cb(err);

      if (options.notify === false) {
        return cb(err, info);
      }

      var context = {
        Model: Model,
        where: where,
        hookState: hookState,
        options: options,
        info: info,
      };
      Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
        cb(err, info);
      });
    }
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.destroyById" id="apidoc.element.loopback.DataSource.DataAccessObject.destroyById">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>destroyById
        <span class="apidocSignatureSpan">(id, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;The id argument is required&#x27;);
  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // destroyById(id, cb)
      cb = options;
      options = {};
    }
  }

  options = options || {};
  cb = cb || utils.createPromiseCallback();

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (isPKMissing(this, cb)) {
    return cb.promise;
  } else if (id == null || id === &#x27;&#x27;) {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;{{Model::deleteById}} requires the apidoc.element.loopback.DataSource.DataAccessObject.destroyById argument&#x27;)));
    });
    return cb.promise;
  }

  var Model = this;

  this.remove(byIdQuery(this, id).where, options, function(err, info) {
    if (err) return cb(err);
    var deleted = info &#x26;&#x26; info.count &#x3e; 0;
    if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
      err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.destroyById %s found for %s&#x27;, id, Model.modelName));
      err.code = &#x27;NOT_FOUND&#x27;;
      err.statusCode = 404;
      return cb(err);
    }

    cb(null, info);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.embedsMany" id="apidoc.element.loopback.DataSource.DataAccessObject.embedsMany">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>embedsMany
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function embedsMany(modelTo, params) {
  return RelationDefinition.embedsMany(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.embedsOne" id="apidoc.element.loopback.DataSource.DataAccessObject.embedsOne">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>embedsOne
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function embedsOne(modelTo, params) {
  return RelationDefinition.embedsOne(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.exists" id="apidoc.element.loopback.DataSource.DataAccessObject.exists">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>exists
        <span class="apidocSignatureSpan">(id, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;The id argument is required&#x27;);
  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // exists(id, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (id !== undefined &#x26;&#x26; id !== null &#x26;&#x26; id !== &#x27;&#x27;) {
    this.count(byIdQuery(this, id).where, options, function(err, count) {
      cb(err, err ? false : count === 1);
    });
  } else {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;{{Model::exists}} requires the apidoc.element.loopback.DataSource.DataAccessObject.exists argument&#x27;)));
    });
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.find" id="apidoc.element.loopback.DataSource.DataAccessObject.find">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>find
        <span class="apidocSignatureSpan">(query, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(query, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof query === &#x27;function&#x27;) {
      // find(cb);
      cb = query;
      query = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // find(query, cb);
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  query = query || {};
  options = options || {};

  assert(typeof query === &#x27;object&#x27;, &#x27;The query argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};
  var self = this;
  var connector = self.getConnector();

  assert(typeof connector.all === &#x27;function&#x27;,
    &#x27;all() must be implemented by the connector&#x27;);

  try {
    this._normalize(query, options);
  } catch (err) {
    process.nextTick(function() {
      cb(err);
    });
    return cb.promise;
  }

  this.applyScope(query);

  var near = query &#x26;&#x26; geo.nearFilter(query.where);
  var supportsGeo = !!connector.buildNearFilter;

  if (near) {
    if (supportsGeo) {
      // convert it
      connector.buildNearFilter(query, near);
    } else if (query.where) {
      // do in memory query
      // using all documents
      // TODO [fabien] use default scope here?
      if (options.notify === false) {
        queryGeo(query);
      } else {
        withNotifyGeo();
      }

      function withNotifyGeo() {
        var context = {
          Model: self,
          query: query,
          hookState: hookState,
          options: options,
        };
        self.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
          if (err) return cb(err);
          queryGeo(ctx.query);
        });
      }

      function queryGeo(query) {
        function geoCallbackWithoutNotify(err, data) {
          var memory = new Memory();
          var modelName = self.modelName;

          if (err) {
            cb(err);
          } else if (Array.isArray(data)) {
            memory.define({
              properties: self.dataSource.definitions[self.modelName].properties,
              settings: self.dataSource.definitions[self.modelName].settings,
              model: self,
            });

            data.forEach(function(obj) {
              memory.create(modelName, obj, options, function() {
                // noop
              });
            });

            // FIXME: apply &#x22;includes&#x22; and other transforms - see allCb below
            memory.all(modelName, query, options, cb);
          } else {
            cb(null, []);
          }
        }

        function geoCallbackWithNotify(err, data) {
          if (err) return cb(err);

          async.map(data, function(item, next) {
            var context = {
              Model: self,
              data: item,
              isNewInstance: false,
              hookState: hookState,
              options: options,
            };

            self.notifyObserversOf(&#x27;loaded&#x27;, context, function(err) {
              if (err) return next(err);
              next(null, context.data);
            });
          }, function(err, results) {
            if (err) return cb(err);
            geoCallbackWithoutNotify(null, results);
          });
        }

        var geoCallback = options.notify === false ? geoCallbackWithoutNotify : geoCallbackWithNotify;
        if (connector.all.length === 4) {
          connector.all(self.modelName, {}, options, geoCallback);
        } else {
          connector.all(self.modelName, {}, geoCallback);
        }
      }
      // already handled
      return cb.promise;
    }
  }

  var allCb = function(err, data) {
    if (!err &#x26;&#x26; Array.isArray(data)) {
      async.map(data, function(item, next) {
        var Model = self.lookupModel(item);
        if (options.notify === false) {
          buildResult(item, next);
        } else {
          withNo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.findById" id="apidoc.element.loopback.DataSource.DataAccessObject.findById">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findById
        <span class="apidocSignatureSpan">(id, filter, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;The id argument is required&#x27;);

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof filter === &#x27;function&#x27;) {
      // findById(id, cb)
      cb = filter;
      filter = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // findById(id, query, cb)
      cb = options;
      options = {};
      if (typeof filter === &#x27;object&#x27; &#x26;&#x26; !(filter.include || filter.fields)) {
        // If filter doesn&#x27;t have include or fields, assuming it&#x27;s options
        options = filter;
        filter = {};
      }
    }
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};
  filter = filter || {};

  assert(typeof filter === &#x27;object&#x27;, &#x27;The filter argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (isPKMissing(this, cb)) {
    return cb.promise;
  } else if (id == null || id === &#x27;&#x27;) {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;{{Model::findById}} requires the apidoc.element.loopback.DataSource.DataAccessObject.findById argument&#x27;)));
    });
  } else {
    var query = byIdQuery(this, id);
    if (filter.include) {
      query.include = filter.include;
    }
    if (filter.fields) {
      query.fields = filter.fields;
    }
    this.findOne(query, options, cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.DataSource.DataAccessObject.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.findByIds" id="apidoc.element.loopback.DataSource.DataAccessObject.findByIds">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findByIds
        <span class="apidocSignatureSpan">(ids, query, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findByIds = function (ids, query, options, cb) {
  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof query === &#x27;function&#x27;) {
      // findByIds(ids, cb)
      cb = query;
      query = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // findByIds(ids, query, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};
  query = query || {};

  assert(Array.isArray(ids), &#x27;The ids argument must be an array&#x27;);
  assert(typeof query === &#x27;object&#x27;, &#x27;The query argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (isPKMissing(this, cb)) {
    return cb.promise;
  } else if (ids.length === 0) {
    process.nextTick(function() { cb(null, []); });
    return cb.promise;
  }

  var filter = {where: {}};
  var pk = idName(this);
  filter.where[pk] = {inq: [].concat(ids)};
  mergeQuery(filter, query || {});

  // to know if the result need to be sorted by ids or not
  // this variable need to be initialized before the call to find, because filter is updated during the call with an order
  var toSortObjectsByIds = filter.order ? false : true;

  this.find(filter, options, function(err, results) {
    cb(err, toSortObjectsByIds ? utils.sortObjectsByIds(pk, ids, results) : results);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.findOne" id="apidoc.element.loopback.DataSource.DataAccessObject.findOne">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findOne
        <span class="apidocSignatureSpan">(query, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(query, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof query === &#x27;function&#x27;) {
      cb = query;
      query = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  query = query || {};
  options = options || {};

  assert(typeof query === &#x27;object&#x27;, &#x27;The query argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  query.limit = 1;
  this.find(query, options, function(err, collection) {
    if (err || !collection || !collection.length &#x3e; 0) return cb(err, null);
    cb(err, collection[0]);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.findOrCreate" id="apidoc.element.loopback.DataSource.DataAccessObject.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;At least one argument is required&#x27;);
  if (data === undefined &#x26;&#x26; options === undefined &#x26;&#x26; cb === undefined) {
    assert(typeof query === &#x27;object&#x27;, &#x27;Single argument must be data object&#x27;);
    // findOrCreate(data);
    // query will be built from data, and method will return Promise
    data = query;
    query = {where: data};
  } else  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // findOrCreate(data, cb);
      // query will be built from data
      cb = data;
      data = query;
      query = {where: data};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // findOrCreate(query, data, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  query = query || {where: {}};
  data = data || {};
  options = options || {};

  assert(typeof query === &#x27;object&#x27;, &#x27;The query argument must be an object&#x27;);
  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};

  var Model = this;
  var self = this;
  var connector = Model.getConnector();

  function _findOrCreate(query, data, currentInstance) {
    var modelName = self.modelName;
    function findOrCreateCallback(err, data, created) {
      if (err) return cb(err);
      var context = {
        Model: Model,
        data: data,
        isNewInstance: created,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;loaded&#x27;, context, function(err) {
        if (err) return cb(err);

        var obj, Model = self.lookupModel(data);

        if (data) {
          obj = new Model(data, {fields: query.fields, applySetters: false,
            persisted: true});
        }

        if (created) {
          var context = {
            Model: Model,
            instance: obj,
            isNewInstance: true,
            hookState: hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;after save&#x27;, context, function(err) {
            if (cb.promise) {
              cb(err, [obj, created]);
            } else {
              cb(err, obj, created);
            }
          });
        } else {
          if (cb.promise) {
            cb(err, [obj, created]);
          } else {
            cb(err, obj, created);
          }
        }
      });
    }

    data = removeUndefined(data);
    var context = {
      Model: Model,
      where: query.where,
      data: data,
      isNewInstance: true,
      currentInstance: currentInstance,
      hookState: hookState,
      options: options,
    };

    Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
      if (err) return cb(err);

      if (connector.findOrCreate.length === 5) {
        connector.findOrCreate(modelName, query, self._forDB(context.data), options, findOrCreateCallback);
      } else {
        connector.findOrCreate(modelName, query, self._forDB(context.data), findOrCreateCallback);
      }
    });
  }

  if (connector.findOrCreate) {
    query.limit = 1;

    try {
      this._normalize(query, options);
    } catch (err) {
      process.nextTick(function() {
        cb(err);
      });
      return cb.promise;
    }

    this.applyScope(query);

    var context = {
      Model: Model,
      query: query,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
      if (err) return cb(err);

      var query = ctx.query;

      var enforced = {};
      var Model = self.lookupModel(data);
      var obj = data instanceof Model ? data : new Model(data);

      Model.applyProperties(enforced, obj);
      obj.setAttributes(enforced);

      var conte ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.getConnector" id="apidoc.element.loopback.DataSource.DataAccessObject.getConnector">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>getConnector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnector = function () {
  return this.getDataSource().connector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.hasAndBelongsToMany" id="apidoc.element.loopback.DataSource.DataAccessObject.hasAndBelongsToMany">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>hasAndBelongsToMany
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasAndBelongsToMany(modelTo, params) {
  return RelationDefinition.hasAndBelongsToMany(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.hasMany" id="apidoc.element.loopback.DataSource.DataAccessObject.hasMany">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>hasMany
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasMany(modelTo, params) {
  return RelationDefinition.hasMany(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.hasOne" id="apidoc.element.loopback.DataSource.DataAccessObject.hasOne">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>hasOne
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasOne(modelTo, params) {
  return RelationDefinition.hasOne(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.include" id="apidoc.element.loopback.DataSource.DataAccessObject.include">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>include
        <span class="apidocSignatureSpan">(objects, include, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">include = function (objects, include, options, cb) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; cb === undefined) {
    cb = options;
    options = {};
  }
  var self = this;

  if (!include || (Array.isArray(include) &#x26;&#x26; include.length === 0) ||
      (Array.isArray(objects) &#x26;&#x26; objects.length === 0) ||
      (isPlainObject(include) &#x26;&#x26; Object.keys(include).length === 0)) {
    // The objects are empty
    return process.nextTick(function() {
      cb &#x26;&#x26; cb(null, objects);
    });
  }

  include = normalizeInclude(include);

  // Find the limit of items for `inq`
  var inqLimit = 256;
  if (self.dataSource &#x26;&#x26; self.dataSource.settings &#x26;&#x26;
    self.dataSource.settings.inqLimit) {
    inqLimit = self.dataSource.settings.inqLimit;
  }

  async.each(include, function(item, callback) {
    processIncludeItem(objects, item, options, callback);
  }, function(err) {
    cb &#x26;&#x26; cb(err, objects);
  });

<span class="apidocCodeCommentSpan">  /**
   * Find related items with an array of foreign keys by page
   * @param model The model class
   * @param filter The query filter
   * @param fkName The name of the foreign key property
   * @param pageSize The size of page
   * @param options Options
   * @param cb
   */
</span>  function findWithForeignKeysByPage(model, filter, fkName, pageSize, options, cb) {
    var foreignKeys = [];
    if (filter.where[fkName]) {
      foreignKeys = filter.where[fkName].inq;
    } else if (filter.where.and) {
      // The inq can be embedded inside &#x27;and: []&#x27;. No or: [] is needed as
      // include only uses and. We only deal with the generated inq for include.
      for (var j in filter.where.and) {
        if (filter.where.and[j][fkName] &#x26;&#x26;
          Array.isArray(filter.where.and[j][fkName].inq)) {
          foreignKeys = filter.where.and[j][fkName].inq;
          break;
        }
      }
    }
    if (!foreignKeys.length) {
      return cb(null, []);
    }
    if (filter.limit || filter.skip || filter.offset) {
      // Force the find to be performed per FK to honor the pagination
      pageSize = 1;
    }
    var size = foreignKeys.length;
    if (size &#x3e; inqLimit &#x26;&#x26; pageSize &#x3c;= 0) {
      pageSize = inqLimit;
    }
    if (pageSize &#x3c;= 0) {
      return model.find(filter, options, cb);
    }

    var listOfFKs = [];

    for (var i = 0; i &#x3c; size; i += pageSize) {
      var end = i + pageSize;
      if (end &#x3e; size) {
        end = size;
      }
      listOfFKs.push(foreignKeys.slice(i, end));
    }

    var items = [];
    // Optimization: no need to resolve keys that are an empty array
    listOfFKs = listOfFKs.filter(function(keys) {
      return keys.length &#x3e; 0;
    });
    async.each(listOfFKs, function(foreignKeys, done) {
      var newFilter = {};
      for (var f in filter) {
        newFilter[f] = filter[f];
      }
      if (filter.where) {
        newFilter.where = {};
        for (var w in filter.where) {
          newFilter.where[w] = filter.where[w];
        }
      }
      newFilter.where[fkName] = {
        inq: foreignKeys,
      };
      model.find(newFilter, options, function(err, results) {
        if (err) return done(err);
        items = items.concat(results);
        done();
      });
    }, function(err) {
      if (err) return cb(err);
      cb(null, items);
    });
  }

  function processIncludeItem(objs, include, options, cb) {
    var relations = self.relations;

    var relationName;
    var subInclude = null, scope = null;

    if (isPlainObject(include)) {
      relationName = Object.keys(include)[0];
      if (include[relationName] instanceof IncludeScope) {
        scope = include[relationName];
        subInclude = scope.include();
      } else {
        subInclude = include[relationName];
        // when include = {user:true}, it does not have subInclude
        if (subInclude === true) {
          subInclude = null;
        }
      }
    } else {
      relationName = include;
      subInclude = null;
    }

    var relation = relations[relationName];
    if (!relation) {
      cb(new Error(g.f(&#x27;Relation &#x22;%s&#x22; is not defined for %s model&#x27;, relationName, self.modelName)));
      return;
    }
    var polymorphic = relation.p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.lookupModel" id="apidoc.element.loopback.DataSource.DataAccessObject.lookupModel">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>lookupModel
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupModel = function (data) {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.normalizeInclude" id="apidoc.element.loopback.DataSource.DataAccessObject.normalizeInclude">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>normalizeInclude
        <span class="apidocSignatureSpan">(include)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalizeInclude(include) {
  var newInclude;
  if (typeof include === &#x27;string&#x27;) {
    return [include];
  } else if (isPlainObject(include)) {
    // Build an array of key/value pairs
    newInclude = [];
    var rel = include.rel || include.relation;
    var obj = {};
    if (typeof rel === &#x27;string&#x27;) {
      obj[rel] = new IncludeScope(include.scope);
      newInclude.push(obj);
    } else {
      for (var key in include) {
        obj[key] = include[key];
        newInclude.push(obj);
      }
    }
    return newInclude;
  } else if (Array.isArray(include)) {
    newInclude = [];
    for (var i = 0, n = include.length; i &#x3c; n; i++) {
      var subIncludes = normalizeInclude(include[i]);
      newInclude = newInclude.concat(subIncludes);
    }
    return newInclude;
  } else {
    return include;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.patchOrCreate" id="apidoc.element.loopback.DataSource.DataAccessObject.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchOrCreate = function (data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // upsert(cb)
      cb = data;
      data = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // upsert(data, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  data = data || {};
  options = options || {};

  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (Array.isArray(data)) {
    cb(new Error(&#x27;updateOrCreate does not support bulk mode or any array input&#x27;));
    return cb.promise;
  }

  var hookState = {};

  var self = this;
  var Model = this;
  var connector = Model.getConnector();

  var id = getIdValue(this, data);
  if (id === undefined || id === null) {
    return this.create(data, options, cb);
  }

  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, doUpdateOrCreate);

  function doUpdateOrCreate(err, ctx) {
    if (err) return cb(err);

    var isOriginalQuery = isWhereByGivenId(Model, ctx.query.where, id);
    if (connector.updateOrCreate &#x26;&#x26; isOriginalQuery) {
      var context = {
        Model: Model,
        where: ctx.query.where,
        data: data,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
        if (err) return cb(err);

        data = ctx.data;
        var update = data;
        var inst = data;
        if (!(data instanceof Model)) {
          inst = new Model(data, {applyDefaultValues: false});
        }
        update = inst.toObject(false);

        Model.applyProperties(update, inst);
        Model = Model.lookupModel(update);

        var connector = self.getConnector();

        var doValidate = undefined;
        if (options.validate === undefined) {
          if (Model.settings.validateUpsert === undefined) {
            if (Model.settings.automaticValidation !== undefined) {
              doValidate = Model.settings.automaticValidation;
            }
          } else {
            doValidate = Model.settings.validateUpsert;
          }
        } else {
          doValidate = options.validate;
        }

        if (doValidate === false) {
          callConnector();
        } else {
          inst.isValid(function(valid) {
            if (!valid) {
              if (doValidate) { // backwards compatibility with validateUpsert:undefined
                return cb(new ValidationError(inst), inst);
              } else {
                // TODO(bajtos) Remove validateUpsert:undefined in v3.0
                g.warn(&#x27;Ignoring validation errors in {{updateOrCreate()}}:&#x27;);
                g.warn(&#x27;  %s&#x27;, new ValidationError(inst).message);
                // continue with updateOrCreate
              }
            }
            callConnector();
          }, update, options);
        }

        function callConnector() {
          update = removeUndefined(update);
          context = {
            Model: Model,
            where: ctx.where,
            data: update,
            currentInstance: inst,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
            if (err) return done(err);
            if (connector.updateOrCreate.length === 4) {
              connector.updateOrCreate(Model.modelName, update, options, done);
            } else {
              connector.updateOrCreate(Model.modelName, update, done);
            }
          });
        }
        function done(err, data, info) {
          if (err) return cb(err);
          var context = { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.patchOrCreateWithWhere" id="apidoc.element.loopback.DataSource.DataAccessObject.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchOrCreateWithWhere = function (where, data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) { return connectionPromise; }
  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // upsertWithWhere(where, data, cb)
      cb = options;
      options = {};
    }
  }
  cb = cb || utils.createPromiseCallback();
  options = options || {};
  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);
  if (Object.keys(data).length === 0) {
    var err = new Error(&#x27;data object cannot be empty!&#x27;);
    err.statusCode = 400;
    process.nextTick(function() { cb(err); });
    return cb.promise;
  }
  var hookState = {};
  var self = this;
  var Model = this;
  var connector = Model.getConnector();
  var modelName = Model.modelName;
  var query = {where: where};
  var context = {
    Model: Model,
    query: query,
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, doUpsertWithWhere);
  function doUpsertWithWhere(err, ctx) {
    if (err) return cb(err);
    ctx.data = data;
    if (connector.upsertWithWhere) {
      var context = {
        Model: Model,
        where: ctx.query.where,
        data: ctx.data,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
        if (err) return cb(err);
        data = ctx.data;
        var update = data;
        var inst = data;
        if (!(data instanceof Model)) {
          inst = new Model(data, {applyDefaultValues: false});
        }
        update = inst.toObject(false);
        Model.applyScope(query);
        Model.applyProperties(update, inst);
        Model = Model.lookupModel(update);
        if (options.validate === false) {
          return callConnector();
        }
        if (options.validate === undefined &#x26;&#x26; Model.settings.automaticValidation === false) {
          return callConnector();
        }
        inst.isValid(function(valid) {
          if (!valid) return cb(new ValidationError(inst), inst);
          callConnector();
        }, update, options);

        function callConnector() {
          try {
            ctx.where = removeUndefined(ctx.where);
            ctx.where = Model._coerce(ctx.where, options);
            update = removeUndefined(update);
            update = Model._coerce(update, options);
          } catch (err) {
            return process.nextTick(function() {
              cb(err);
            });
          }
          context = {
            Model: Model,
            where: ctx.where,
            data: update,
            currentInstance: inst,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
            if (err) return done(err);
            connector.upsertWithWhere(modelName, ctx.where, update, options, done);
          });
        }
        function done(err, data, info) {
          if (err) return cb(err);
          var contxt = {
            Model: Model,
            data: data,
            isNewInstance: info &#x26;&#x26; info.isNewInstance,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;loaded&#x27;, contxt, function(err) {
            if (err) return cb(err);
            var obj;
            if (contxt.data &#x26;&#x26; !(contxt.data instanceof Model)) {
              inst._initProperties(contxt.data, {persisted: true});
              obj = inst;
            } else {
              obj = contxt.data;
            }
            var context = {
              Model: Model,
              instance: obj,
              isNewInstance: info ? info.isNewInstance : undefined,
              hookState: hookState,
              options: options,
            }; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.referencesMany" id="apidoc.element.loopback.DataSource.DataAccessObject.referencesMany">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>referencesMany
        <span class="apidocSignatureSpan">(modelTo, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function referencesMany(modelTo, params) {
  return RelationDefinition.referencesMany(this, modelTo, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.remove" id="apidoc.element.loopback.DataSource.DataAccessObject.remove">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>remove
        <span class="apidocSignatureSpan">(where, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  var Model = this;
  var connector = Model.getConnector();

  assert(typeof connector.destroyAll === &#x27;function&#x27;,
    &#x27;destroyAll() must be implemented by the connector&#x27;);

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof where === &#x27;function&#x27;) {
      cb = where;
      where = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  where = where || {};
  options = options || {};

  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};

  var query = {where: where};
  this.applyScope(query);
  where = query.where;

  if (options.notify === false) {
    doDelete(where);
  } else {
    query = {where: whereIsEmpty(where) ? {} : where};
    var context = {
      Model: Model,
      query: query,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
      if (err) return cb(err);
      var context = {
        Model: Model,
        where: ctx.query.where,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before delete&#x27;, context, function(err, ctx) {
        if (err) return cb(err);
        doDelete(ctx.where);
      });
    });
  }

  function doDelete(where) {
    var context = {
      Model: Model,
      where: whereIsEmpty(where) ? {} : where,
      hookState: hookState,
      options: options,
    };

    if (whereIsEmpty(where)) {
      if (connector.destroyAll.length === 4) {
        connector.destroyAll(Model.modelName, {}, options, done);
      } else {
        connector.destroyAll(Model.modelName, {}, done);
      }
    } else {
      try {
        // Support an optional where object
        where = removeUndefined(where);
        where = Model._coerce(where, options);
      } catch (err) {
        return process.nextTick(function() {
          cb(err);
        });
      }

      if (connector.destroyAll.length === 4) {
        connector.destroyAll(Model.modelName, where, options, done);
      } else {
        connector.destroyAll(Model.modelName, where, done);
      }
    }

    function done(err, info) {
      if (err) return cb(err);

      if (options.notify === false) {
        return cb(err, info);
      }

      var context = {
        Model: Model,
        where: where,
        hookState: hookState,
        options: options,
        info: info,
      };
      Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
        cb(err, info);
      });
    }
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.removeById" id="apidoc.element.loopback.DataSource.DataAccessObject.removeById">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>removeById
        <span class="apidocSignatureSpan">(id, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;The id argument is required&#x27;);
  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // destroyById(id, cb)
      cb = options;
      options = {};
    }
  }

  options = options || {};
  cb = cb || utils.createPromiseCallback();

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (isPKMissing(this, cb)) {
    return cb.promise;
  } else if (id == null || id === &#x27;&#x27;) {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;{{Model::deleteById}} requires the apidoc.element.loopback.DataSource.DataAccessObject.removeById argument&#x27;)));
    });
    return cb.promise;
  }

  var Model = this;

  this.remove(byIdQuery(this, id).where, options, function(err, info) {
    if (err) return cb(err);
    var deleted = info &#x26;&#x26; info.count &#x3e; 0;
    if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
      err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.removeById %s found for %s&#x27;, id, Model.modelName));
      err.code = &#x27;NOT_FOUND&#x27;;
      err.statusCode = 404;
      return cb(err);
    }

    cb(null, info);
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.replaceById" id="apidoc.element.loopback.DataSource.DataAccessObject.replaceById">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceById = function (id, data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert((typeof data === &#x27;object&#x27;) &#x26;&#x26; (data !== null),
          &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var connector = this.getConnector();

  var err;
  if (typeof connector.replaceById !== &#x27;function&#x27;) {
    err = new Error(g.f(
      &#x27;The connector %s does not support {{replaceById}} operation. This is not a bug in LoopBack. &#x27; +
      &#x27;Please contact the authors of the connector, preferably via GitHub issues.&#x27;,
      connector.name));
    return cb(err);
  }

  var pkName = idName(this);
  if (!data[pkName]) data[pkName] = id;

  var Model = this;
  var inst = new Model(data, {persisted: true});
  var enforced = {};
  this.applyProperties(enforced, inst);
  inst.setAttributes(enforced);
  Model = this.lookupModel(data); // data-specific
  if (Model !== inst.constructor) inst = new Model(data);
  var strict = inst.__strict;

  if (isPKMissing(Model, cb))
    return cb.promise;

  var model = Model.modelName;
  var hookState = {};

  if (id !== data[pkName]) {
    err = new Error(g.f(&#x27;apidoc.element.loopback.DataSource.DataAccessObject.replaceById property (%s) &#x27; +
            &#x27;cannot be updated from %s to %s&#x27;, pkName, id, data[pkName]));
    err.statusCode = 400;
    process.nextTick(function() { cb(err); });
    return cb.promise;
  }

  var context = {
    Model: Model,
    instance: inst,
    isNewInstance: false,
    hookState: hookState,
    options: options,
  };

  Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
    if (err) return cb(err);

    if (ctx.instance[pkName] !== id &#x26;&#x26; !Model._warned.cannotOverwritePKInBeforeSaveHook) {
      Model._warned.cannotOverwritePKInBeforeSaveHook = true;
      g.warn(&#x27;WARNING: apidoc.element.loopback.DataSource.DataAccessObject.replaceById property cannot be changed from %s to %s for model:%s &#x27; +
        &#x27;in {{\&#x27;before save\&#x27;}} operation hook&#x27;, id, inst[pkName], Model.modelName);
    }

    data = inst.toObject(false);

    if (strict) {
      applyStrictCheck(Model, strict, data, inst, validateAndCallConnector);
    } else {
      validateAndCallConnector(null, data);
    }

    function validateAndCallConnector(err, data) {
      if (err) return cb(err);
      data = removeUndefined(data);
      // update instance&#x27;s properties
      inst.setAttributes(data);

      var doValidate = true;
      if (options.validate === undefined) {
        if (Model.settings.automaticValidation !== undefined) {
          doValidate = Model.settings.automaticValidation;
        }
      } else {
        doValidate = options.validate;
      }

      if (doValidate) {
        inst.isValid(function(valid) {
          if (!valid) return cb(new ValidationError(inst), inst);

          callConnector();
        }, data, options);
      } else {
        callConnector();
      }

      function callConnector() {
        copyData(data, inst);
        var typedData = convertSubsetOfPropertiesByType(inst, data);
        context.data = typedData;

        function replaceCallback(err, data) {
          if (err) return cb(err);

          var ctx = {
            Model: Model,
            hookState: hookState,
            data: context.data,
            isNewInstance: false,
            options: options,
          };
          Model.notifyObserversOf(&#x27;loaded&#x27;, ctx, function(err) {
            if (err) return cb(err);

            if (ctx.data[pkName] !== id &#x26;&#x26; !Model._warned.cannotOverwritePKInLoadedHook) {
              Model._warned.cannotOverwritePKInLoadedHook = true;
              g.warn(&#x27;WARNING: apidoc.element.loopback.DataSource.DataAccessObject.replaceById property cannot be changed from %s to %s for model:%s in &#x27; +
                &#x27;{{\&#x27;loaded\&#x27;}} operation hook&#x27;,
                id, ctx.data[pkName], Model.modelName); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.replaceOrCreate" id="apidoc.element.loopback.DataSource.DataAccessObject.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // replaceOrCreta(data,cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  data = data || {};
  options = options || {};

  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var hookState = {};

  var self = this;
  var Model = this;
  var connector = Model.getConnector();

  var id = getIdValue(this, data);
  if (id === undefined || id === null) {
    return this.create(data, options, cb);
  }

  var forceId = this.settings.forceId;
  if (forceId) {
    return Model.replaceById(id, data, options, cb);
  }

  var inst;
  if (data instanceof Model) {
    inst = data;
  } else {
    inst = new Model(data);
  }

  var strict = inst.__strict;
  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, doReplaceOrCreate);

  function doReplaceOrCreate(err, ctx) {
    if (err) return cb(err);

    var isOriginalQuery = isWhereByGivenId(Model, ctx.query.where, id);
    var where = ctx.query.where;
    if (connector.replaceOrCreate &#x26;&#x26; isOriginalQuery) {
      var context = {
        Model: Model,
        instance: inst,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
        if (err) return cb(err);
        var update = inst.toObject(false);
        if (strict) {
          applyStrictCheck(Model, strict, update, inst, validateAndCallConnector);
        } else {
          validateAndCallConnector();
        }

        function validateAndCallConnector(err) {
          if (err) return cb(err);
          Model.applyProperties(update, inst);
          Model = Model.lookupModel(update);

          var connector = self.getConnector();

          if (options.validate === false) {
            return callConnector();
          }

          // only when options.validate is not set, take model-setting into consideration
          if (options.validate === undefined &#x26;&#x26; Model.settings.automaticValidation === false) {
            return callConnector();
          }

          inst.isValid(function(valid) {
            if (!valid) return cb(new ValidationError(inst), inst);
            callConnector();
          }, update, options);

          function callConnector() {
            update = removeUndefined(update);
            context = {
              Model: Model,
              where: where,
              data: update,
              currentInstance: inst,
              hookState: ctx.hookState,
              options: options,
            };
            Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
              if (err) return done(err);
              connector.replaceOrCreate(Model.modelName, context.data, options, done);
            });
          }
          function done(err, data, info) {
            if (err) return cb(err);
            var context = {
              Model: Model,
              data: data,
              isNewInstance: info ? info.isNewInstance : undefined,
              hookState: ctx.hookState,
              options: options,
            };
            Model.notifyObserversOf(&#x27;loaded&#x27;, context, function(err) {
              if (err) return cb(err);

              var obj;
              if (data &#x26;&#x26; !(data instanceof Model)) {
                inst._initProperties(data, {persisted: true});
                obj = inst;
              } else {
                obj = data;
              }
              if (err) {
                cb(err, obj);
              } else {
                var context = {
                  Model: Model, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.scope" id="apidoc.element.loopback.DataSource.DataAccessObject.scope">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>scope
        <span class="apidocSignatureSpan">(name, query, targetClass, methods, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scope = function (name, query, targetClass, methods, options) {
  var cls = this;
  if (options &#x26;&#x26; options.isStatic === false) {
    cls = cls.prototype;
  }
  return defineScope(cls, targetClass || cls, name, query, methods, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.update" id="apidoc.element.loopback.DataSource.DataAccessObject.update">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>update
        <span class="apidocSignatureSpan">(where, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (where, data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;At least one argument is required&#x27;);

  if (data === undefined &#x26;&#x26; options === undefined &#x26;&#x26; cb === undefined &#x26;&#x26; arguments.length === 1) {
    data = where;
    where = {};
  } else if (options === undefined &#x26;&#x26; cb === undefined) {
    // One of:
    // updateAll(data, cb)
    // updateAll(where, data) -&#x3e; Promise
    if (typeof data === &#x27;function&#x27;) {
      cb = data;
      data = where;
      where = {};
    }
  } else if (cb === undefined) {
    // One of:
    // updateAll(where, data, options) -&#x3e; Promise
    // updateAll(where, data, cb)
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  data = data || {};
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var Model = this;
  var connector = Model.getDataSource().connector;
  assert(typeof connector.update === &#x27;function&#x27;,
    &#x27;update() must be implemented by the connector&#x27;);

  var hookState = {};

  var query = {where: where};
  this.applyScope(query);
  this.applyProperties(data);

  where = query.where;

  var context = {
    Model: Model,
    query: {where: where},
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    var context = {
      Model: Model,
      where: ctx.query.where,
      data: data,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;before save&#x27;, context,
      function(err, ctx) {
        if (err) return cb(err);
        doUpdate(ctx.where, ctx.data);
      });
  });

  function doUpdate(where, data) {
    try {
      where = removeUndefined(where);
      where = Model._coerce(where, options);
      data = removeUndefined(data);
      data = Model._coerce(data, options);
    } catch (err) {
      return process.nextTick(function() {
        cb(err);
      });
    }

    function updateCallback(err, info) {
      if (err) return cb(err);

      var context = {
        Model: Model,
        where: where,
        data: data,
        hookState: hookState,
        options: options,
        info: info,
      };
      Model.notifyObserversOf(&#x27;after save&#x27;, context, function(err, ctx) {
        return cb(err, info);
      });
    }

    var context = {
      Model: Model,
      where: where,
      data: data,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err, ctx) {
      if (err) return cb(err);

      if (connector.update.length === 5) {
        connector.update(Model.modelName, where, data, options, updateCallback);
      } else {
        connector.update(Model.modelName, where, data, updateCallback);
      }
    });
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.updateAll" id="apidoc.element.loopback.DataSource.DataAccessObject.updateAll">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateAll = function (where, data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  assert(arguments.length &#x3e;= 1, &#x27;At least one argument is required&#x27;);

  if (data === undefined &#x26;&#x26; options === undefined &#x26;&#x26; cb === undefined &#x26;&#x26; arguments.length === 1) {
    data = where;
    where = {};
  } else if (options === undefined &#x26;&#x26; cb === undefined) {
    // One of:
    // updateAll(data, cb)
    // updateAll(where, data) -&#x3e; Promise
    if (typeof data === &#x27;function&#x27;) {
      cb = data;
      data = where;
      where = {};
    }
  } else if (cb === undefined) {
    // One of:
    // updateAll(where, data, options) -&#x3e; Promise
    // updateAll(where, data, cb)
    if (typeof options === &#x27;function&#x27;) {
      cb = options;
      options = {};
    }
  }

  data = data || {};
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var Model = this;
  var connector = Model.getDataSource().connector;
  assert(typeof connector.update === &#x27;function&#x27;,
    &#x27;update() must be implemented by the connector&#x27;);

  var hookState = {};

  var query = {where: where};
  this.applyScope(query);
  this.applyProperties(data);

  where = query.where;

  var context = {
    Model: Model,
    query: {where: where},
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    var context = {
      Model: Model,
      where: ctx.query.where,
      data: data,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;before save&#x27;, context,
      function(err, ctx) {
        if (err) return cb(err);
        doUpdate(ctx.where, ctx.data);
      });
  });

  function doUpdate(where, data) {
    try {
      where = removeUndefined(where);
      where = Model._coerce(where, options);
      data = removeUndefined(data);
      data = Model._coerce(data, options);
    } catch (err) {
      return process.nextTick(function() {
        cb(err);
      });
    }

    function updateCallback(err, info) {
      if (err) return cb(err);

      var context = {
        Model: Model,
        where: where,
        data: data,
        hookState: hookState,
        options: options,
        info: info,
      };
      Model.notifyObserversOf(&#x27;after save&#x27;, context, function(err, ctx) {
        return cb(err, info);
      });
    }

    var context = {
      Model: Model,
      where: where,
      data: data,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err, ctx) {
      if (err) return cb(err);

      if (connector.update.length === 5) {
        connector.update(Model.modelName, where, data, options, updateCallback);
      } else {
        connector.update(Model.modelName, where, data, updateCallback);
      }
    });
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.updateOrCreate" id="apidoc.element.loopback.DataSource.DataAccessObject.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOrCreate = function (data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // upsert(cb)
      cb = data;
      data = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // upsert(data, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  data = data || {};
  options = options || {};

  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (Array.isArray(data)) {
    cb(new Error(&#x27;updateOrCreate does not support bulk mode or any array input&#x27;));
    return cb.promise;
  }

  var hookState = {};

  var self = this;
  var Model = this;
  var connector = Model.getConnector();

  var id = getIdValue(this, data);
  if (id === undefined || id === null) {
    return this.create(data, options, cb);
  }

  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, doUpdateOrCreate);

  function doUpdateOrCreate(err, ctx) {
    if (err) return cb(err);

    var isOriginalQuery = isWhereByGivenId(Model, ctx.query.where, id);
    if (connector.updateOrCreate &#x26;&#x26; isOriginalQuery) {
      var context = {
        Model: Model,
        where: ctx.query.where,
        data: data,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
        if (err) return cb(err);

        data = ctx.data;
        var update = data;
        var inst = data;
        if (!(data instanceof Model)) {
          inst = new Model(data, {applyDefaultValues: false});
        }
        update = inst.toObject(false);

        Model.applyProperties(update, inst);
        Model = Model.lookupModel(update);

        var connector = self.getConnector();

        var doValidate = undefined;
        if (options.validate === undefined) {
          if (Model.settings.validateUpsert === undefined) {
            if (Model.settings.automaticValidation !== undefined) {
              doValidate = Model.settings.automaticValidation;
            }
          } else {
            doValidate = Model.settings.validateUpsert;
          }
        } else {
          doValidate = options.validate;
        }

        if (doValidate === false) {
          callConnector();
        } else {
          inst.isValid(function(valid) {
            if (!valid) {
              if (doValidate) { // backwards compatibility with validateUpsert:undefined
                return cb(new ValidationError(inst), inst);
              } else {
                // TODO(bajtos) Remove validateUpsert:undefined in v3.0
                g.warn(&#x27;Ignoring validation errors in {{updateOrCreate()}}:&#x27;);
                g.warn(&#x27;  %s&#x27;, new ValidationError(inst).message);
                // continue with updateOrCreate
              }
            }
            callConnector();
          }, update, options);
        }

        function callConnector() {
          update = removeUndefined(update);
          context = {
            Model: Model,
            where: ctx.where,
            data: update,
            currentInstance: inst,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
            if (err) return done(err);
            if (connector.updateOrCreate.length === 4) {
              connector.updateOrCreate(Model.modelName, update, options, done);
            } else {
              connector.updateOrCreate(Model.modelName, update, done);
            }
          });
        }
        function done(err, data, info) {
          if (err) return cb(err);
          var context = { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.upsert" id="apidoc.element.loopback.DataSource.DataAccessObject.upsert">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>upsert
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upsert = function (data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // upsert(cb)
      cb = data;
      data = {};
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // upsert(data, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  data = data || {};
  options = options || {};

  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  if (Array.isArray(data)) {
    cb(new Error(&#x27;updateOrCreate does not support bulk mode or any array input&#x27;));
    return cb.promise;
  }

  var hookState = {};

  var self = this;
  var Model = this;
  var connector = Model.getConnector();

  var id = getIdValue(this, data);
  if (id === undefined || id === null) {
    return this.create(data, options, cb);
  }

  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, doUpdateOrCreate);

  function doUpdateOrCreate(err, ctx) {
    if (err) return cb(err);

    var isOriginalQuery = isWhereByGivenId(Model, ctx.query.where, id);
    if (connector.updateOrCreate &#x26;&#x26; isOriginalQuery) {
      var context = {
        Model: Model,
        where: ctx.query.where,
        data: data,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
        if (err) return cb(err);

        data = ctx.data;
        var update = data;
        var inst = data;
        if (!(data instanceof Model)) {
          inst = new Model(data, {applyDefaultValues: false});
        }
        update = inst.toObject(false);

        Model.applyProperties(update, inst);
        Model = Model.lookupModel(update);

        var connector = self.getConnector();

        var doValidate = undefined;
        if (options.validate === undefined) {
          if (Model.settings.validateUpsert === undefined) {
            if (Model.settings.automaticValidation !== undefined) {
              doValidate = Model.settings.automaticValidation;
            }
          } else {
            doValidate = Model.settings.validateUpsert;
          }
        } else {
          doValidate = options.validate;
        }

        if (doValidate === false) {
          callConnector();
        } else {
          inst.isValid(function(valid) {
            if (!valid) {
              if (doValidate) { // backwards compatibility with validateUpsert:undefined
                return cb(new ValidationError(inst), inst);
              } else {
                // TODO(bajtos) Remove validateUpsert:undefined in v3.0
                g.warn(&#x27;Ignoring validation errors in {{updateOrCreate()}}:&#x27;);
                g.warn(&#x27;  %s&#x27;, new ValidationError(inst).message);
                // continue with updateOrCreate
              }
            }
            callConnector();
          }, update, options);
        }

        function callConnector() {
          update = removeUndefined(update);
          context = {
            Model: Model,
            where: ctx.where,
            data: update,
            currentInstance: inst,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
            if (err) return done(err);
            if (connector.updateOrCreate.length === 4) {
              connector.updateOrCreate(Model.modelName, update, options, done);
            } else {
              connector.updateOrCreate(Model.modelName, update, done);
            }
          });
        }
        function done(err, data, info) {
          if (err) return cb(err);
          var context = { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.upsertWithWhere" id="apidoc.element.loopback.DataSource.DataAccessObject.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upsertWithWhere = function (where, data, options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) { return connectionPromise; }
  if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // upsertWithWhere(where, data, cb)
      cb = options;
      options = {};
    }
  }
  cb = cb || utils.createPromiseCallback();
  options = options || {};
  assert(typeof where === &#x27;object&#x27;, &#x27;The where argument must be an object&#x27;);
  assert(typeof data === &#x27;object&#x27;, &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);
  if (Object.keys(data).length === 0) {
    var err = new Error(&#x27;data object cannot be empty!&#x27;);
    err.statusCode = 400;
    process.nextTick(function() { cb(err); });
    return cb.promise;
  }
  var hookState = {};
  var self = this;
  var Model = this;
  var connector = Model.getConnector();
  var modelName = Model.modelName;
  var query = {where: where};
  var context = {
    Model: Model,
    query: query,
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;access&#x27;, context, doUpsertWithWhere);
  function doUpsertWithWhere(err, ctx) {
    if (err) return cb(err);
    ctx.data = data;
    if (connector.upsertWithWhere) {
      var context = {
        Model: Model,
        where: ctx.query.where,
        data: ctx.data,
        hookState: hookState,
        options: options,
      };
      Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
        if (err) return cb(err);
        data = ctx.data;
        var update = data;
        var inst = data;
        if (!(data instanceof Model)) {
          inst = new Model(data, {applyDefaultValues: false});
        }
        update = inst.toObject(false);
        Model.applyScope(query);
        Model.applyProperties(update, inst);
        Model = Model.lookupModel(update);
        if (options.validate === false) {
          return callConnector();
        }
        if (options.validate === undefined &#x26;&#x26; Model.settings.automaticValidation === false) {
          return callConnector();
        }
        inst.isValid(function(valid) {
          if (!valid) return cb(new ValidationError(inst), inst);
          callConnector();
        }, update, options);

        function callConnector() {
          try {
            ctx.where = removeUndefined(ctx.where);
            ctx.where = Model._coerce(ctx.where, options);
            update = removeUndefined(update);
            update = Model._coerce(update, options);
          } catch (err) {
            return process.nextTick(function() {
              cb(err);
            });
          }
          context = {
            Model: Model,
            where: ctx.where,
            data: update,
            currentInstance: inst,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
            if (err) return done(err);
            connector.upsertWithWhere(modelName, ctx.where, update, options, done);
          });
        }
        function done(err, data, info) {
          if (err) return cb(err);
          var contxt = {
            Model: Model,
            data: data,
            isNewInstance: info &#x26;&#x26; info.isNewInstance,
            hookState: ctx.hookState,
            options: options,
          };
          Model.notifyObserversOf(&#x27;loaded&#x27;, contxt, function(err) {
            if (err) return cb(err);
            var obj;
            if (contxt.data &#x26;&#x26; !(contxt.data instanceof Model)) {
              inst._initProperties(contxt.data, {persisted: true});
              obj = inst;
            } else {
              obj = contxt.data;
            }
            var context = {
              Model: Model,
              instance: obj,
              isNewInstance: info ? info.isNewInstance : undefined,
              hookState: hookState,
              options: options,
            }; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.DataAccessObject.Transaction.prototype" id="apidoc.module.loopback.DataSource.DataAccessObject.Transaction.prototype">module loopback.DataSource.DataAccessObject.Transaction.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype._notifyBaseObservers" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.clearObservers" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.clearObservers">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.commit" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.commit">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>commit
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (cb) {
  var self = this;
  cb = cb || utils.createPromiseCallback();
  // Report an error if the transaction is not active
  if (!self.connection) {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;The {{transaction}} is not active: %s&#x27;, self.id)));
    });
    return cb.promise;
  }
  var context = {
    transaction: self,
    operation: &#x27;commit&#x27;,
  };

  function work(done) {
    self.connector.commit(self.connection, done);
  }

  self.notifyObserversAround(&#x27;commit&#x27;, context, work, function(err) {
    // Deference the connection to mark the transaction is not active
    // The connection should have been released back the pool
    self.connection = null;
    cb(err);
  });

  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.notifyObserversAround" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.notifyObserversOf" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.observe" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.observe">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.removeObserver" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.removeObserver">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.rollback" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.rollback">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>rollback
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (cb) {
  var self = this;
  cb = cb || utils.createPromiseCallback();
  // Report an error if the transaction is not active
  if (!self.connection) {
    process.nextTick(function() {
      cb(new Error(g.f(&#x27;The {{transaction}} is not active: %s&#x27;, self.id)));
    });
    return cb.promise;
  }
  var context = {
    transaction: self,
    operation: &#x27;rollback&#x27;,
  };

  function work(done) {
    self.connector.rollback(self.connection, done);
  }

  self.notifyObserversAround(&#x27;rollback&#x27;, context, work, function(err) {
    // Deference the connection to mark the transaction is not active
    // The connection should have been released back the pool
    self.connection = null;
    cb(err);
  });

  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.toJSON" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.toJSON">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err) {
    if (done) done(err);
    return;
  }
  mappings.forEach(function(m) {
    var role;
    if (options.returnOnlyRoleNames === true) {
      role = m.<span class="apidocCodeKeywordSpan">toJSON</span>().role.name;
    } else {
      role = m.roleId;
    }
    addRole(role);
  });
  if (done) done();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.toString" id="apidoc.element.loopback.DataSource.DataAccessObject.Transaction.prototype.toString">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.Transaction.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
    if (err) return callback(err);
    var modelIds = models.map(function(m) {
      return m[idName].<span class="apidocCodeKeywordSpan">toString</span>();
    });
    callback(null, changes.filter(function(ch) {
      if (ch.type() === Change.DELETE) return true;
      return modelIds.indexOf(ch.modelId) &#x3e; -1;
    }));
  });
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.DataAccessObject.prototype" id="apidoc.module.loopback.DataSource.DataAccessObject.prototype">module loopback.DataSource.DataAccessObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.delete" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.delete">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>delete
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument should be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument should be a function&#x27;);

  var inst = this;
  var connector = this.getConnector();

  var Model = this.constructor;
  var id = getIdValue(this.constructor, this);
  var hookState = {};

  if (isPKMissing(Model, cb))
    return cb.promise;

  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };

  Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    var context = {
      Model: Model,
      where: ctx.query.where,
      instance: inst,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;before delete&#x27;, context, function(err, ctx) {
      if (err) return cb(err);
      doDeleteInstance(ctx.where);
    });
  });

  function doDeleteInstance(where) {
    if (!isWhereByGivenId(Model, where, id)) {
      // A hook modified the query, it is no longer
      // a simple &#x27;delete model with the given id&#x27;.
      // We must switch to full query-based delete.
      Model.deleteAll(where, {notify: false}, function(err, info) {
        if (err) return cb(err, false);
        var deleted = info &#x26;&#x26; info.count &#x3e; 0;
        if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
          err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.prototype.delete %s found for %s&#x27;, id, Model.modelName));
          err.code = &#x27;NOT_FOUND&#x27;;
          err.statusCode = 404;
          return cb(err, false);
        }
        var context = {
          Model: Model,
          where: where,
          instance: inst,
          hookState: hookState,
          options: options,
          info: info,
        };
        Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
          cb(err, info);
        });
      });
      return;
    }

    inst.trigger(&#x27;destroy&#x27;, function(destroyed) {
      function destroyCallback(err, info) {
        if (err) return cb(err);
        var deleted = info &#x26;&#x26; info.count &#x3e; 0;
        if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
          err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.prototype.delete %s found for %s&#x27;, id, Model.modelName));
          err.code = &#x27;NOT_FOUND&#x27;;
          err.statusCode = 404;
          return cb(err);
        }

        destroyed(function() {
          var context = {
            Model: Model,
            where: where,
            instance: inst,
            hookState: hookState,
            options: options,
            info: info,
          };
          Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
            cb(err, info);
          });
        });
      }

      if (connector.destroy.length === 4) {
        connector.destroy(inst.constructor.modelName, id, options, destroyCallback);
      } else {
        connector.destroy(inst.constructor.modelName, id, destroyCallback);
      }
    }, null, cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.destroy" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.destroy">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>destroy
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument should be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument should be a function&#x27;);

  var inst = this;
  var connector = this.getConnector();

  var Model = this.constructor;
  var id = getIdValue(this.constructor, this);
  var hookState = {};

  if (isPKMissing(Model, cb))
    return cb.promise;

  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };

  Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    var context = {
      Model: Model,
      where: ctx.query.where,
      instance: inst,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;before delete&#x27;, context, function(err, ctx) {
      if (err) return cb(err);
      doDeleteInstance(ctx.where);
    });
  });

  function doDeleteInstance(where) {
    if (!isWhereByGivenId(Model, where, id)) {
      // A hook modified the query, it is no longer
      // a simple &#x27;delete model with the given id&#x27;.
      // We must switch to full query-based delete.
      Model.deleteAll(where, {notify: false}, function(err, info) {
        if (err) return cb(err, false);
        var deleted = info &#x26;&#x26; info.count &#x3e; 0;
        if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
          err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.prototype.destroy %s found for %s&#x27;, id, Model.modelName));
          err.code = &#x27;NOT_FOUND&#x27;;
          err.statusCode = 404;
          return cb(err, false);
        }
        var context = {
          Model: Model,
          where: where,
          instance: inst,
          hookState: hookState,
          options: options,
          info: info,
        };
        Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
          cb(err, info);
        });
      });
      return;
    }

    inst.trigger(&#x27;destroy&#x27;, function(destroyed) {
      function destroyCallback(err, info) {
        if (err) return cb(err);
        var deleted = info &#x26;&#x26; info.count &#x3e; 0;
        if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
          err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.prototype.destroy %s found for %s&#x27;, id, Model.modelName));
          err.code = &#x27;NOT_FOUND&#x27;;
          err.statusCode = 404;
          return cb(err);
        }

        destroyed(function() {
          var context = {
            Model: Model,
            where: where,
            instance: inst,
            hookState: hookState,
            options: options,
            info: info,
          };
          Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
            cb(err, info);
          });
        });
      }

      if (connector.destroy.length === 4) {
        connector.destroy(inst.constructor.modelName, id, options, destroyCallback);
      } else {
        connector.destroy(inst.constructor.modelName, id, destroyCallback);
      }
    }, null, cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    elapsedSeconds &#x3c; secondsToLive;

  if (isValid) {
    process.nextTick(function() {
      cb(null, isValid);
    });
  } else {
    this.<span class="apidocCodeKeywordSpan">destroy</span>(function(err) {
      cb(err, isValid);
    });
  }
} catch (e) {
  process.nextTick(function() {
    cb(e);
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.getConnector" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.getConnector">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>getConnector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnector = function () {
  return this.getDataSource().connector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.isNewRecord" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.isNewRecord">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>isNewRecord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNewRecord = function () {
  return !this.__persisted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.patchAttributes" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.patchAttributes">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>patchAttributes
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patchAttributes = function (data, options, cb) {
  var self = this;
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // updateAttributes(cb)
      cb = data;
      data = undefined;
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // updateAttributes(data, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert((typeof data === &#x27;object&#x27;) &#x26;&#x26; (data !== null),
    &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var inst = this;
  var Model = this.constructor;
  var connector = inst.getConnector();
  assert(typeof connector.updateAttributes === &#x27;function&#x27;,
    &#x27;updateAttributes() must be implemented by the connector&#x27;);

  if (isPKMissing(Model, cb))
    return cb.promise;

  var allowExtendedOperators = Model._allowExtendedOperators(options);
  var strict = this.__strict;
  var model = Model.modelName;
  var hookState = {};

  // Convert the data to be plain object so that update won&#x27;t be confused
  if (data instanceof Model) {
    data = data.toObject(false);
  }
  data = removeUndefined(data);

  // Make sure id(s) cannot be changed
  var idNames = Model.definition.idNames();
  for (var i = 0, n = idNames.length; i &#x3c; n; i++) {
    var idName = idNames[i];
    if (data[idName] !== undefined &#x26;&#x26; !idEquals(data[idName], inst[idName])) {
      var err = new Error(g.f(&#x27;apidoc.element.loopback.DataSource.DataAccessObject.prototype.patchAttributes cannot be updated from &#x27; +
        &#x27;%s to %s when {{forceId}} is set to true&#x27;,
        inst[idName], data[idName]));
      err.statusCode = 400;
      process.nextTick(function() {
        cb(err);
      });
      return cb.promise;
    }
  }

  var context = {
    Model: Model,
    where: byIdQuery(Model, getIdValue(Model, inst)).where,
    data: data,
    currentInstance: inst,
    hookState: hookState,
    options: options,
  };

  Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    data = ctx.data;

    if (strict &#x26;&#x26; !allowExtendedOperators) {
      applyStrictCheck(self.constructor, strict, data, inst, validateAndSave);
    } else {
      validateAndSave(null, data);
    }

    function validateAndSave(err, data) {
      if (err) return cb(err);
      data = removeUndefined(data);
      var doValidate = true;
      if (options.validate === undefined) {
        if (Model.settings.automaticValidation !== undefined) {
          doValidate = Model.settings.automaticValidation;
        }
      } else {
        doValidate = options.validate;
      }

      // update instance&#x27;s properties
      try {
        inst.setAttributes(data);
      } catch (err) {
        return cb(err);
      }

      if (doValidate) {
        inst.isValid(function(valid) {
          if (!valid) {
            cb(new ValidationError(inst), inst);
            return;
          }

          triggerSave();
        }, data, options);
      } else {
        triggerSave();
      }

      function triggerSave() {
        inst.trigger(&#x27;save&#x27;, function(saveDone) {
          inst.trigger(&#x27;update&#x27;, function(done) {
            copyData(data, inst);
            var typedData = convertSubsetOfPropertiesByType(inst, data);
            context.data = typedData;

            function updateAttributesCallback(err) {
              if (err) return cb(err);
              var ctx = {
                Model: Model,
                data: context.data,
                hookState: hookState,
                options: options,
                isNewInstance: false,
              };
              Model.notifyObserversOf(&#x27;loaded&#x27;, ctx, function(err) {
                if (err) return cb(err);

                inst.__persisted = true;

                // By default, the instance passed to updateAttributes callback is NOT updated ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    try {
      User.validatePassword(newPassword);
    } catch (err) {
      return cb(err);
    }

    const delta = {password: newPassword};
    this.<span class="apidocCodeKeywordSpan">patchAttributes</span>(delta, options, (err, updated) =&#x3e; cb(err));
  });
  return cb.promise;
};

/**
 * Verify a user&#x27;s identity by sending them a confirmation email.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.reload" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.reload">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>reload
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reload(cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  return this.constructor.findById(getIdValue(this.constructor, this), cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.remove" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.remove">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>remove
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument should be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument should be a function&#x27;);

  var inst = this;
  var connector = this.getConnector();

  var Model = this.constructor;
  var id = getIdValue(this.constructor, this);
  var hookState = {};

  if (isPKMissing(Model, cb))
    return cb.promise;

  var context = {
    Model: Model,
    query: byIdQuery(Model, id),
    hookState: hookState,
    options: options,
  };

  Model.notifyObserversOf(&#x27;access&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    var context = {
      Model: Model,
      where: ctx.query.where,
      instance: inst,
      hookState: hookState,
      options: options,
    };
    Model.notifyObserversOf(&#x27;before delete&#x27;, context, function(err, ctx) {
      if (err) return cb(err);
      doDeleteInstance(ctx.where);
    });
  });

  function doDeleteInstance(where) {
    if (!isWhereByGivenId(Model, where, id)) {
      // A hook modified the query, it is no longer
      // a simple &#x27;delete model with the given id&#x27;.
      // We must switch to full query-based delete.
      Model.deleteAll(where, {notify: false}, function(err, info) {
        if (err) return cb(err, false);
        var deleted = info &#x26;&#x26; info.count &#x3e; 0;
        if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
          err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.prototype.remove %s found for %s&#x27;, id, Model.modelName));
          err.code = &#x27;NOT_FOUND&#x27;;
          err.statusCode = 404;
          return cb(err, false);
        }
        var context = {
          Model: Model,
          where: where,
          instance: inst,
          hookState: hookState,
          options: options,
          info: info,
        };
        Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
          cb(err, info);
        });
      });
      return;
    }

    inst.trigger(&#x27;destroy&#x27;, function(destroyed) {
      function destroyCallback(err, info) {
        if (err) return cb(err);
        var deleted = info &#x26;&#x26; info.count &#x3e; 0;
        if (Model.settings.strictDelete &#x26;&#x26; !deleted) {
          err = new Error(g.f(&#x27;No instance with apidoc.element.loopback.DataSource.DataAccessObject.prototype.remove %s found for %s&#x27;, id, Model.modelName));
          err.code = &#x27;NOT_FOUND&#x27;;
          err.statusCode = 404;
          return cb(err);
        }

        destroyed(function() {
          var context = {
            Model: Model,
            where: where,
            instance: inst,
            hookState: hookState,
            options: options,
            info: info,
          };
          Model.notifyObserversOf(&#x27;after delete&#x27;, context, function(err) {
            cb(err, info);
          });
        });
      }

      if (connector.destroy.length === 4) {
        connector.destroy(inst.constructor.modelName, id, options, destroyCallback);
      } else {
        connector.destroy(inst.constructor.modelName, id, destroyCallback);
      }
    }, null, cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.replaceAttributes" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.replaceAttributes">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>replaceAttributes
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceAttributes = function (data, options, cb) {
  var Model = this.constructor;
  var id = getIdValue(this.constructor, this);
  return Model.replaceById(id, data, options, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.save" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.save">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>save
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function (options, cb) {
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }
  var Model = this.constructor;

  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument should be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument should be a function&#x27;);

  if (isPKMissing(Model, cb)) {
    return cb.promise;
  }  else if (this.isNewRecord()) {
    return Model.create(this, options, cb);
  }

  var hookState = {};

  if (options.validate === undefined) {
    if (Model.settings.automaticValidation === undefined) {
      options.validate = true;
    } else {
      options.validate = Model.settings.automaticValidation;
    }
  }

  if (options.throws === undefined) {
    options.throws = false;
  }

  var inst = this;
  var connector = inst.getConnector();
  var modelName = Model.modelName;

  var context = {
    Model: Model,
    instance: inst,
    hookState: hookState,
    options: options,
  };
  Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err) {
    if (err) return cb(err);

    var data = inst.toObject(true);
    Model.applyProperties(data, inst);
    inst.setAttributes(data);

    // validate first
    if (!options.validate) {
      return save();
    }

    inst.isValid(function(valid) {
      if (valid) {
        save();
      } else {
        var err = new ValidationError(inst);
        // throws option is dangerous for async usage
        if (options.throws) {
          throw err;
        }
        cb(err, inst);
      }
    }, data, options);

    // then save
    function save() {
      inst.trigger(&#x27;save&#x27;, function(saveDone) {
        inst.trigger(&#x27;update&#x27;, function(updateDone) {
          data = removeUndefined(data);
          function saveCallback(err, unusedData, result) {
            if (err) {
              return cb(err, inst);
            }

            var context = {
              Model: Model,
              data: data,
              isNewInstance: result &#x26;&#x26; result.isNewInstance,
              hookState: hookState,
              options: options,
            };
            Model.notifyObserversOf(&#x27;loaded&#x27;, context, function(err) {
              if (err) return cb(err);

              inst._initProperties(data, {persisted: true});

              var context = {
                Model: Model,
                instance: inst,
                isNewInstance: result &#x26;&#x26; result.isNewInstance,
                hookState: hookState,
                options: options,
              };
              Model.notifyObserversOf(&#x27;after save&#x27;, context, function(err) {
                if (err) return cb(err, inst);
                updateDone.call(inst, function() {
                  saveDone.call(inst, function() {
                    cb(err, inst);
                  });
                });
              });
            });
          }

          context = {
            Model: Model,
            data: data,
            where: byIdQuery(Model, getIdValue(Model, inst)).where,
            currentInstance: inst,
            hookState: hookState,
            options: options,
          };

          Model.notifyObserversOf(&#x27;persist&#x27;, context, function(err) {
            if (err) return cb(err);

            if (connector.save.length === 4) {
              connector.save(modelName, inst.constructor._forDB(data), options, saveCallback);
            } else {
              connector.save(modelName, inst.constructor._forDB(data), saveCallback);
            }
          });
        }, data, cb);
      }, data, cb);
    }
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.remove(cb);
    } else {
      change.<span class="apidocCodeKeywordSpan">save</span>(cb);
    }
  }
};

/**
 * Get a change&#x27;s current revision based on current data.
 * @callback  {Function} callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.setAttribute" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.setAttribute">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>setAttribute
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setAttribute(name, value) {
  this[name] = value; // TODO [fabien] - currently not protected by applyProperties
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.setAttributes" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.setAttributes">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>setAttributes
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setAttributes(data) {
  if (typeof data !== &#x27;object&#x27;) return;

  this.constructor.applyProperties(data, this);

  var Model = this.constructor;
  var inst = this;

  // update instance&#x27;s properties
  for (var key in data) {
    inst.setAttribute(key, data[key]);
  }

  Model.emit(&#x27;set&#x27;, inst);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!data) {
  return conflict.SourceModel.deleteById(conflict.modelId, done);
}

conflict.models(function(err, source, target) {
  if (err) return done(err);
  var inst = source || new conflict.SourceModel(target);
  inst.<span class="apidocCodeKeywordSpan">setAttributes</span>(data);
  inst.save(function(err) {
    if (err) return done(err);
    conflict.resolve(done);
  });
});

function done(err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.unsetAttribute" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.unsetAttribute">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>unsetAttribute
        <span class="apidocSignatureSpan">(name, nullify)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unsetAttribute(name, nullify) {
  if (nullify || this.constructor.definition.settings.persistUndefinedAsNull) {
    this[name] = this.__data[name] = null;
  } else {
    delete this[name];
    delete this.__data[name];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttribute" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttribute">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>updateAttribute
        <span class="apidocSignatureSpan">(name, value, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAttribute(name, value, options, cb) {
  var data = {};
  data[name] = value;
  return this.updateAttributes(data, options, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttributes" id="apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttributes">
        function <span class="apidocSignatureSpan">loopback.DataSource.DataAccessObject.prototype.</span>updateAttributes
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateAttributes = function (data, options, cb) {
  var self = this;
  var connectionPromise = stillConnecting(this.getDataSource(), this, arguments);
  if (connectionPromise) {
    return connectionPromise;
  }

  if (options === undefined &#x26;&#x26; cb === undefined) {
    if (typeof data === &#x27;function&#x27;) {
      // updateAttributes(cb)
      cb = data;
      data = undefined;
    }
  } else if (cb === undefined) {
    if (typeof options === &#x27;function&#x27;) {
      // updateAttributes(data, cb)
      cb = options;
      options = {};
    }
  }

  cb = cb || utils.createPromiseCallback();
  options = options || {};

  assert((typeof data === &#x27;object&#x27;) &#x26;&#x26; (data !== null),
    &#x27;The data argument must be an object&#x27;);
  assert(typeof options === &#x27;object&#x27;, &#x27;The options argument must be an object&#x27;);
  assert(typeof cb === &#x27;function&#x27;, &#x27;The cb argument must be a function&#x27;);

  var inst = this;
  var Model = this.constructor;
  var connector = inst.getConnector();
  assert(typeof connector.updateAttributes === &#x27;function&#x27;,
    &#x27;updateAttributes() must be implemented by the connector&#x27;);

  if (isPKMissing(Model, cb))
    return cb.promise;

  var allowExtendedOperators = Model._allowExtendedOperators(options);
  var strict = this.__strict;
  var model = Model.modelName;
  var hookState = {};

  // Convert the data to be plain object so that update won&#x27;t be confused
  if (data instanceof Model) {
    data = data.toObject(false);
  }
  data = removeUndefined(data);

  // Make sure id(s) cannot be changed
  var idNames = Model.definition.idNames();
  for (var i = 0, n = idNames.length; i &#x3c; n; i++) {
    var idName = idNames[i];
    if (data[idName] !== undefined &#x26;&#x26; !idEquals(data[idName], inst[idName])) {
      var err = new Error(g.f(&#x27;apidoc.element.loopback.DataSource.DataAccessObject.prototype.updateAttributes cannot be updated from &#x27; +
        &#x27;%s to %s when {{forceId}} is set to true&#x27;,
        inst[idName], data[idName]));
      err.statusCode = 400;
      process.nextTick(function() {
        cb(err);
      });
      return cb.promise;
    }
  }

  var context = {
    Model: Model,
    where: byIdQuery(Model, getIdValue(Model, inst)).where,
    data: data,
    currentInstance: inst,
    hookState: hookState,
    options: options,
  };

  Model.notifyObserversOf(&#x27;before save&#x27;, context, function(err, ctx) {
    if (err) return cb(err);
    data = ctx.data;

    if (strict &#x26;&#x26; !allowExtendedOperators) {
      applyStrictCheck(self.constructor, strict, data, inst, validateAndSave);
    } else {
      validateAndSave(null, data);
    }

    function validateAndSave(err, data) {
      if (err) return cb(err);
      data = removeUndefined(data);
      var doValidate = true;
      if (options.validate === undefined) {
        if (Model.settings.automaticValidation !== undefined) {
          doValidate = Model.settings.automaticValidation;
        }
      } else {
        doValidate = options.validate;
      }

      // update instance&#x27;s properties
      try {
        inst.setAttributes(data);
      } catch (err) {
        return cb(err);
      }

      if (doValidate) {
        inst.isValid(function(valid) {
          if (!valid) {
            cb(new ValidationError(inst), inst);
            return;
          }

          triggerSave();
        }, data, options);
      } else {
        triggerSave();
      }

      function triggerSave() {
        inst.trigger(&#x27;save&#x27;, function(saveDone) {
          inst.trigger(&#x27;update&#x27;, function(done) {
            copyData(data, inst);
            var typedData = convertSubsetOfPropertiesByType(inst, data);
            context.data = typedData;

            function updateAttributesCallback(err) {
              if (err) return cb(err);
              var ctx = {
                Model: Model,
                data: context.data,
                hookState: hookState,
                options: options,
                isNewInstance: false,
              };
              Model.notifyObserversOf(&#x27;loaded&#x27;, ctx, function(err) {
                if (err) return cb(err);

                inst.__persisted = true;

                // By default, the instance passed to updateAttributes callback is NOT updated ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.<span class="apidocCodeKeywordSpan">updateAttributes</span>(data, cb);
  });
};

/**
 * Create a change stream. [See here for more info](http://loopback.io/doc/en/lb2/Realtime-server-sent-events.html)
 *
 * @param {Object} options
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.JSON" id="apidoc.module.loopback.DataSource.JSON">module loopback.DataSource.JSON</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.JSON.JSON" id="apidoc.element.loopback.DataSource.JSON.JSON">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>JSON
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSON(value) {
  if (!(this instanceof JSON)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.JSON.prototype" id="apidoc.module.loopback.DataSource.JSON.prototype">module loopback.DataSource.JSON.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.JSON.prototype.toJSON" id="apidoc.element.loopback.DataSource.JSON.prototype.toJSON">
        function <span class="apidocSignatureSpan">loopback.DataSource.JSON.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err) {
    if (done) done(err);
    return;
  }
  mappings.forEach(function(m) {
    var role;
    if (options.returnOnlyRoleNames === true) {
      role = m.<span class="apidocCodeKeywordSpan">toJSON</span>().role.name;
    } else {
      role = m.roleId;
    }
    addRole(role);
  });
  if (done) done();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.JSON.prototype.toObject" id="apidoc.element.loopback.DataSource.JSON.prototype.toObject">
        function <span class="apidocSignatureSpan">loopback.DataSource.JSON.prototype.</span>toObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.validate = true;
}
if (!(&#x27;throws&#x27; in options)) {
  options.throws = false;
}

var inst = this;
var data = inst.<span class="apidocCodeKeywordSpan">toObject</span>(true);
var id = this.getId();

if (!id) {
  return Model.create(this, callback);
}

// validate first
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.Text" id="apidoc.module.loopback.DataSource.Text">module loopback.DataSource.Text</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.Text.Text" id="apidoc.element.loopback.DataSource.Text.Text">
        function <span class="apidocSignatureSpan">loopback.DataSource.</span>Text
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Text(value) {
  if (!(this instanceof Text)) {
    return value;
  }
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.Text.prototype" id="apidoc.module.loopback.DataSource.Text.prototype">module loopback.DataSource.Text.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.Text.prototype.toJSON" id="apidoc.element.loopback.DataSource.Text.prototype.toJSON">
        function <span class="apidocSignatureSpan">loopback.DataSource.Text.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err) {
    if (done) done(err);
    return;
  }
  mappings.forEach(function(m) {
    var role;
    if (options.returnOnlyRoleNames === true) {
      role = m.<span class="apidocCodeKeywordSpan">toJSON</span>().role.name;
    } else {
      role = m.roleId;
    }
    addRole(role);
  });
  if (done) done();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.Text.prototype.toObject" id="apidoc.element.loopback.DataSource.Text.prototype.toObject">
        function <span class="apidocSignatureSpan">loopback.DataSource.Text.prototype.</span>toObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.validate = true;
}
if (!(&#x27;throws&#x27; in options)) {
  options.throws = false;
}

var inst = this;
var data = inst.<span class="apidocCodeKeywordSpan">toObject</span>(true);
var id = this.getId();

if (!id) {
  return Model.create(this, callback);
}

// validate first
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.DataSource.prototype" id="apidoc.module.loopback.DataSource.prototype">module loopback.DataSource.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype._setupConnector" id="apidoc.element.loopback.DataSource.prototype._setupConnector">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>_setupConnector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setupConnector = function () {
  this.connector = this.connector || this.adapter; // The legacy JugglingDB adapter will set up `adapter` property
  this.adapter = this.connector; // Keep the adapter as an alias to connector
  if (this.connector) {
    if (!this.connector.dataSource) {
      // Set up the dataSource if the connector doesn&#x27;t do so
      this.connector.dataSource = this;
    }
    var dataSource = this;
    this.connector.log = function(query, start) {
      dataSource.log(query, start);
    };

    this.connector.logger = function(query) {
      var t1 = Date.now();
      var log = this.log;
      return function(q) {
        log(q || query, t1);
      };
    };
    // Configure the connector instance to mix in observer functions
    jutil.mixin(this.connector, OberserverMixin);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.attach" id="apidoc.element.loopback.DataSource.prototype.attach">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>attach
        <span class="apidocSignatureSpan">(modelClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attach = function (modelClass) {
  if (modelClass.dataSource === this) {
    // Already attached to the data source
    return modelClass;
  }

  if (modelClass.modelBuilder !== this.modelBuilder) {
    this.modelBuilder.definitions[modelClass.modelName] = modelClass.definition;
    this.modelBuilder.models[modelClass.modelName] = modelClass;
    // reset the modelBuilder
    modelClass.modelBuilder = this.modelBuilder;
  }

  // redefine the dataSource
  modelClass.dataSource = this;

  this.setupDataAccess(modelClass, modelClass.settings);
  modelClass.emit(&#x27;dataSourceAttached&#x27;, modelClass);
  return modelClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.automigrate" id="apidoc.element.loopback.DataSource.prototype.automigrate">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>automigrate
        <span class="apidocSignatureSpan">(models, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">automigrate = function (models, cb) {
  this.freeze();

  if ((!cb) &#x26;&#x26; (&#x27;function&#x27; === typeof models)) {
    cb = models;
    models = undefined;
  }

  cb = cb || utils.createPromiseCallback();

  if (!this.connector.automigrate) {
    // NOOP
    process.nextTick(cb);
    return cb.promise;
  }

  // First argument is a model name
  if (&#x27;string&#x27; === typeof models) {
    models = [models];
  }

  var attachedModels = this.connector._models;

  if (attachedModels &#x26;&#x26; typeof attachedModels === &#x27;object&#x27;) {
    models = models || Object.keys(attachedModels);

    if (models.length === 0) {
      process.nextTick(cb);
      return cb.promise;
    }

    var invalidModels = models.filter(function(m) {
      return !(m in attachedModels);
    });

    if (invalidModels.length) {
      process.nextTick(function() {
        cb(new Error(g.f(&#x27;Cannot migrate models not attached to this datasource: %s&#x27;,
          invalidModels.join(&#x27; &#x27;))));
      });
      return cb.promise;
    }
  }

  this.connector.automigrate(models, cb);
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.autoupdate" id="apidoc.element.loopback.DataSource.prototype.autoupdate">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>autoupdate
        <span class="apidocSignatureSpan">(models, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoupdate = function (models, cb) {
  this.freeze();

  if ((!cb) &#x26;&#x26; (&#x27;function&#x27; === typeof models)) {
    cb = models;
    models = undefined;
  }

  cb = cb || utils.createPromiseCallback();

  if (!this.connector.autoupdate) {
    // NOOP
    process.nextTick(cb);
    return cb.promise;
  }

  // First argument is a model name
  if (&#x27;string&#x27; === typeof models) {
    models = [models];
  }

  var attachedModels = this.connector._models;

  if (attachedModels &#x26;&#x26; typeof attachedModels === &#x27;object&#x27;) {
    models = models || Object.keys(attachedModels);

    if (models.length === 0) {
      process.nextTick(cb);
      return cb.promise;
    }

    var invalidModels = models.filter(function(m) {
      return !(m in attachedModels);
    });

    if (invalidModels.length) {
      process.nextTick(function() {
        cb(new Error(g.f(&#x27;Cannot migrate models not attached to this datasource: %s&#x27;,
        invalidModels.join(&#x27; &#x27;))));
      });
      return cb.promise;
    }
  }

  this.connector.autoupdate(models, cb);
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.buildModelFromInstance" id="apidoc.element.loopback.DataSource.prototype.buildModelFromInstance">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>buildModelFromInstance
        <span class="apidocSignatureSpan">(name, json, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildModelFromInstance = function (name, json, options) {
  // Introspect the JSON document to generate a schema
  var schema = ModelBuilder.introspect(json);

  // Create a model for the generated schema
  return this.createModel(name, schema, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.columnMetadata" id="apidoc.element.loopback.DataSource.prototype.columnMetadata">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>columnMetadata
        <span class="apidocSignatureSpan">(modelName, propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">columnMetadata = function (modelName, propertyName) {
  return this.getModelDefinition(modelName).columnMetadata(this.connector.name, propertyName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.columnName" id="apidoc.element.loopback.DataSource.prototype.columnName">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>columnName
        <span class="apidocSignatureSpan">(modelName, propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">columnName = function (modelName, propertyName) {
  return this.getModelDefinition(modelName).columnName(this.connector.name, propertyName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.columnNames" id="apidoc.element.loopback.DataSource.prototype.columnNames">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>columnNames
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">columnNames = function (modelName) {
  return this.getModelDefinition(modelName).columnNames(this.connector.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.connect" id="apidoc.element.loopback.DataSource.prototype.connect">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>connect
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (callback) {
  callback = callback || utils.createPromiseCallback();
  var self = this;
  if (this.connected) {
    // The data source is already connected, return immediately
    process.nextTick(callback);
    return callback.promise;
  }
  if (typeof this.connector.connect !== &#x27;function&#x27;) {
    // Connector doesn&#x27;t have the connect function
    // Assume no connect is needed
    self.connected = true;
    self.connecting = false;
    process.nextTick(function() {
      self.emit(&#x27;connected&#x27;);
      callback();
    });
    return callback.promise;
  }

  // Queue the callback
  this.pendingConnectCallbacks = this.pendingConnectCallbacks || [];
  this.pendingConnectCallbacks.push(callback);

  // The connect is already in progress
  if (this.connecting) return callback.promise;
  // Set connecting flag to be true
  this.connecting = true;
  this.connector.connect(function(err, result) {
    self.connecting = false;
    if (!err) self.connected = true;
    var cbs = self.pendingConnectCallbacks;
    self.pendingConnectCallbacks = [];
    if (!err) {
      self.emit(&#x27;connected&#x27;);
    } else {
      self.emit(&#x27;error&#x27;, err);
    }
    // Invoke all pending callbacks
    async.each(cbs, function(cb, done) {
      try {
        cb(err);
      } catch (e) {
        // Ignore error to make sure all callbacks are invoked
        debug(&#x27;Uncaught error raised by connect callback function: &#x27;, e);
      } finally {
        done();
      }
    }, function(err) {
      if (err) throw err; // It should not happen
    });
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.copyModel" id="apidoc.element.loopback.DataSource.prototype.copyModel">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>copyModel
        <span class="apidocSignatureSpan">(Master)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyModel(Master) {
  var dataSource = this;
  var className = Master.modelName;
  var md = Master.modelBuilder.getModelDefinition(className);
  var Slave = function SlaveModel() {
    Master.apply(this, [].slice.call(arguments));
  };

  util.inherits(Slave, Master);

  // Delegating static properties
  Slave.__proto__ = Master;

  hiddenProperty(Slave, &#x27;dataSource&#x27;, dataSource);
  hiddenProperty(Slave, &#x27;modelName&#x27;, className);
  hiddenProperty(Slave, &#x27;relations&#x27;, Master.relations);

  if (!(className in dataSource.modelBuilder.models)) {
    // store class in model pool
    dataSource.modelBuilder.models[className] = Slave;
    dataSource.modelBuilder.definitions[className] =
      new ModelDefinition(dataSource.modelBuilder, md.name, md.properties, md.settings);

    if ((!dataSource.isTransaction) &#x26;&#x26; dataSource.connector &#x26;&#x26; dataSource.connector.define) {
      dataSource.connector.define({
        model: Slave,
        properties: md.properties,
        settings: md.settings,
      });
    }
  }

  return Slave;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.createModel" id="apidoc.element.loopback.DataSource.prototype.createModel">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>createModel
        <span class="apidocSignatureSpan">(className, properties, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineClass(className, properties, settings) {
  var args = slice.call(arguments);

  if (!className) {
    throw new Error(g.f(&#x27;Class name required&#x27;));
  }
  if (args.length === 1) {
    properties = {};
    args.push(properties);
  }
  if (args.length === 2) {
    settings = {};
    args.push(settings);
  }

  properties = properties || {};
  settings = settings || {};

  if (this.isRelational()) {
    // Set the strict mode to be true for relational DBs by default
    if (settings.strict === undefined || settings.strict === null) {
      settings.strict = true;
    }
    if (settings.strict === false) {
      settings.strict = &#x27;throw&#x27;;
    }
  }

  var modelClass = this.modelBuilder.define(className, properties, settings);
  modelClass.dataSource = this;

  if (settings.unresolved) {
    return modelClass;
  }

  this.setupDataAccess(modelClass, settings);
  modelClass.emit(&#x27;dataSourceAttached&#x27;, modelClass);

  return modelClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

app.model = function(Model, config) {
var isPublic = true;
var registry = this.registry;

if (typeof Model === &#x27;string&#x27;) {
  var msg = &#x27;app.model(modelName, settings) is no longer supported. &#x27; +
    &#x27;Use app.registry.<span class="apidocCodeKeywordSpan">createModel</span>(modelName, definition) and &#x27; +
    &#x27;app.model(ModelCtor, config) instead.&#x27;;
  throw new Error(msg);
}

if (arguments.length &#x3e; 1) {
  config = config || {};
  configureModel(Model, config, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.define" id="apidoc.element.loopback.DataSource.prototype.define">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>define
        <span class="apidocSignatureSpan">(className, properties, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineClass(className, properties, settings) {
  var args = slice.call(arguments);

  if (!className) {
    throw new Error(g.f(&#x27;Class name required&#x27;));
  }
  if (args.length === 1) {
    properties = {};
    args.push(properties);
  }
  if (args.length === 2) {
    settings = {};
    args.push(settings);
  }

  properties = properties || {};
  settings = settings || {};

  if (this.isRelational()) {
    // Set the strict mode to be true for relational DBs by default
    if (settings.strict === undefined || settings.strict === null) {
      settings.strict = true;
    }
    if (settings.strict === false) {
      settings.strict = &#x27;throw&#x27;;
    }
  }

  var modelClass = this.modelBuilder.define(className, properties, settings);
  modelClass.dataSource = this;

  if (settings.unresolved) {
    return modelClass;
  }

  this.setupDataAccess(modelClass, settings);
  modelClass.emit(&#x27;dataSourceAttached&#x27;, modelClass);

  return modelClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @property {DataSource} Model.dataSource Data source to which the model is connected, if any. Static property.
 * @property {SharedClass} Model.sharedMethod The `strong-remoting` [SharedClass](http://apidocs.strongloop.com/strong-remoting/#
sharedclass) that contains remoting (and http) metadata. Static property.
 * @property {Object} settings Contains additional model settings.
 * @property {string} settings.http.path Base URL of the model HTTP route.
 * @property [{string}] settings.acls Array of ACLs for the model.
 * @class
 */
var Model = registry.modelBuilder.<span class="apidocCodeKeywordSpan">define</span>(&#x27;Model&#x27;);

Model.registry = registry;

/**
 * The `loopback.Model.extend()` method calls this when you create a model that extends another model.
 * Add any setup or configuration code you want executed when the model is created.
 * See  [Setting up a custom model](http://loopback.io/doc/en/lb2/Extending-built-in-models.html#setting-up-a-custom-model).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.defineForeignKey" id="apidoc.element.loopback.DataSource.prototype.defineForeignKey">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineForeignKey
        <span class="apidocSignatureSpan">(className, key, foreignClassName, pkName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineForeignKey(className, key, foreignClassName, pkName) {
  var pkType = null;
  var foreignModel = this.getModelDefinition(foreignClassName);
  pkName = pkName || foreignModel &#x26;&#x26; foreignModel.idName();
  if (pkName) {
    pkType = foreignModel.properties[pkName].type;
  }
  var model = this.getModelDefinition(className);
  if (model.properties[key]) {
    if (pkType) {
      // Reset the type of the foreign key
      model.rawProperties[key].type = model.properties[key].type = pkType;
    }
    return;
  }

  var fkDef = {type: pkType};
  var foreignMeta = this.columnMetadata(foreignClassName, pkName);
  if (foreignMeta &#x26;&#x26; (foreignMeta.dataType || foreignMeta.dataLength)) {
    fkDef[this.connector.name] = {};
    if (foreignMeta.dataType) {
      fkDef[this.connector.name].dataType = foreignMeta.dataType;
    }
    if (foreignMeta.dataLength) {
      fkDef[this.connector.name].dataLength = foreignMeta.dataLength;
    }
  }
  if (this.connector.defineForeignKey) {
    var cb = function(err, keyType) {
      if (err) throw err;
      fkDef.type = keyType || pkType;
      // Add the foreign key property to the data source _models
      this.defineProperty(className, key, fkDef);
    }.bind(this);
    switch (this.connector.defineForeignKey.length) {
      case 4:
        this.connector.defineForeignKey(className, key, foreignClassName, cb);
        break;
      default:
      case 3:
        this.connector.defineForeignKey(className, key, cb);
        break;
    }
  } else {
    // Add the foreign key property to the data source _models
    this.defineProperty(className, key, fkDef);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.defineOperation" id="apidoc.element.loopback.DataSource.prototype.defineOperation">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineOperation
        <span class="apidocSignatureSpan">(name, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineOperation = function (name, options, fn) {
  options.fn = fn;
  options.name = name;
  this._operations[name] = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.defineProperty" id="apidoc.element.loopback.DataSource.prototype.defineProperty">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineProperty
        <span class="apidocSignatureSpan">(model, prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (model, prop, params) {
  this.modelBuilder.defineProperty(model, prop, params);

  var resolvedProp = this.getModelDefinition(model).properties[prop];
  if (this.connector &#x26;&#x26; this.connector.defineProperty) {
    this.connector.defineProperty(model, prop, resolvedProp);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.defineRelations" id="apidoc.element.loopback.DataSource.prototype.defineRelations">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineRelations
        <span class="apidocSignatureSpan">(modelClass, relations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRelations = function (modelClass, relations) {
  var self = this;

  // Create a function for the closure in the loop
  var createListener = function(name, relation, targetModel, throughModel) {
    if (!isModelDataSourceAttached(targetModel)) {
      targetModel.once(&#x27;dataAccessConfigured&#x27;, function(model) {
        // Check if the through model doesn&#x27;t exist or resolved
        if (!throughModel || isModelDataSourceAttached(throughModel)) {
          // The target model is resolved
          var params = traverse(relation).clone();
          params.as = name;
          params.model = model;
          if (throughModel) {
            params.through = throughModel;
          }
          modelClass[relation.type].call(modelClass, name, params);
        }
      });
    }

    if (throughModel &#x26;&#x26; !isModelDataSourceAttached(throughModel)) {
      // Set up a listener to the through model
      throughModel.once(&#x27;dataAccessConfigured&#x27;, function(model) {
        if (isModelDataSourceAttached(targetModel)) {
          // The target model is resolved
          var params = traverse(relation).clone();
          params.as = name;
          params.model = targetModel;
          params.through = model;
          modelClass[relation.type].call(modelClass, name, params);
        }
      });
    }
  };

  // Set up the relations
  if (relations) {
    Object.keys(relations).forEach(function(rn) {
      var r = relations[rn];
      assert(DataSource.relationTypes.indexOf(r.type) !== -1, &#x27;Invalid relation type: &#x27; + r.type);
      assert(isValidRelationName(rn), &#x27;Invalid relation name: &#x27; + rn);

      var targetModel, polymorphicName;

      if (r.polymorphic &#x26;&#x26; r.type !== &#x27;belongsTo&#x27; &#x26;&#x26; !r.model) {
        throw new Error(g.f(&#x27;No model specified for {{polymorphic}} %s: %s&#x27;, r.type, rn));
      }

      if (r.polymorphic) {
        polymorphicName = typeof r.model === &#x27;string&#x27; ? r.model : rn;
        if (typeof r.polymorphic === &#x27;string&#x27;) {
          polymorphicName = r.polymorphic;
        } else if (typeof r.polymorphic === &#x27;object&#x27; &#x26;&#x26; typeof r.polymorphic.as === &#x27;string&#x27;) {
          polymorphicName = r.polymorphic.as;
        }
      }

      if (r.model) {
        targetModel = isModelClass(r.model) ? r.model : self.getModel(r.model, true);
      }

      var throughModel = null;
      if (r.through) {
        throughModel = isModelClass(r.through) ? r.through : self.getModel(r.through, true);
      }

      if ((targetModel &#x26;&#x26; !isModelDataSourceAttached(targetModel)) ||
          (throughModel &#x26;&#x26; !isModelDataSourceAttached(throughModel))) {
        // Create a listener to defer the relation set up
        createListener(rn, r, targetModel, throughModel);
      } else {
        // The target model is resolved
        var params = traverse(r).clone();
        params.as = rn;
        params.model = polymorphicName || targetModel;
        if (throughModel) {
          params.through = throughModel;
        }
        modelClass[r.type].call(modelClass, rn, params);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.defineScopes" id="apidoc.element.loopback.DataSource.prototype.defineScopes">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>defineScopes
        <span class="apidocSignatureSpan">(modelClass, scopes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineScopes = function (modelClass, scopes) {
  if (scopes) {
    for (var s in scopes) {
      defineScope(modelClass, modelClass, s, scopes[s], {}, scopes[s].options);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.disableRemote" id="apidoc.element.loopback.DataSource.prototype.disableRemote">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>disableRemote
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemote = function (operation) {
  var op = this.getOperation(operation);
  if (op) {
    op.remoteEnabled = false;
  } else {
    throw new Error(g.f(&#x27;%s is not provided by the attached connector&#x27;, operation));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.disconnect" id="apidoc.element.loopback.DataSource.prototype.disconnect">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disconnect(cb) {
  var self = this;
  if (this.connected &#x26;&#x26; (typeof this.connector.disconnect === &#x27;function&#x27;)) {
    this.connector.disconnect(function(err, result) {
      self.connected = false;
      cb &#x26;&#x26; cb(err, result);
    });
  } else {
    process.nextTick(function() {
      self.connected = false;
      cb &#x26;&#x26; cb();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverAndBuildModels" id="apidoc.element.loopback.DataSource.prototype.discoverAndBuildModels">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverAndBuildModels
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverAndBuildModels = function (modelName, options, cb) {
  var self = this;
  options = options || {};
  this.discoverSchemas(modelName, options, function(err, schemas) {
    if (err) {
      cb &#x26;&#x26; cb(err, schemas);
      return;
    }

    var schemaList = [];
    for (var s in schemas) {
      var schema = schemas[s];
      if (options.base) {
        schema.options = schema.options || {};
        schema.options.base = options.base;
      }
      schemaList.push(schema);
    }

    var models = self.modelBuilder.buildModels(schemaList,
      self.createModel.bind(self));

    cb &#x26;&#x26; cb(err, models);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverAndBuildModelsSync" id="apidoc.element.loopback.DataSource.prototype.discoverAndBuildModelsSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverAndBuildModelsSync
        <span class="apidocSignatureSpan">(modelName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverAndBuildModelsSync = function (modelName, options) {
  options = options || {};
  var schemas = this.discoverSchemasSync(modelName, options);

  var schemaList = [];
  for (var s in schemas) {
    var schema = schemas[s];
    if (options.base) {
      schema.options = schema.options || {};
      schema.options.base = options.base;
    }
    schemaList.push(schema);
  }

  var models = this.modelBuilder.buildModels(schemaList,
    this.createModel.bind(this));

  return models;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverExportedForeignKeys" id="apidoc.element.loopback.DataSource.prototype.discoverExportedForeignKeys">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverExportedForeignKeys
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverExportedForeignKeys = function (modelName, options, cb) {
  this.freeze();

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  if (this.connector.discoverExportedForeignKeys) {
    this.connector.discoverExportedForeignKeys(modelName, options, cb);
  } else if (cb) {
    process.nextTick(cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverExportedForeignKeysSync" id="apidoc.element.loopback.DataSource.prototype.discoverExportedForeignKeysSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverExportedForeignKeysSync
        <span class="apidocSignatureSpan">(modelName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverExportedForeignKeysSync = function (modelName, options) {
  this.freeze();
  if (this.connector.discoverExportedForeignKeysSync) {
    return this.connector.discoverExportedForeignKeysSync(modelName, options);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverForeignKeys" id="apidoc.element.loopback.DataSource.prototype.discoverForeignKeys">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverForeignKeys
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverForeignKeys = function (modelName, options, cb) {
  this.freeze();

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  if (this.connector.discoverForeignKeys) {
    this.connector.discoverForeignKeys(modelName, options, cb);
  } else if (cb) {
    process.nextTick(cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverForeignKeysSync" id="apidoc.element.loopback.DataSource.prototype.discoverForeignKeysSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverForeignKeysSync
        <span class="apidocSignatureSpan">(modelName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverForeignKeysSync = function (modelName, options) {
  this.freeze();
  if (this.connector.discoverForeignKeysSync) {
    return this.connector.discoverForeignKeysSync(modelName, options);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverModelDefinitions" id="apidoc.element.loopback.DataSource.prototype.discoverModelDefinitions">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelDefinitions
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverModelDefinitions = function (options, cb) {
  this.freeze();

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  if (this.connector.discoverModelDefinitions) {
    this.connector.discoverModelDefinitions(options, cb);
  } else if (cb) {
    process.nextTick(cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverModelDefinitionsSync" id="apidoc.element.loopback.DataSource.prototype.discoverModelDefinitionsSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelDefinitionsSync
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverModelDefinitionsSync = function (options) {
  this.freeze();
  if (this.connector.discoverModelDefinitionsSync) {
    return this.connector.discoverModelDefinitionsSync(options);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverModelProperties" id="apidoc.element.loopback.DataSource.prototype.discoverModelProperties">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelProperties
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverModelProperties = function (modelName, options, cb) {
  this.freeze();

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  if (this.connector.discoverModelProperties) {
    this.connector.discoverModelProperties(modelName, options, cb);
  } else if (cb) {
    process.nextTick(cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverModelPropertiesSync" id="apidoc.element.loopback.DataSource.prototype.discoverModelPropertiesSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverModelPropertiesSync
        <span class="apidocSignatureSpan">(modelName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverModelPropertiesSync = function (modelName, options) {
  this.freeze();
  if (this.connector.discoverModelPropertiesSync) {
    return this.connector.discoverModelPropertiesSync(modelName, options);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverPrimaryKeys" id="apidoc.element.loopback.DataSource.prototype.discoverPrimaryKeys">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverPrimaryKeys
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverPrimaryKeys = function (modelName, options, cb) {
  this.freeze();

  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }
  options = options || {};
  cb = cb || utils.createPromiseCallback();

  if (this.connector.discoverPrimaryKeys) {
    this.connector.discoverPrimaryKeys(modelName, options, cb);
  } else if (cb) {
    process.nextTick(cb);
  }
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverPrimaryKeysSync" id="apidoc.element.loopback.DataSource.prototype.discoverPrimaryKeysSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverPrimaryKeysSync
        <span class="apidocSignatureSpan">(modelName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverPrimaryKeysSync = function (modelName, options) {
  this.freeze();
  if (this.connector.discoverPrimaryKeysSync) {
    return this.connector.discoverPrimaryKeysSync(modelName, options);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverSchema" id="apidoc.element.loopback.DataSource.prototype.discoverSchema">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverSchema
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverSchema = function (modelName, options, cb) {
  options = options || {};

  if (!cb &#x26;&#x26; &#x27;function&#x27; === typeof options) {
    cb = options;
    options = {};
  }
  options.visited = {};
  options.relations = false;

  cb = cb || utils.createPromiseCallback();

  this.discoverSchemas(modelName, options, function(err, schemas) {
    if (err || !schemas) {
      cb &#x26;&#x26; cb(err, schemas);
      return;
    }
    for (var s in schemas) {
      cb &#x26;&#x26; cb(null, schemas[s]);
      return;
    }
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverSchemas" id="apidoc.element.loopback.DataSource.prototype.discoverSchemas">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverSchemas
        <span class="apidocSignatureSpan">(modelName, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverSchemas = function (modelName, options, cb) {
  options = options || {};

  if (!cb &#x26;&#x26; &#x27;function&#x27; === typeof options) {
    cb = options;
    options = {};
  }

  cb = cb || utils.createPromiseCallback();

  var self = this;
  var dbType = this.connector.name || this.name;

  var nameMapper;
  if (options.nameMapper === null) {
    // No mapping
    nameMapper = function(type, name) {
      return name;
    };
  } else if (typeof options.nameMapper === &#x27;function&#x27;) {
    // Custom name mapper
    nameMapper = options.nameMapper;
  } else {
    // Default name mapper
    nameMapper = function mapName(type, name) {
      if (type === &#x27;table&#x27; || type === &#x27;model&#x27;) {
        return fromDBName(name, false);
      } else if (type == &#x27;fk&#x27;) {
        return fromDBName(name + &#x27;Rel&#x27;, true);
      } else {
        return fromDBName(name, true);
      }
    };
  }

  if (this.connector.discoverSchemas) {
    // Delegate to the connector implementation
    this.connector.discoverSchemas(modelName, options, cb);
    return cb.promise;
  }

  var tasks = [
    this.discoverModelProperties.bind(this, modelName, options),
    this.discoverPrimaryKeys.bind(this, modelName, options)];

  var followingRelations = options.associations || options.relations;
  if (followingRelations) {
    tasks.push(this.discoverForeignKeys.bind(this, modelName, options));
  }

  async.parallel(tasks, function(err, results) {
    if (err) {
      cb(err);
      return cb.promise;
    }

    var columns = results[0];
    if (!columns || columns.length === 0) {
      cb(new Error(g.f(&#x27;Table \&#x27;%s\&#x27; does not exist.&#x27;, modelName)));
      return cb.promise;
    }

    // Handle primary keys
    var primaryKeys = results[1] || [];
    var pks = {};
    primaryKeys.forEach(function(pk) {
      pks[pk.columnName] = pk.keySeq;
    });

    if (self.settings.debug) {
      debug(&#x27;Primary keys: &#x27;, pks);
    }

    var schema = {
      name: nameMapper(&#x27;table&#x27;, modelName),
      options: {
        idInjection: false, // DO NOT add id property
      },
      properties: {},
    };

    schema.options[dbType] = {
      schema: columns[0].owner,
      table: modelName,
    };

    columns.forEach(function(item) {
      var propName = nameMapper(&#x27;column&#x27;, item.columnName);
      schema.properties[propName] = {
        type: item.type,
        required: (item.nullable === &#x27;N&#x27; || item.nullable === &#x27;NO&#x27; ||
          item.nullable === 0 || item.nullable === false),
        length: item.dataLength,
        precision: item.dataPrecision,
        scale: item.dataScale,
      };

      if (pks[item.columnName]) {
        schema.properties[propName].id = pks[item.columnName];
      }
      var dbSpecific = schema.properties[propName][dbType] = {
        columnName: item.columnName,
        dataType: item.dataType,
        dataLength: item.dataLength,
        dataPrecision: item.dataPrecision,
        dataScale: item.dataScale,
        nullable: item.nullable,
      };
      // merge connector-specific properties
      if (item[dbType]) {
        for (var k in item[dbType]) {
          dbSpecific[k] = item[dbType][k];
        }
      }
    });

    // Add current modelName to the visited tables
    options.visited = options.visited || {};
    var schemaKey = columns[0].owner + &#x27;.&#x27; + modelName;
    if (!options.visited.hasOwnProperty(schemaKey)) {
      if (self.settings.debug) {
        debug(&#x27;Adding schema for &#x27; + schemaKey);
      }
      options.visited[schemaKey] = schema;
    }

    var otherTables = {};
    if (followingRelations) {
      // Handle foreign keys
      var fks = {};
      var foreignKeys = results[2] || [];
      foreignKeys.forEach(function(fk) {
        var fkInfo = {
          keySeq: fk.keySeq,
          owner: fk.pkOwner,
          tableName: fk.pkTableName,
          columnName: fk.pkColumnName,
        };
        if (fks[fk.fkName]) {
          fks[fk.fkName].push(fkInfo);
        } else {
          fks[fk.fkName] = [fkInfo];
        }
      });

      if (self.settings.debug) {
        debug(&#x27;Foreign keys: &#x27;, fks);
      }

      schema.options.relations = {};
      fo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.discoverSchemasSync" id="apidoc.element.loopback.DataSource.prototype.discoverSchemasSync">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>discoverSchemasSync
        <span class="apidocSignatureSpan">(modelName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discoverSchemasSync = function (modelName, options) {
  var self = this;
  var dbType = this.name || this.connector.name;

  var columns = this.discoverModelPropertiesSync(modelName, options);
  if (!columns || columns.length === 0) {
    return [];
  }

  var nameMapper = options.nameMapper || function mapName(type, name) {
    if (type === &#x27;table&#x27; || type === &#x27;model&#x27;) {
      return fromDBName(name, false);
    } else {
      return fromDBName(name, true);
    }
  };

  // Handle primary keys
  var primaryKeys = this.discoverPrimaryKeysSync(modelName, options);
  var pks = {};
  primaryKeys.forEach(function(pk) {
    pks[pk.columnName] = pk.keySeq;
  });

  if (self.settings.debug) {
    debug(&#x27;Primary keys: &#x27;, pks);
  }

  var schema = {
    name: nameMapper(&#x27;table&#x27;, modelName),
    options: {
      idInjection: false, // DO NOT add id property
    },
    properties: {},
  };

  schema.options[dbType] = {
    schema: columns.length &#x3e; 0 &#x26;&#x26; columns[0].owner,
    table: modelName,
  };

  columns.forEach(function(item) {
    var i = item;

    var propName = nameMapper(&#x27;column&#x27;, item.columnName);
    schema.properties[propName] = {
      type: item.type,
      required: (item.nullable === &#x27;N&#x27;),
      length: item.dataLength,
      precision: item.dataPrecision,
      scale: item.dataScale,
    };

    if (pks[item.columnName]) {
      schema.properties[propName].id = pks[item.columnName];
    }
    schema.properties[propName][dbType] = {
      columnName: i.columnName,
      dataType: i.dataType,
      dataLength: i.dataLength,
      dataPrecision: item.dataPrecision,
      dataScale: item.dataScale,
      nullable: i.nullable,
    };
  });

  // Add current modelName to the visited tables
  options.visited = options.visited || {};
  var schemaKey = columns[0].owner + &#x27;.&#x27; + modelName;
  if (!options.visited.hasOwnProperty(schemaKey)) {
    if (self.settings.debug) {
      debug(&#x27;Adding schema for &#x27; + schemaKey);
    }
    options.visited[schemaKey] = schema;
  }

  var otherTables = {};
  var followingRelations = options.associations || options.relations;
  if (followingRelations) {
    // Handle foreign keys
    var fks = {};
    var foreignKeys = this.discoverForeignKeysSync(modelName, options);
    foreignKeys.forEach(function(fk) {
      var fkInfo = {
        keySeq: fk.keySeq,
        owner: fk.pkOwner,
        tableName: fk.pkTableName,
        columnName: fk.pkColumnName,
      };
      if (fks[fk.fkName]) {
        fks[fk.fkName].push(fkInfo);
      } else {
        fks[fk.fkName] = [fkInfo];
      }
    });

    if (self.settings.debug) {
      debug(&#x27;Foreign keys: &#x27;, fks);
    }

    schema.options.relations = {};
    foreignKeys.forEach(function(fk) {
      var propName = nameMapper(&#x27;column&#x27;, fk.pkTableName);
      schema.options.relations[propName] = {
        model: nameMapper(&#x27;table&#x27;, fk.pkTableName),
        type: &#x27;belongsTo&#x27;,
        foreignKey: nameMapper(&#x27;column&#x27;, fk.fkColumnName),
      };

      var key = fk.pkOwner + &#x27;.&#x27; + fk.pkTableName;
      if (!options.visited.hasOwnProperty(key) &#x26;&#x26; !otherTables.hasOwnProperty(key)) {
        otherTables[key] = {owner: fk.pkOwner, tableName: fk.pkTableName};
      }
    });
  }

  if (Object.keys(otherTables).length === 0) {
    return options.visited;
  } else {
    var moreTasks = [];
    for (var t in otherTables) {
      if (self.settings.debug) {
        debug(&#x27;Discovering related schema for &#x27; + schemaKey);
      }
      var newOptions = {};
      for (var key in options) {
        newOptions[key] = options[key];
      }
      newOptions.owner = otherTables[t].owner;
      self.discoverSchemasSync(otherTables[t].tableName, newOptions);
    }
    return options.visited;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.enableRemote" id="apidoc.element.loopback.DataSource.prototype.enableRemote">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>enableRemote
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableRemote = function (operation) {
  var op = this.getOperation(operation);
  if (op) {
    op.remoteEnabled = true;
  } else {
    throw new Error(g.f(&#x27;%s is not provided by the attached connector&#x27;, operation));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.freeze" id="apidoc.element.loopback.DataSource.prototype.freeze">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>freeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function freeze() {
  if (!this.connector) {
    throw new Error(g.f(&#x27;The connector has not been initialized.&#x27;));
  }
  if (this.connector.freezeDataSource) {
    this.connector.freezeDataSource();
  }
  if (this.connector.freezeSchema) {
    this.connector.freezeSchema();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.getModel" id="apidoc.element.loopback.DataSource.prototype.getModel">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getModel
        <span class="apidocSignatureSpan">(name, forceCreate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModel = function (name, forceCreate) {
  return this.modelBuilder.getModel(name, forceCreate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = context || {};

assert(context.registry,
  &#x27;Application registry is mandatory in AccessContext but missing in provided context&#x27;);
this.registry = context.registry;
this.principals = context.principals || [];
var model = context.model;
model = (&#x27;string&#x27; === typeof model) ? this.registry.<span class="apidocCodeKeywordSpan">getModel</span>(model) : model
;
this.model = model;
this.modelName = model &#x26;&#x26; model.modelName;

this.modelId = context.id || context.modelId;
this.property = context.property || AccessContext.ALL;

this.method = context.method;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.getModelDefinition" id="apidoc.element.loopback.DataSource.prototype.getModelDefinition">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getModelDefinition
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModelDefinition = function (name) {
  return this.modelBuilder.getModelDefinition(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.getOperation" id="apidoc.element.loopback.DataSource.prototype.getOperation">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getOperation
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOperation = function (operation) {
  var ops = this.operations();
  var opKeys = Object.keys(ops);

  for (var i = 0; i &#x3c; opKeys.length; i++) {
    var op = ops[opKeys[i]];

    if (op.name === operation) {
      return op;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.getTypes" id="apidoc.element.loopback.DataSource.prototype.getTypes">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>getTypes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTypes = function () {
  var getTypes = this.connector &#x26;&#x26; this.connector.getTypes;
  var types = getTypes &#x26;&#x26; getTypes() || [];
  if (typeof types === &#x27;string&#x27;) {
    types = types.split(/[\s,\/]+/);
  }
  return types;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var ds = new DataSource(name, options, self.modelBuilder);
ds.createModel = function(name, properties, settings) {
  settings = settings || {};
  var BaseModel = settings.base || settings.super;
  if (!BaseModel) {
    // Check the connector types
    var connectorTypes = ds.<span class="apidocCodeKeywordSpan">getTypes</span>();
    if (Array.isArray(connectorTypes) &#x26;&#x26; connectorTypes.indexOf(&#x27;db&#x27;) !== -1) {
      // Only set up the base model to PersistedModel if the connector is DB
      BaseModel = self.PersistedModel;
    } else {
      BaseModel = self.Model;
    }
    settings.base = BaseModel;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.idColumnName" id="apidoc.element.loopback.DataSource.prototype.idColumnName">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idColumnName
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idColumnName = function (modelName) {
  return this.getModelDefinition(modelName).idColumnName(this.connector.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.idName" id="apidoc.element.loopback.DataSource.prototype.idName">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idName
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idName = function (modelName) {
  if (!this.getModelDefinition(modelName).idName) {
    g.error(&#x27;No apidoc.element.loopback.DataSource.prototype.idName name %s&#x27;, this.getModelDefinition(modelName));
  }
  return this.getModelDefinition(modelName).idName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

PersistedModel.getIdName = function() {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.<span class="apidocCodeKeywordSpan">idName</span>(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
};

PersistedModel.setupRemoting = function() {
  var PersistedModel = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.idNames" id="apidoc.element.loopback.DataSource.prototype.idNames">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idNames
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idNames = function (modelName) {
  return this.getModelDefinition(modelName).idNames();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.idProperty" id="apidoc.element.loopback.DataSource.prototype.idProperty">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>idProperty
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idProperty = function (modelName) {
  var def = this.getModelDefinition(modelName);
  var idProps = def &#x26;&#x26; def.ids();
  return idProps &#x26;&#x26; idProps[0] &#x26;&#x26; idProps[0].property;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.isActual" id="apidoc.element.loopback.DataSource.prototype.isActual">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>isActual
        <span class="apidocSignatureSpan">(models, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isActual = function (models, cb) {
  this.freeze();
  if (this.connector.isActual) {
    this.connector.isActual(models, cb);
  } else {
    if ((!cb) &#x26;&#x26; (&#x27;function&#x27; === typeof models)) {
      cb = models;
      models = undefined;
    }
    if (cb) {
      process.nextTick(function() {
        cb(null, true);
      });
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.isRelational" id="apidoc.element.loopback.DataSource.prototype.isRelational">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>isRelational
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelational = function () {
  return this.connector &#x26;&#x26; this.connector.relational;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.log" id="apidoc.element.loopback.DataSource.prototype.log">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>log
        <span class="apidocSignatureSpan">(sql, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (sql, t) {
  debug(sql, t);
  this.emit(&#x27;log&#x27;, sql, t);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  app.listen(0, function() {
    process.env.PORT = this.address().port;
    done();
  });
});

grunt.registerTask(&#x27;skip-karma-on-windows&#x27;, function() {
  console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;*** SKIPPING PHANTOM-JS BASED TESTS ON WINDOWS ***&#x27;);
});

grunt.registerTask(&#x27;e2e&#x27;, [&#x27;e2e-server&#x27;, &#x27;karma:e2e&#x27;]);

// Default task.
grunt.registerTask(&#x27;default&#x27;, [&#x27;browserify&#x27;]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.mixin" id="apidoc.element.loopback.DataSource.prototype.mixin">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>mixin
        <span class="apidocSignatureSpan">(ModelCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (ModelCtor) {
  var ops = this.operations();
  var DAO = this.DataAccessObject;

  // mixin DAO
  jutil.mixin(ModelCtor, DAO, {proxyFunctions: true, override: true});

  // decorate operations as alias functions
  Object.keys(ops).forEach(function(name) {
    var op = ops[name];
    var scope;

    if (op.enabled) {
      scope = op.prototype ? ModelCtor.prototype : ModelCtor;
      // var sfn = scope[name] = function () {
      //   op.scope[op.fnName].apply(self, arguments);
      // }
      Object.keys(op)
        .filter(function(key) {
          // filter out the following keys
          return ~[
            &#x27;scope&#x27;,
            &#x27;fnName&#x27;,
            &#x27;prototype&#x27;,
          ].indexOf(key);
        })
        .forEach(function(key) {
          if (typeof op[key] !== &#x27;undefined&#x27;) {
            op.scope[op.fnName][key] = op[key];
          }
        });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.operations" id="apidoc.element.loopback.DataSource.prototype.operations">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>operations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">operations = function () {
  return this._operations;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.ping" id="apidoc.element.loopback.DataSource.prototype.ping">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>ping
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (cb) {
  var self = this;
  if (self.connector.ping) {
    this.connector.ping(cb);
  } else if (self.connector.discoverModelProperties) {
    self.discoverModelProperties(&#x27;dummy&#x27;, {}, cb);
  } else {
    process.nextTick(function() {
      var err = self.connected ? null : new Error(g.f(&#x27;Not connected&#x27;));
      cb(err);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.ready" id="apidoc.element.loopback.DataSource.prototype.ready">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>ready
        <span class="apidocSignatureSpan">(obj, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ready = function (obj, args) {
  var self = this;
  if (this.connected) {
    // Connected
    return false;
  }

  var method = args.callee;
  // Set up a callback after the connection is established to continue the method call

  var onConnected = null, onError = null, timeoutHandle = null;
  onConnected = function() {
    // Remove the error handler
    self.removeListener(&#x27;error&#x27;, onError);
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
    var params = [].slice.call(args);
    try {
      method.apply(obj, params);
    } catch (err) {
      // Catch the exception and report it via callback
      var cb = params.pop();
      if (typeof cb === &#x27;function&#x27;) {
        process.nextTick(function() {
          cb(err);
        });
      } else {
        throw err;
      }
    }
  };
  onError = function(err) {
    // Remove the connected listener
    self.removeListener(&#x27;connected&#x27;, onConnected);
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
    var params = [].slice.call(args);
    var cb = params.pop();
    if (typeof cb === &#x27;function&#x27;) {
      process.nextTick(function() {
        cb(err);
      });
    }
  };
  this.once(&#x27;connected&#x27;, onConnected);
  this.once(&#x27;error&#x27;, onError);

  // Set up a timeout to cancel the invocation
  var timeout = this.settings.connectionTimeout || 5000;
  timeoutHandle = setTimeout(function() {
    self.removeListener(&#x27;error&#x27;, onError);
    self.removeListener(&#x27;connected&#x27;, onConnected);
    var params = [].slice.call(args);
    var cb = params.pop();
    if (typeof cb === &#x27;function&#x27;) {
      cb(new Error(g.f(&#x27;Timeout in connecting after %s ms&#x27;, timeout)));
    }
  }, timeout);

  if (!this.connecting) {
    this.connect();
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.setup" id="apidoc.element.loopback.DataSource.prototype.setup">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>setup
        <span class="apidocSignatureSpan">(name, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function (name, settings) {
  var dataSource = this;
  var connector;

  // support single settings object
  if (name &#x26;&#x26; typeof name === &#x27;object&#x27; &#x26;&#x26; !settings) {
    settings = name;
    name = undefined;
  }

  if (typeof settings === &#x27;object&#x27;) {
    if (settings.initialize) {
      connector = settings;
    } else if (settings.connector) {
      connector = settings.connector;
    } else if (settings.adapter) {
      connector = settings.adapter;
    }
  }

  // just save everything we get
  this.settings = settings || {};

  this.settings.debug = this.settings.debug || debug.enabled;

  if (this.settings.debug) {
    debug(&#x27;Settings: %j&#x27;, this.settings);
  }

  // Disconnected by default
  this.connected = false;
  this.connecting = false;

  if (typeof connector === &#x27;string&#x27;) {
    name = connector;
    connector = undefined;
  }
  name = name || (connector &#x26;&#x26; connector.name);
  this.name = name;

  if (name &#x26;&#x26; !connector) {
    if (typeof name === &#x27;object&#x27;) {
      // The first argument might be the connector itself
      connector = name;
      this.name = connector.name;
    } else {
      // The connector has not been resolved
      var result = DataSource._resolveConnector(name);
      connector = result.connector;
      if (!connector) {
        console.error(result.error);
        this.emit(&#x27;error&#x27;, new Error(result.error));
        return;
      }
    }
  }

  if (connector) {
    var postInit = function postInit(err, result) {
      this._setupConnector();
      // we have an connector now?
      if (!this.connector) {
        throw new Error(g.f(&#x27;Connector is not defined correctly: &#x27; +
          &#x27;it should create `{{connector}}` member of dataSource&#x27;));
      }
      this.connected = !err; // Connected now
      if (this.connected) {
        this.emit(&#x27;connected&#x27;);
      } else {
        // The connection fails, let&#x27;s report it and hope it will be recovered in the next call
        g.error(&#x27;Connection fails: %s\nIt will be retried for the next request.&#x27;, err);
        this.emit(&#x27;error&#x27;, err);
        this.connecting = false;
      }
    }.bind(this);

    try {
      if (&#x27;function&#x27; === typeof connector.initialize) {
        // Call the async initialize method
        connector.initialize(this, postInit);
      } else if (&#x27;function&#x27; === typeof connector) {
        // Use the connector constructor directly
        this.connector = new connector(this.settings);
        postInit();
      }
    } catch (err) {
      if (err.message) {
        err.message = &#x27;Cannot initialize connector &#x27; +
          JSON.stringify(connector.name || name)  + &#x27;: &#x27; +
          err.message;
      }
      throw err;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.setupDataAccess" id="apidoc.element.loopback.DataSource.prototype.setupDataAccess">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>setupDataAccess
        <span class="apidocSignatureSpan">(modelClass, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupDataAccess = function (modelClass, settings) {
  if (this.connector) {
    // Check if the id property should be generated
    var idName = modelClass.definition.idName();
    var idProp = modelClass.definition.rawProperties[idName];
    if (idProp &#x26;&#x26; idProp.generated &#x26;&#x26; this.connector.getDefaultIdType) {
      // Set the default id type from connector&#x27;s ability
      var idType = this.connector.getDefaultIdType() || String;
      idProp.type = idType;
      modelClass.definition.rawProperties[idName].type = idType;
      modelClass.definition.properties[idName].type = idType;
      var forceId = settings.forceId;
      if (idProp.generated &#x26;&#x26; forceId !== false) {
        forceId = true;
      }
      if (forceId) {
        modelClass.validatesAbsenceOf(idName, {if: &#x27;isNewRecord&#x27;});
      }
    }
    if (this.connector.define) {
      // pass control to connector
      this.connector.define({
        model: modelClass,
        properties: modelClass.definition.properties,
        settings: settings,
      });
    }
  }

  // add data access objects
  this.mixin(modelClass);

  // define relations from LDL (options.relations)
  var relations = settings.relationships || settings.relations;
  this.defineRelations(modelClass, relations);

  // Emit the dataAccessConfigured event to indicate all the methods for data
  // access have been mixed into the model class
  modelClass.emit(&#x27;dataAccessConfigured&#x27;, modelClass);

  // define scopes from LDL (options.relations)
  var scopes = settings.scopes || {};
  this.defineScopes(modelClass, scopes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.supportTypes" id="apidoc.element.loopback.DataSource.prototype.supportTypes">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>supportTypes
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supportTypes = function (types) {
  var supportedTypes = this.getTypes();
  if (Array.isArray(types)) {
    // Check each of the types
    for (var i = 0; i &#x3c; types.length; i++) {
      if (supportedTypes.indexOf(types[i]) === -1) {
        // Not supported
        return false;
      }
    }
    return true;
  } else {
    // The types is a string
    return supportedTypes.indexOf(types) !== -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.tableName" id="apidoc.element.loopback.DataSource.prototype.tableName">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>tableName
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tableName = function (modelName) {
  return this.getModelDefinition(modelName).tableName(this.connector.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.DataSource.prototype.transaction" id="apidoc.element.loopback.DataSource.prototype.transaction">
        function <span class="apidocSignatureSpan">loopback.DataSource.prototype.</span>transaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transaction = function () {
  var dataSource = this;
  var transaction = new EventEmitter();

  for (var p in dataSource) {
    transaction[p] = dataSource[p];
  }

  transaction.isTransaction = true;
  transaction.origin = dataSource;
  transaction.name = dataSource.name;
  transaction.settings = dataSource.settings;
  transaction.connected = false;
  transaction.connecting = false;
  transaction.connector = dataSource.connector.transaction();

  // create blank models pool
  transaction.modelBuilder = new ModelBuilder();
  transaction.models = transaction.modelBuilder.models;
  transaction.definitions = transaction.modelBuilder.definitions;

  for (var i in dataSource.modelBuilder.models) {
    dataSource.copyModel.call(transaction, dataSource.modelBuilder.models[i]);
  }

  transaction.exec = function(cb) {
    transaction.connector.exec(cb);
  };

  return transaction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Email" id="apidoc.module.loopback.Email">module loopback.Email</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Email.Email" id="apidoc.element.loopback.Email.Email">
        function <span class="apidocSignatureSpan">loopback.</span>Email
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.ValidationError" id="apidoc.element.loopback.Email.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Email.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email._ACL" id="apidoc.element.loopback.Email._ACL">
        function <span class="apidocSignatureSpan">loopback.Email.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email._getAccessTypeForMethod" id="apidoc.element.loopback.Email._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Email.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email._notifyBaseObservers" id="apidoc.element.loopback.Email._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Email.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email._runWhenAttachedToApp" id="apidoc.element.loopback.Email._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Email.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.addListener" id="apidoc.element.loopback.Email.addListener">
        function <span class="apidocSignatureSpan">loopback.Email.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.afterRemote" id="apidoc.element.loopback.Email.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Email.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.afterRemoteError" id="apidoc.element.loopback.Email.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Email.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.attachTo" id="apidoc.element.loopback.Email.attachTo">
        function <span class="apidocSignatureSpan">loopback.Email.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.beforeRemote" id="apidoc.element.loopback.Email.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Email.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.belongsToRemoting" id="apidoc.element.loopback.Email.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.checkAccess" id="apidoc.element.loopback.Email.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Email.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.clearObservers" id="apidoc.element.loopback.Email.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Email.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.createOptionsFromRemotingContext" id="apidoc.element.loopback.Email.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Email.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.defineProperty" id="apidoc.element.loopback.Email.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Email.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.disableRemoteMethod" id="apidoc.element.loopback.Email.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Email.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.disableRemoteMethodByName" id="apidoc.element.loopback.Email.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Email.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.emit" id="apidoc.element.loopback.Email.emit">
        function <span class="apidocSignatureSpan">loopback.Email.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.eventNames" id="apidoc.element.loopback.Email.eventNames">
        function <span class="apidocSignatureSpan">loopback.Email.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.extend" id="apidoc.element.loopback.Email.extend">
        function <span class="apidocSignatureSpan">loopback.Email.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.forEachProperty" id="apidoc.element.loopback.Email.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Email.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.getApp" id="apidoc.element.loopback.Email.getApp">
        function <span class="apidocSignatureSpan">loopback.Email.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.getDataSource" id="apidoc.element.loopback.Email.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Email.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.getMaxListeners" id="apidoc.element.loopback.Email.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Email.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.getPropertyType" id="apidoc.element.loopback.Email.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Email.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.hasManyRemoting" id="apidoc.element.loopback.Email.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.hasOneRemoting" id="apidoc.element.loopback.Email.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.isHiddenProperty" id="apidoc.element.loopback.Email.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Email.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.isProtectedProperty" id="apidoc.element.loopback.Email.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Email.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.listenerCount" id="apidoc.element.loopback.Email.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Email.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.listeners" id="apidoc.element.loopback.Email.listeners">
        function <span class="apidocSignatureSpan">loopback.Email.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.mixin" id="apidoc.element.loopback.Email.mixin">
        function <span class="apidocSignatureSpan">loopback.Email.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.nestRemoting" id="apidoc.element.loopback.Email.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.notifyObserversAround" id="apidoc.element.loopback.Email.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Email.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.notifyObserversOf" id="apidoc.element.loopback.Email.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.observe" id="apidoc.element.loopback.Email.observe">
        function <span class="apidocSignatureSpan">loopback.Email.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.on" id="apidoc.element.loopback.Email.on">
        function <span class="apidocSignatureSpan">loopback.Email.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.once" id="apidoc.element.loopback.Email.once">
        function <span class="apidocSignatureSpan">loopback.Email.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.prependListener" id="apidoc.element.loopback.Email.prependListener">
        function <span class="apidocSignatureSpan">loopback.Email.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.prependOnceListener" id="apidoc.element.loopback.Email.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Email.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.registerProperty" id="apidoc.element.loopback.Email.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Email.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.remoteMethod" id="apidoc.element.loopback.Email.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Email.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.removeAllListeners" id="apidoc.element.loopback.Email.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Email.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.removeListener" id="apidoc.element.loopback.Email.removeListener">
        function <span class="apidocSignatureSpan">loopback.Email.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.removeObserver" id="apidoc.element.loopback.Email.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Email.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.scopeRemoting" id="apidoc.element.loopback.Email.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.send" id="apidoc.element.loopback.Email.send">
        function <span class="apidocSignatureSpan">loopback.Email.</span>send
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function () {
  throw new Error(g.f(&#x27;You must connect the {{Email}} Model to a {{Mail}} connector&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.get(&#x27;/&#x27;, function(req, res){
*   res.<span class="apidocCodeKeywordSpan">send</span>(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
* @header var app = loopback()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.setMaxListeners" id="apidoc.element.loopback.Email.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Email.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.setup" id="apidoc.element.loopback.Email.setup">
        function <span class="apidocSignatureSpan">loopback.Email.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function () {
  var ModelCtor = this;
  var Parent = this.super_;

  if (!ModelCtor.registry &#x26;&#x26; Parent &#x26;&#x26; Parent.registry) {
    ModelCtor.registry = Parent.registry;
  }

  var options = this.settings;
  var typeName = this.modelName;

  // support remoting prototype methods
  // it&#x27;s important to setup this function *before* calling `new SharedClass`
  // otherwise remoting metadata from our base model is picked up
  ModelCtor.sharedCtor = function(data, id, options, fn) {
    var ModelCtor = this;

    var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
      typeof id === &#x27;object&#x27; &#x26;&#x26;
      typeof options === &#x27;function&#x27;;
    if (isRemoteInvocationWithOptions) {
      // sharedCtor(id, options, fn)
      fn = options;
      options = id;
      id = data;
      data = null;
    } else if (typeof data === &#x27;function&#x27;) {
      // sharedCtor(fn)
      fn = data;
      data = null;
      id = null;
      options = null;
    } else if (typeof id === &#x27;function&#x27;) {
      // sharedCtor(data, fn)
      // sharedCtor(id, fn)
      fn = id;
      options = null;

      if (typeof data !== &#x27;object&#x27;) {
        id = data;
        data = null;
      } else {
        id = null;
      }
    }

    if (id &#x26;&#x26; data) {
      var model = new ModelCtor(data);
      model.id = id;
      fn(null, model);
    } else if (data) {
      fn(null, new ModelCtor(data));
    } else if (id) {
      var filter = {};
      ModelCtor.findById(id, filter, options, function(err, model) {
        if (err) {
          fn(err);
        } else if (model) {
          fn(null, model);
        } else {
          err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Email.setup %s&#x27;, id));
          err.statusCode = 404;
          err.code = &#x27;MODEL_NOT_FOUND&#x27;;
          fn(err);
        }
      });
    } else {
      fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Email.setup or {{data}}&#x27;)));
    }
  };

  var idDesc = ModelCtor.modelName + &#x27; id&#x27;;
  ModelCtor.sharedCtor.accepts = [
    {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, required: true, http: {source: &#x27;path&#x27;},
      description: idDesc},
    // {arg: &#x27;instance&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;body&#x27;}}
    {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: createOptionsViaModelMethod},
  ];

  ModelCtor.sharedCtor.http = [
    {path: &#x27;/:id&#x27;},
  ];

  ModelCtor.sharedCtor.returns = {root: true};

  var remotingOptions = {};
  extend(remotingOptions, options.remoting || {});

  // create a sharedClass
  var sharedClass = ModelCtor.sharedClass = new SharedClass(
    ModelCtor.modelName,
    ModelCtor,
    remotingOptions
  );

  // before remote hook
  ModelCtor.beforeRemote = function(name, fn) {
    var className = this.modelName;
    this._runWhenAttachedToApp(function(app) {
      var remotes = app.remotes();
      remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
        return fn(ctx, ctx.result, next);
      });
    });
  };

  // after remote hook
  ModelCtor.afterRemote = function(name, fn) {
    var className = this.modelName;
    this._runWhenAttachedToApp(function(app) {
      var remotes = app.remotes();
      remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
        return fn(ctx, ctx.result, next);
      });
    });
  };

  ModelCtor.afterRemoteError = function(name, fn) {
    var className = this.modelName;
    this._runWhenAttachedToApp(function(app) {
      var remotes = app.remotes();
      remotes.afterError(className + &#x27;.&#x27; + name, fn);
    });
  };

  ModelCtor._runWhenAttachedToApp = function(fn) {
    if (this.app) return fn(this.app);
    var self = this;
    self.once(&#x27;attached&#x27;, function() {
      fn(self.app);
    });
  };

  if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
    console.warn(g.f(
      &#x27;%s is using model setting %s which is no longer available.&#x27;,
      typeName, &#x27;injectOptionsFromRemoteContext&#x27;));
    console.warn(g.f(
      &#x27;Please rework your app to use the offical solution for injecting &#x27; +
        &#x27;&#x22;options&#x22; argument from request context,\nsee %s&#x27;,
      &#x27;http://loopback.io/doc/en/lb3/Using-current-context.html&#x27;));
  }

  // resolve relation functions
  sharedClass.resolve(function resolver(d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.sharedCtor" id="apidoc.element.loopback.Email.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Email.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Email.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Email.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_" id="apidoc.element.loopback.Email.super_">
        function <span class="apidocSignatureSpan">loopback.Email.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validate" id="apidoc.element.loopback.Email.validate">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validateAsync" id="apidoc.element.loopback.Email.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesAbsenceOf" id="apidoc.element.loopback.Email.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesExclusionOf" id="apidoc.element.loopback.Email.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesFormatOf" id="apidoc.element.loopback.Email.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesInclusionOf" id="apidoc.element.loopback.Email.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesLengthOf" id="apidoc.element.loopback.Email.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesNumericalityOf" id="apidoc.element.loopback.Email.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesPresenceOf" id="apidoc.element.loopback.Email.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.validatesUniquenessOf" id="apidoc.element.loopback.Email.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Email.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Email.prototype" id="apidoc.module.loopback.Email.prototype">module loopback.Email.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Email.prototype.send" id="apidoc.element.loopback.Email.prototype.send">
        function <span class="apidocSignatureSpan">loopback.Email.prototype.</span>send
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function () {
  throw new Error(g.f(&#x27;You must connect the {{Email}} Model to a {{Mail}} connector&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.get(&#x27;/&#x27;, function(req, res){
*   res.<span class="apidocCodeKeywordSpan">send</span>(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
* @header var app = loopback()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Email.sharedClass" id="apidoc.module.loopback.Email.sharedClass">module loopback.Email.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Email.sharedClass.ctor" id="apidoc.element.loopback.Email.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.Email.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Email.super_" id="apidoc.module.loopback.Email.super_">module loopback.Email.super_</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_" id="apidoc.element.loopback.Email.super_.super_">
        function <span class="apidocSignatureSpan">loopback.Email.</span>super_
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">[Model undefined]</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.ValidationError" id="apidoc.element.loopback.Email.super_.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_._ACL" id="apidoc.element.loopback.Email.super_._ACL">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_._getAccessTypeForMethod" id="apidoc.element.loopback.Email.super_._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_._notifyBaseObservers" id="apidoc.element.loopback.Email.super_._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_._runWhenAttachedToApp" id="apidoc.element.loopback.Email.super_._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.addListener" id="apidoc.element.loopback.Email.super_.addListener">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.afterRemote" id="apidoc.element.loopback.Email.super_.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.afterRemoteError" id="apidoc.element.loopback.Email.super_.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.attachTo" id="apidoc.element.loopback.Email.super_.attachTo">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.beforeRemote" id="apidoc.element.loopback.Email.super_.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.belongsToRemoting" id="apidoc.element.loopback.Email.super_.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.checkAccess" id="apidoc.element.loopback.Email.super_.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.clearObservers" id="apidoc.element.loopback.Email.super_.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.createOptionsFromRemotingContext" id="apidoc.element.loopback.Email.super_.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.defineProperty" id="apidoc.element.loopback.Email.super_.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.disableRemoteMethod" id="apidoc.element.loopback.Email.super_.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.disableRemoteMethodByName" id="apidoc.element.loopback.Email.super_.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.emit" id="apidoc.element.loopback.Email.super_.emit">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.eventNames" id="apidoc.element.loopback.Email.super_.eventNames">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.extend" id="apidoc.element.loopback.Email.super_.extend">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.forEachProperty" id="apidoc.element.loopback.Email.super_.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.getApp" id="apidoc.element.loopback.Email.super_.getApp">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.getDataSource" id="apidoc.element.loopback.Email.super_.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.getMaxListeners" id="apidoc.element.loopback.Email.super_.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.getPropertyType" id="apidoc.element.loopback.Email.super_.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.hasManyRemoting" id="apidoc.element.loopback.Email.super_.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.hasOneRemoting" id="apidoc.element.loopback.Email.super_.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.isHiddenProperty" id="apidoc.element.loopback.Email.super_.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.isProtectedProperty" id="apidoc.element.loopback.Email.super_.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.listenerCount" id="apidoc.element.loopback.Email.super_.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.listeners" id="apidoc.element.loopback.Email.super_.listeners">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.mixin" id="apidoc.element.loopback.Email.super_.mixin">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.nestRemoting" id="apidoc.element.loopback.Email.super_.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.notifyObserversAround" id="apidoc.element.loopback.Email.super_.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.notifyObserversOf" id="apidoc.element.loopback.Email.super_.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.observe" id="apidoc.element.loopback.Email.super_.observe">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.on" id="apidoc.element.loopback.Email.super_.on">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.once" id="apidoc.element.loopback.Email.super_.once">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.prependListener" id="apidoc.element.loopback.Email.super_.prependListener">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.prependOnceListener" id="apidoc.element.loopback.Email.super_.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.registerProperty" id="apidoc.element.loopback.Email.super_.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.remoteMethod" id="apidoc.element.loopback.Email.super_.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.removeAllListeners" id="apidoc.element.loopback.Email.super_.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.removeListener" id="apidoc.element.loopback.Email.super_.removeListener">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.removeObserver" id="apidoc.element.loopback.Email.super_.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.scopeRemoting" id="apidoc.element.loopback.Email.super_.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.setMaxListeners" id="apidoc.element.loopback.Email.super_.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.setup" id="apidoc.element.loopback.Email.super_.setup">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function () {
  var ModelCtor = this;
  var Parent = this.super_;

  if (!ModelCtor.registry &#x26;&#x26; Parent &#x26;&#x26; Parent.registry) {
    ModelCtor.registry = Parent.registry;
  }

  var options = this.settings;
  var typeName = this.modelName;

  // support remoting prototype methods
  // it&#x27;s important to setup this function *before* calling `new SharedClass`
  // otherwise remoting metadata from our base model is picked up
  ModelCtor.sharedCtor = function(data, id, options, fn) {
    var ModelCtor = this;

    var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
      typeof id === &#x27;object&#x27; &#x26;&#x26;
      typeof options === &#x27;function&#x27;;
    if (isRemoteInvocationWithOptions) {
      // sharedCtor(id, options, fn)
      fn = options;
      options = id;
      id = data;
      data = null;
    } else if (typeof data === &#x27;function&#x27;) {
      // sharedCtor(fn)
      fn = data;
      data = null;
      id = null;
      options = null;
    } else if (typeof id === &#x27;function&#x27;) {
      // sharedCtor(data, fn)
      // sharedCtor(id, fn)
      fn = id;
      options = null;

      if (typeof data !== &#x27;object&#x27;) {
        id = data;
        data = null;
      } else {
        id = null;
      }
    }

    if (id &#x26;&#x26; data) {
      var model = new ModelCtor(data);
      model.id = id;
      fn(null, model);
    } else if (data) {
      fn(null, new ModelCtor(data));
    } else if (id) {
      var filter = {};
      ModelCtor.findById(id, filter, options, function(err, model) {
        if (err) {
          fn(err);
        } else if (model) {
          fn(null, model);
        } else {
          err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Email.super_.setup %s&#x27;, id));
          err.statusCode = 404;
          err.code = &#x27;MODEL_NOT_FOUND&#x27;;
          fn(err);
        }
      });
    } else {
      fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Email.super_.setup or {{data}}&#x27;)));
    }
  };

  var idDesc = ModelCtor.modelName + &#x27; id&#x27;;
  ModelCtor.sharedCtor.accepts = [
    {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, required: true, http: {source: &#x27;path&#x27;},
      description: idDesc},
    // {arg: &#x27;instance&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;body&#x27;}}
    {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: createOptionsViaModelMethod},
  ];

  ModelCtor.sharedCtor.http = [
    {path: &#x27;/:id&#x27;},
  ];

  ModelCtor.sharedCtor.returns = {root: true};

  var remotingOptions = {};
  extend(remotingOptions, options.remoting || {});

  // create a sharedClass
  var sharedClass = ModelCtor.sharedClass = new SharedClass(
    ModelCtor.modelName,
    ModelCtor,
    remotingOptions
  );

  // before remote hook
  ModelCtor.beforeRemote = function(name, fn) {
    var className = this.modelName;
    this._runWhenAttachedToApp(function(app) {
      var remotes = app.remotes();
      remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
        return fn(ctx, ctx.result, next);
      });
    });
  };

  // after remote hook
  ModelCtor.afterRemote = function(name, fn) {
    var className = this.modelName;
    this._runWhenAttachedToApp(function(app) {
      var remotes = app.remotes();
      remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
        return fn(ctx, ctx.result, next);
      });
    });
  };

  ModelCtor.afterRemoteError = function(name, fn) {
    var className = this.modelName;
    this._runWhenAttachedToApp(function(app) {
      var remotes = app.remotes();
      remotes.afterError(className + &#x27;.&#x27; + name, fn);
    });
  };

  ModelCtor._runWhenAttachedToApp = function(fn) {
    if (this.app) return fn(this.app);
    var self = this;
    self.once(&#x27;attached&#x27;, function() {
      fn(self.app);
    });
  };

  if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
    console.warn(g.f(
      &#x27;%s is using model setting %s which is no longer available.&#x27;,
      typeName, &#x27;injectOptionsFromRemoteContext&#x27;));
    console.warn(g.f(
      &#x27;Please rework your app to use the offical solution for injecting &#x27; +
        &#x27;&#x22;options&#x22; argument from request context,\nsee %s&#x27;,
      &#x27;http://loopback.io/doc/en/lb3/Using-current-context.html&#x27;));
  }

  // resolve relation functions
  sharedClass.resolve(function resolver(d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.sharedCtor" id="apidoc.element.loopback.Email.super_.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Email.super_.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Email.super_.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validate" id="apidoc.element.loopback.Email.super_.validate">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validateAsync" id="apidoc.element.loopback.Email.super_.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesAbsenceOf" id="apidoc.element.loopback.Email.super_.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesExclusionOf" id="apidoc.element.loopback.Email.super_.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesFormatOf" id="apidoc.element.loopback.Email.super_.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesInclusionOf" id="apidoc.element.loopback.Email.super_.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesLengthOf" id="apidoc.element.loopback.Email.super_.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesNumericalityOf" id="apidoc.element.loopback.Email.super_.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesPresenceOf" id="apidoc.element.loopback.Email.super_.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.validatesUniquenessOf" id="apidoc.element.loopback.Email.super_.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Email.super_.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Email.super_.super_.prototype" id="apidoc.module.loopback.Email.super_.super_.prototype">module loopback.Email.super_.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype._initProperties" id="apidoc.element.loopback.Email.super_.super_.prototype._initProperties">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>_initProperties
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initProperties = function (data, options) {
  var self = this;
  var ctor = this.constructor;
                                     // issue#1261
  if (typeof data !== &#x27;undefined&#x27; &#x26;&#x26; data.constructor &#x26;&#x26;
      typeof (data.constructor) !== &#x27;function&#x27;) {
    throw new Error(g.f(&#x27;Property name &#x22;function Object() { [native code] }&#x22; is not allowed in %s data&#x27;, ctor.modelName));
  }

  if (data instanceof ctor) {
    // Convert the data to be plain object to avoid pollutions
    data = data.toObject(false);
  }
  var properties = _extend({}, ctor.definition.properties);
  data = data || {};

  if (typeof ctor.applyProperties === &#x27;function&#x27;) {
    ctor.applyProperties(data);
  }

  options = options || {};
  var applySetters = options.applySetters;
  var applyDefaultValues = options.applyDefaultValues;
  var strict = options.strict;

  if (strict === undefined) {
    strict = ctor.definition.settings.strict;
  } else if (strict === &#x27;throw&#x27;) {
    g.warn(&#x27;Warning: Model %s, {{strict mode: `throw`}} has been removed, &#x27; +
      &#x27;please use {{`strict: true`}} instead, which returns&#x27; +
      &#x27;{{`Validation Error`}} for unknown properties,&#x27;, ctor.modelName);
  }

  var persistUndefinedAsNull = ctor.definition.settings.persistUndefinedAsNull;

  if (ctor.hideInternalProperties) {
    // Object.defineProperty() is expensive. We only try to make the internal
    // properties hidden (non-enumerable) if the model class has the
    // `hideInternalProperties` set to true
    Object.defineProperties(this, {
      __cachedRelations: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: {},
      },

      __data: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: {},
      },

      // Instance level data source
      __dataSource: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: options.dataSource,
      },

      // Instance level strict mode
      __strict: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: strict,
      },

      __persisted: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: false,
      },
    });

    if (strict) {
      Object.defineProperty(this, &#x27;__unknownProperties&#x27;, {
        writable: true,
        enumerable: false,
        configrable: true,
        value: [],
      });
    }
  } else {
    this.__cachedRelations = {};
    this.__data = {};
    this.__dataSource = options.dataSource;
    this.__strict = strict;
    this.__persisted = false;
    if (strict) {
      this.__unknownProperties = [];
    }
  }

  if (options.persisted !== undefined) {
    this.__persisted = options.persisted === true;
  }

  if (data.__cachedRelations) {
    this.__cachedRelations = data.__cachedRelations;
  }

  var keys = Object.keys(data);

  if (Array.isArray(options.fields)) {
    keys = keys.filter(function(k) {
      return (options.fields.indexOf(k) != -1);
    });
  }

  var size = keys.length;
  var p, propVal;
  for (var k = 0; k &#x3c; size; k++) {
    p = keys[k];
    propVal = data[p];
    if (typeof propVal === &#x27;function&#x27;) {
      continue;
    }

    if (propVal === undefined &#x26;&#x26; persistUndefinedAsNull) {
      propVal = null;
    }

    if (properties[p]) {
      // Managed property
      if (applySetters || properties[p].id) {
        self[p] = propVal;
      } else {
        self.__data[p] = propVal;
      }
    } else if (ctor.relations[p]) {
      var relationType = ctor.relations[p].type;

      var modelTo;
      if (!properties[p]) {
        modelTo = ctor.relations[p].modelTo || ModelBaseClass;
        var multiple = ctor.relations[p].multiple;
        var typeName = multiple ? &#x27;Array&#x27; : modelTo.modelName;
        var propType = multiple ? [modelTo] : modelTo;
        properties[p] = {name: typeName, type: propType};
<span class="apidocCodeCommentSpan">        /* Issue #1252
        this.setStrict(false);
        */
</span>      }

      // Relation
      if (relationType === &#x27;belongsTo&#x27; &#x26;&#x26; propVal != null) {
        // If the related model is populated
        self.__data ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.upsert(inst, function(err) {
        inst.<span class="apidocCodeKeywordSpan">_initProperties</span>(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
    }, data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.fromObject" id="apidoc.element.loopback.Email.super_.super_.prototype.fromObject">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>fromObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromObject = function (obj) {
  for (var key in obj) {
    this[key] = obj[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.getDataSource" id="apidoc.element.loopback.Email.super_.super_.prototype.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.__dataSource || this.constructor.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.getPropertyType" id="apidoc.element.loopback.Email.super_.super_.prototype.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  return this.constructor.getPropertyType(propName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.inspect" id="apidoc.element.loopback.Email.super_.super_.prototype.inspect">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>inspect
        <span class="apidocSignatureSpan">(depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function (depth) {
  if (INSPECT_SUPPORTS_OBJECT_RETVAL)
    return this.__data;

  // Workaround for older versions
  // See also https://github.com/joyent/node/commit/66280de133
  return util.inspect(this.__data, {
    showHidden: false,
    depth: depth,
    colors: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.isValid" id="apidoc.element.loopback.Email.super_.super_.prototype.isValid">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>isValid
        <span class="apidocSignatureSpan">(callback, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValid = function (callback, data, options) {
  options = options || {};
  var valid = true, inst = this, wait = 0, async = false;
  var validations = this.constructor.validations;

  var reportDiscardedProperties = this.__strict &#x26;&#x26;
    this.__unknownProperties &#x26;&#x26; this.__unknownProperties.length;

  // exit with success when no errors
  if (typeof validations !== &#x27;object&#x27; &#x26;&#x26; !reportDiscardedProperties) {
    cleanErrors(this);
    if (callback) {
      this.trigger(&#x27;validate&#x27;, function(validationsDone) {
        validationsDone.call(inst, function() {
          callback(valid);
        });
      }, data, callback);
    }
    return valid;
  }

  Object.defineProperty(this, &#x27;errors&#x27;, {
    enumerable: false,
    configurable: true,
    value: new Errors,
  });

  this.trigger(&#x27;validate&#x27;, function(validationsDone) {
    var inst = this,
      asyncFail = false;

    var attrs = Object.keys(validations || {});

    attrs.forEach(function(attr) {
      var attrValidations = validations[attr] || [];
      attrValidations.forEach(function(v) {
        if (v.options &#x26;&#x26; v.options.async) {
          async = true;
          wait += 1;
          process.nextTick(function() {
            validationFailed(inst, attr, v, options, done);
          });
        } else {
          if (validationFailed(inst, attr, v)) {
            valid = false;
          }
        }
      });
    });

    if (reportDiscardedProperties) {
      for (var ix in inst.__unknownProperties) {
        var key = inst.__unknownProperties[ix];
        var code = &#x27;unknown-property&#x27;;
        var msg = defaultMessages[code];
        inst.errors.add(key, msg, code);
        valid = false;
      }
    }

    if (!async) {
      validationsDone.call(inst, function() {
        if (valid) cleanErrors(inst);
        if (callback) {
          callback(valid);
        }
      });
    }

    function done(fail) {
      asyncFail = asyncFail || fail;
      if (--wait === 0) {
        validationsDone.call(inst, function() {
          if (valid &#x26;&#x26; !asyncFail) cleanErrors(inst);
          if (callback) {
            callback(valid &#x26;&#x26; !asyncFail);
          }
        });
      }
    }
  }, data, callback);

  if (async) {
    // in case of async validation we should return undefined here,
    // because not all validations are finished yet
    return;
  } else {
    return valid;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// validate first
if (!options.validate) {
  return save();
}

inst.<span class="apidocCodeKeywordSpan">isValid</span>(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.ValidationError(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.reset" id="apidoc.element.loopback.Email.super_.super_.prototype.reset">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  var obj = this;
  for (var k in obj) {
    if (k !== &#x27;id&#x27; &#x26;&#x26; !obj.constructor.dataSource.definitions[obj.constructor.modelName].properties[k]) {
      delete obj[k];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.setStrict" id="apidoc.element.loopback.Email.super_.super_.prototype.setStrict">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>setStrict
        <span class="apidocSignatureSpan">(strict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setStrict = function (strict) {
  this.__strict = strict;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.toJSON" id="apidoc.element.loopback.Email.super_.super_.prototype.toJSON">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toObject(false, true, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (err) {
    if (done) done(err);
    return;
  }
  mappings.forEach(function(m) {
    var role;
    if (options.returnOnlyRoleNames === true) {
      role = m.<span class="apidocCodeKeywordSpan">toJSON</span>().role.name;
    } else {
      role = m.roleId;
    }
    addRole(role);
  });
  if (done) done();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.toObject" id="apidoc.element.loopback.Email.super_.super_.prototype.toObject">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>toObject
        <span class="apidocSignatureSpan">(onlySchema, removeHidden, removeProtected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function (onlySchema, removeHidden, removeProtected) {
  if (onlySchema === undefined) {
    onlySchema = true;
  }
  var data = {};
  var self = this;
  var Model = this.constructor;

  // if it is already an Object
  if (Model === Object) {
    return self;
  }

  var strict = this.__strict;
  var schemaLess = (strict === false) || !onlySchema;
  var persistUndefinedAsNull = Model.definition.settings.persistUndefinedAsNull;

  var props = Model.definition.properties;
  var keys = Object.keys(props);
  var propertyName, val;

  for (var i = 0; i &#x3c; keys.length; i++) {
    propertyName = keys[i];
    val = self[propertyName];

    // Exclude functions
    if (typeof val === &#x27;function&#x27;) {
      continue;
    }
    // Exclude hidden properties
    if (removeHidden &#x26;&#x26; Model.isHiddenProperty(propertyName)) {
      continue;
    }

    if (removeProtected &#x26;&#x26; Model.isProtectedProperty(propertyName)) {
      continue;
    }

    if (val instanceof List) {
      data[propertyName] = val.toObject(!schemaLess, removeHidden, true);
    } else {
      if (val !== undefined &#x26;&#x26; val !== null &#x26;&#x26; val.toObject) {
        data[propertyName] = val.toObject(!schemaLess, removeHidden, true);
      } else {
        if (val === undefined &#x26;&#x26; persistUndefinedAsNull) {
          val = null;
        }
        data[propertyName] = val;
      }
    }
  }

  if (schemaLess) {
    // Find its own properties which can be set via myModel.myProperty = &#x27;myValue&#x27;.
    // If the property is not declared in the model definition, no setter will be
    // triggered to add it to __data
    keys = Object.keys(self);
    var size = keys.length;
    for (i = 0; i &#x3c; size; i++) {
      propertyName = keys[i];
      if (props[propertyName]) {
        continue;
      }
      if (propertyName.indexOf(&#x27;__&#x27;) === 0) {
        continue;
      }
      if (removeHidden &#x26;&#x26; Model.isHiddenProperty(propertyName)) {
        continue;
      }
      if (removeProtected &#x26;&#x26; Model.isProtectedProperty(propertyName)) {
        continue;
      }
      if (data[propertyName] !== undefined) {
        continue;
      }
      val = self[propertyName];
      if (val !== undefined) {
        if (typeof val === &#x27;function&#x27;) {
          continue;
        }
        if (val !== null &#x26;&#x26; val.toObject) {
          data[propertyName] = val.toObject(!schemaLess, removeHidden, true);
        } else {
          data[propertyName] = val;
        }
      } else if (persistUndefinedAsNull) {
        data[propertyName] = null;
      }
    }
    // Now continue to check __data
    keys = Object.keys(self.__data);
    size = keys.length;
    for (i = 0; i &#x3c; size; i++) {
      propertyName = keys[i];
      if (propertyName.indexOf(&#x27;__&#x27;) === 0) {
        continue;
      }
      if (data[propertyName] === undefined) {
        if (removeHidden &#x26;&#x26; Model.isHiddenProperty(propertyName)) {
          continue;
        }
        if (removeProtected &#x26;&#x26; Model.isProtectedProperty(propertyName)) {
          continue;
        }
        var ownVal = self[propertyName];
        // The ownVal can be a relation function
        val = (ownVal !== undefined &#x26;&#x26; (typeof ownVal !== &#x27;function&#x27;)) ? ownVal : self.__data[propertyName];
        if (typeof val === &#x27;function&#x27;) {
          continue;
        }

        if (val !== undefined &#x26;&#x26; val !== null &#x26;&#x26; val.toObject) {
          data[propertyName] = val.toObject(!schemaLess, removeHidden, true);
        } else if (val === undefined &#x26;&#x26; persistUndefinedAsNull) {
          data[propertyName] = null;
        } else {
          data[propertyName] = val;
        }
      }
    }
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.validate = true;
}
if (!(&#x27;throws&#x27; in options)) {
  options.throws = false;
}

var inst = this;
var data = inst.<span class="apidocCodeKeywordSpan">toObject</span>(true);
var id = this.getId();

if (!id) {
  return Model.create(this, callback);
}

// validate first
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Email.super_.super_.prototype.trigger" id="apidoc.element.loopback.Email.super_.super_.prototype.trigger">
        function <span class="apidocSignatureSpan">loopback.Email.super_.super_.prototype.</span>trigger
        <span class="apidocSignatureSpan">(actionName, work, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trigger(actionName, work, data, callback) {
  var capitalizedName = capitalize(actionName);
  var beforeHook = this.constructor[&#x27;before&#x27; + capitalizedName] ||
    this.constructor[&#x27;pre&#x27; + capitalizedName];
  var afterHook = this.constructor[&#x27;after&#x27; + capitalizedName] ||
    this.constructor[&#x27;post&#x27; + capitalizedName];
  if (actionName === &#x27;validate&#x27;) {
    beforeHook = beforeHook || this.constructor.beforeValidation;
    afterHook = afterHook || this.constructor.afterValidation;
  }
  var inst = this;

  if (actionName !== &#x27;initialize&#x27;) {
    if (beforeHook)
      deprecateHook(inst.constructor, [&#x27;before&#x27;, &#x27;pre&#x27;], capitalizedName);
    if (afterHook)
      deprecateHook(inst.constructor, [&#x27;after&#x27;, &#x27;post&#x27;], capitalizedName);
  }

  // we only call &#x22;before&#x22; hook when we have actual action (work) to perform
  if (work) {
    if (beforeHook) {
      // before hook should be called on instance with two parameters: next and data
      beforeHook.call(inst, function() {
        // Check arguments to next(err, result)
        if (arguments.length) {
          return callback &#x26;&#x26; callback.apply(null, arguments);
        }
        // No err &#x26; result is present, proceed with the real work
        // actual action also have one param: callback
        work.call(inst, next);
      }, data);
    } else {
      work.call(inst, next);
    }
  } else {
    next();
  }

  function next(done) {
    if (afterHook) {
      afterHook.call(inst, done);
    } else if (done) {
      done.call(this);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    callback(err, inst);
  }
});

// then save
function save() {
  inst.<span class="apidocCodeKeywordSpan">trigger</span>(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.upsert(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.GeoPoint" id="apidoc.module.loopback.GeoPoint">module loopback.GeoPoint</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.GeoPoint.GeoPoint" id="apidoc.element.loopback.GeoPoint.GeoPoint">
        function <span class="apidocSignatureSpan">loopback.</span>GeoPoint
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GeoPoint(data) {
  if (!(this instanceof GeoPoint)) {
    return new GeoPoint(data);
  }

  if (arguments.length === 2) {
    data = {
      lat: arguments[0],
      lng: arguments[1],
    };
  }

  assert(Array.isArray(data) || typeof data === &#x27;object&#x27; || typeof data === &#x27;string&#x27;,
    &#x27;must provide valid geo-coordinates array [lat, lng] or object or a &#x22;lat, lng&#x22; string&#x27;);

  if (typeof data === &#x27;string&#x27;) {
    try {
      data = JSON.parse(data);
    } catch (err) {
      data = data.split(/,\s*/);
      assert(data.length === 2, &#x27;must provide a string &#x22;lat,lng&#x22; creating a GeoPoint with a string&#x27;);
    }
  }
  if (Array.isArray(data)) {
    data = {
      lat: Number(data[0]),
      lng: Number(data[1]),
    };
  } else {
    data.lng = Number(data.lng);
    data.lat = Number(data.lat);
  }

  assert(typeof data === &#x27;object&#x27;, &#x27;must provide a lat and lng object when creating a GeoPoint&#x27;);
  assert(typeof data.lat === &#x27;number&#x27; &#x26;&#x26; !isNaN(data.lat), &#x27;lat must be a number when creating a GeoPoint&#x27;);
  assert(typeof data.lng === &#x27;number&#x27; &#x26;&#x26; !isNaN(data.lng), &#x27;lng must be a number when creating a GeoPoint&#x27;);
  assert(data.lng &#x3c;= 180, &#x27;lng must be &#x3c;= 180&#x27;);
  assert(data.lng &#x3e;= -180, &#x27;lng must be &#x3e;= -180&#x27;);
  assert(data.lat &#x3c;= 90, &#x27;lat must be &#x3c;= 90&#x27;);
  assert(data.lat &#x3e;= -90, &#x27;lat must be &#x3e;= -90&#x27;);

  this.lat = data.lat;
  this.lng = data.lng;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.GeoPoint.distanceBetween" id="apidoc.element.loopback.GeoPoint.distanceBetween">
        function <span class="apidocSignatureSpan">loopback.GeoPoint.</span>distanceBetween
        <span class="apidocSignatureSpan">(a, b, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distanceBetween(a, b, options) {
  if (!(a instanceof GeoPoint)) {
    a = GeoPoint(a);
  }
  if (!(b instanceof GeoPoint)) {
    b = GeoPoint(b);
  }

  var x1 = a.lat;
  var y1 = a.lng;

  var x2 = b.lat;
  var y2 = b.lng;

  return geoDistance(x1, y1, x2, y2, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.GeoPoint.prototype" id="apidoc.module.loopback.GeoPoint.prototype">module loopback.GeoPoint.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.GeoPoint.prototype.distanceTo" id="apidoc.element.loopback.GeoPoint.prototype.distanceTo">
        function <span class="apidocSignatureSpan">loopback.GeoPoint.prototype.</span>distanceTo
        <span class="apidocSignatureSpan">(point, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distanceTo = function (point, options) {
  return GeoPoint.distanceBetween(this, point, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.GeoPoint.prototype.toString" id="apidoc.element.loopback.GeoPoint.prototype.toString">
        function <span class="apidocSignatureSpan">loopback.GeoPoint.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.lat + &#x27;,&#x27; + this.lng;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
    if (err) return callback(err);
    var modelIds = models.map(function(m) {
      return m[idName].<span class="apidocCodeKeywordSpan">toString</span>();
    });
    callback(null, changes.filter(function(ch) {
      if (ch.type() === Change.DELETE) return true;
      return modelIds.indexOf(ch.modelId) &#x3e; -1;
    }));
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.KeyValueModel" id="apidoc.module.loopback.KeyValueModel">module loopback.KeyValueModel</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.KeyValueModel" id="apidoc.element.loopback.KeyValueModel.KeyValueModel">
        function <span class="apidocSignatureSpan">loopback.</span>KeyValueModel
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.ValidationError" id="apidoc.element.loopback.KeyValueModel.ValidationError">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel._ACL" id="apidoc.element.loopback.KeyValueModel._ACL">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel._getAccessTypeForMethod" id="apidoc.element.loopback.KeyValueModel._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel._notifyBaseObservers" id="apidoc.element.loopback.KeyValueModel._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel._runWhenAttachedToApp" id="apidoc.element.loopback.KeyValueModel._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.addListener" id="apidoc.element.loopback.KeyValueModel.addListener">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.afterRemote" id="apidoc.element.loopback.KeyValueModel.afterRemote">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.afterRemoteError" id="apidoc.element.loopback.KeyValueModel.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.attachTo" id="apidoc.element.loopback.KeyValueModel.attachTo">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.beforeRemote" id="apidoc.element.loopback.KeyValueModel.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.belongsToRemoting" id="apidoc.element.loopback.KeyValueModel.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.checkAccess" id="apidoc.element.loopback.KeyValueModel.checkAccess">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.clearObservers" id="apidoc.element.loopback.KeyValueModel.clearObservers">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.createOptionsFromRemotingContext" id="apidoc.element.loopback.KeyValueModel.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.defineProperty" id="apidoc.element.loopback.KeyValueModel.defineProperty">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.disableRemoteMethod" id="apidoc.element.loopback.KeyValueModel.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.disableRemoteMethodByName" id="apidoc.element.loopback.KeyValueModel.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.emit" id="apidoc.element.loopback.KeyValueModel.emit">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.eventNames" id="apidoc.element.loopback.KeyValueModel.eventNames">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.expire" id="apidoc.element.loopback.KeyValueModel.expire">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>expire
        <span class="apidocSignatureSpan">(key, ttl, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expire = function (key, ttl, options, callback) {
  throwNotAttached(this.modelName, &#x27;expire&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} key Key to use when searching the database.
 * @param {Number} ttl TTL in ms to set for the key.
 * @options {Object} options
 * @callback {Function} callback
 * @param {Error} err Error object.
 * @promise
 *
 * @header KeyValueModel.<span class="apidocCodeKeywordSpan">expire</span>(key, ttl, cb)
 */
KeyValueModel.expire = function(key, ttl, options, callback) {
  throwNotAttached(this.modelName, &#x27;expire&#x27;);
};

/**
 * Return the TTL (time to live) for a given key. TTL is the remaining time
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.extend" id="apidoc.element.loopback.KeyValueModel.extend">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.forEachProperty" id="apidoc.element.loopback.KeyValueModel.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.get" id="apidoc.element.loopback.KeyValueModel.get">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>get
        <span class="apidocSignatureSpan">(key, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key, options, callback) {
  throwNotAttached(this.modelName, &#x27;get&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* supports Express middleware. See
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/&#x27;, function(req, res){
*   res.send(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.getApp" id="apidoc.element.loopback.KeyValueModel.getApp">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.getDataSource" id="apidoc.element.loopback.KeyValueModel.getDataSource">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.getMaxListeners" id="apidoc.element.loopback.KeyValueModel.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.getPropertyType" id="apidoc.element.loopback.KeyValueModel.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.hasManyRemoting" id="apidoc.element.loopback.KeyValueModel.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.hasOneRemoting" id="apidoc.element.loopback.KeyValueModel.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.isHiddenProperty" id="apidoc.element.loopback.KeyValueModel.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.isProtectedProperty" id="apidoc.element.loopback.KeyValueModel.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.iterateKeys" id="apidoc.element.loopback.KeyValueModel.iterateKeys">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>iterateKeys
        <span class="apidocSignatureSpan">(filter, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateKeys = function (filter, options) {
  throwNotAttached(this.modelName, &#x27;iterateKeys&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Asynchronously iterate all keys in the database. Similar to `.keys()` but
* instead allows for iteration over large data sets without having to load
* everything into memory at once.
*
* Callback example:
* ```js
* // Given a model named `Color` with two keys `red` and `blue`
* var iterator = Color.<span class="apidocCodeKeywordSpan">iterateKeys</span>();
* it.next(function(err, key) {
*   // key contains `red`
*   it.next(function(err, key) {
*     // key contains `blue`
*   });
* });
* ```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.keys" id="apidoc.element.loopback.KeyValueModel.keys">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>keys
        <span class="apidocSignatureSpan">(filter, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function (filter, options, callback) {
  throwNotAttached(this.modelName, &#x27;keys&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    modelConfig.remoting &#x26;&#x26;
    modelConfig.remoting.sharedMethods &#x26;&#x26;
    typeof modelConfig.remoting.sharedMethods === &#x27;object&#x27;;
if (modelConfigHasSharedMethodsSettings)
  util._extend(settings, modelConfig.remoting.sharedMethods);

// validate setting values
Object.<span class="apidocCodeKeywordSpan">keys</span>(settings).forEach(function(setting) {
  var settingValue = settings[setting];
  var settingValueType = typeof settingValue;
  if (settingValueType !== &#x27;boolean&#x27;)
    throw new TypeError(g.f(&#x27;Expected boolean, got %s&#x27;, settingValueType));
});

// set sharedMethod.shared using the merged settings
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.listenerCount" id="apidoc.element.loopback.KeyValueModel.listenerCount">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.listeners" id="apidoc.element.loopback.KeyValueModel.listeners">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.mixin" id="apidoc.element.loopback.KeyValueModel.mixin">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.nestRemoting" id="apidoc.element.loopback.KeyValueModel.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.notifyObserversAround" id="apidoc.element.loopback.KeyValueModel.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.notifyObserversOf" id="apidoc.element.loopback.KeyValueModel.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.observe" id="apidoc.element.loopback.KeyValueModel.observe">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.on" id="apidoc.element.loopback.KeyValueModel.on">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.once" id="apidoc.element.loopback.KeyValueModel.once">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.prependListener" id="apidoc.element.loopback.KeyValueModel.prependListener">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.prependOnceListener" id="apidoc.element.loopback.KeyValueModel.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.registerProperty" id="apidoc.element.loopback.KeyValueModel.registerProperty">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.remoteMethod" id="apidoc.element.loopback.KeyValueModel.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.removeAllListeners" id="apidoc.element.loopback.KeyValueModel.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.removeListener" id="apidoc.element.loopback.KeyValueModel.removeListener">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.removeObserver" id="apidoc.element.loopback.KeyValueModel.removeObserver">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.scopeRemoting" id="apidoc.element.loopback.KeyValueModel.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.set" id="apidoc.element.loopback.KeyValueModel.set">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>set
        <span class="apidocSignatureSpan">(key, value, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value, options, callback) {
  throwNotAttached(this.modelName, &#x27;set&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For example, to listen on the specified port and all hosts, and ignore app config.
* ```js
* app.listen(80);
* ```
*
* The function also installs a `listening` callback that calls
* `app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;port&#x27;)` with the value returned by `server.address().port`.
* This way the port param contains always the real port number, even when
* listen was called with port number 0.
*
* @param {Function} [cb] If specified, the callback is added as a listener
*   for the server&#x27;s &#x22;listening&#x22; event.
* @returns {http.Server} A node `http.Server` with this application configured
*   as the request handler.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.setMaxListeners" id="apidoc.element.loopback.KeyValueModel.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.setup" id="apidoc.element.loopback.KeyValueModel.setup">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function () {
  KeyValueModel.base.setup.apply(this, arguments);

  this.remoteMethod(&#x27;get&#x27;, {
    accepts: {
      arg: &#x27;key&#x27;, type: &#x27;string&#x27;, required: true,
      http: {source: &#x27;path&#x27;},
    },
    returns: {arg: &#x27;value&#x27;, type: &#x27;any&#x27;, root: true},
    http: {path: &#x27;/:key&#x27;, verb: &#x27;get&#x27;},
    rest: {after: convertNullToNotFoundError},
  });

  this.remoteMethod(&#x27;set&#x27;, {
    accepts: [
      {arg: &#x27;key&#x27;, type: &#x27;string&#x27;, required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;value&#x27;, type: &#x27;any&#x27;, required: true,
        http: {source: &#x27;body&#x27;}},
      {arg: &#x27;ttl&#x27;, type: &#x27;number&#x27;,
        http: {source: &#x27;query&#x27;},
        description: &#x27;time to live in milliseconds&#x27;},
    ],
    http: {path: &#x27;/:key&#x27;, verb: &#x27;put&#x27;},
  });

  this.remoteMethod(&#x27;expire&#x27;, {
    accepts: [
      {arg: &#x27;key&#x27;, type: &#x27;string&#x27;, required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;ttl&#x27;, type: &#x27;number&#x27;, required: true,
        http: {source: &#x27;form&#x27;}},
    ],
    http: {path: &#x27;/:key/expire&#x27;, verb: &#x27;put&#x27;},
  });

  this.remoteMethod(&#x27;ttl&#x27;, {
    accepts: {
      arg: &#x27;key&#x27;, type: &#x27;string&#x27;, required: true,
      http: {source: &#x27;path&#x27;},
    },
    returns: {arg: &#x27;value&#x27;, type: &#x27;any&#x27;, root: true},
    http: {path: &#x27;/:key/ttl&#x27;, verb: &#x27;get&#x27;},
  });

  this.remoteMethod(&#x27;keys&#x27;, {
    accepts: {
      arg: &#x27;filter&#x27;, type: &#x27;object&#x27;, required: false,
      http: {source: &#x27;query&#x27;},
    },
    returns: {arg: &#x27;keys&#x27;, type: [&#x27;string&#x27;], root: true},
    http: {path: &#x27;/keys&#x27;, verb: &#x27;get&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.sharedCtor" id="apidoc.element.loopback.KeyValueModel.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.KeyValueModel.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.KeyValueModel.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.super_" id="apidoc.element.loopback.KeyValueModel.super_">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.ttl" id="apidoc.element.loopback.KeyValueModel.ttl">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>ttl
        <span class="apidocSignatureSpan">(key, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ttl = function (key, options, callback) {
  throwNotAttached(this.modelName, &#x27;ttl&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @options {Object} options
 * @callback {Function} callback
 * @param {Error} error
 * @param {Number} ttl Expiration time for the key-value pair. `undefined` if
 *   TTL was not initially set.
 * @promise
 *
 * @header KeyValueModel.<span class="apidocCodeKeywordSpan">ttl</span>(key, cb)
 */
KeyValueModel.ttl = function(key, options, callback) {
  throwNotAttached(this.modelName, &#x27;ttl&#x27;);
};

/**
 * Return all keys in the database.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validate" id="apidoc.element.loopback.KeyValueModel.validate">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validateAsync" id="apidoc.element.loopback.KeyValueModel.validateAsync">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesAbsenceOf" id="apidoc.element.loopback.KeyValueModel.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesExclusionOf" id="apidoc.element.loopback.KeyValueModel.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesFormatOf" id="apidoc.element.loopback.KeyValueModel.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesInclusionOf" id="apidoc.element.loopback.KeyValueModel.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesLengthOf" id="apidoc.element.loopback.KeyValueModel.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesNumericalityOf" id="apidoc.element.loopback.KeyValueModel.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesPresenceOf" id="apidoc.element.loopback.KeyValueModel.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.validatesUniquenessOf" id="apidoc.element.loopback.KeyValueModel.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.KeyValueModel.sharedClass" id="apidoc.module.loopback.KeyValueModel.sharedClass">module loopback.KeyValueModel.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.KeyValueModel.sharedClass.ctor" id="apidoc.element.loopback.KeyValueModel.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.KeyValueModel.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Mail" id="apidoc.module.loopback.Mail">module loopback.Mail</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Mail.Mail" id="apidoc.element.loopback.Mail.Mail">
        function <span class="apidocSignatureSpan">loopback.</span>Mail
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MailConnector(settings) {
  assert(typeof settings === &#x27;object&#x27;, &#x27;cannot initialize MailConnector without a settings object&#x27;);

  var transports = settings.transports;

  // if transports is not in settings object AND settings.transport exists
  if (!transports &#x26;&#x26; settings.transport) {
    // then wrap single transport in an array and assign to transports
    transports = [settings.transport];
  }

  if (!transports) {
    transports = [];
  }

  this.transportsIndex = {};
  this.transports = [];

  if (loopback.isServer) {
    transports.forEach(this.setupTransport.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail.initialize" id="apidoc.element.loopback.Mail.initialize">
        function <span class="apidocSignatureSpan">loopback.Mail.</span>initialize
        <span class="apidocSignatureSpan">(dataSource, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (dataSource, callback) {
  dataSource.connector = new MailConnector(dataSource.settings);
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Mail.mailer" id="apidoc.module.loopback.Mail.mailer">module loopback.Mail.mailer</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Mail.mailer.createTransport" id="apidoc.element.loopback.Mail.mailer.createTransport">
        function <span class="apidocSignatureSpan">loopback.Mail.mailer.</span>createTransport
        <span class="apidocSignatureSpan">(transporter, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTransport = function (transporter, defaults) {
    var urlConfig;
    var options;
    var mailer;
    var proxyUrl;

    // if no transporter configuration is provided use direct as default
    transporter = transporter || directTransport({
        debug: true
    });

    if (
        // provided transporter is a configuration object, not transporter plugin
        (typeof transporter === &#x27;object&#x27; &#x26;&#x26; typeof transporter.send !== &#x27;function&#x27;) ||
        // provided transporter looks like a connection url
        (typeof transporter === &#x27;string&#x27; &#x26;&#x26; /^(smtps?|direct):/i.test(transporter))
    ) {

        if ((urlConfig = typeof transporter === &#x27;string&#x27; ? transporter : transporter.url)) {
            // parse a configuration URL into configuration options
            options = shared.parseConnectionUrl(urlConfig);
        } else {
            options = transporter;
        }

        if (options.proxy &#x26;&#x26; typeof options.proxy === &#x27;string&#x27;) {
            proxyUrl = options.proxy;
        }

        if (options.transport &#x26;&#x26; typeof options.transport === &#x27;string&#x27;) {
            try {
                transporter = require(&#x27;nodemailer-&#x27; + (options.transport).toLowerCase() + &#x27;-transport&#x27;)(options);
            } catch (E) {
                // if transporter loader fails, return an error when sending mail
                transporter = {
                    send: function (mail, callback) {
                        var errmsg = &#x27;Requested transport plugin  &#x22;nodemailer-&#x27; + (options.transport).toLowerCase() + &#x27;-transport
&#x22; could not be initiated&#x27;;
                        var err = new Error(errmsg);
                        err.code = &#x27;EINIT&#x27;;
                        setImmediate(function () {
                            return callback(err);
                        });
                    }
                };
            }
        } else if (options.direct) {
            transporter = directTransport(options);
        } else if (options.pool) {
            transporter = smtpPoolTransport(options);
        } else {
            transporter = smtpTransport(options);
        }
    }

    mailer = new Nodemailer(transporter, options, defaults);

    if (proxyUrl) {
        setupProxy(mailer, proxyUrl);
    }

    return mailer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Mail.prototype" id="apidoc.module.loopback.Mail.prototype">module loopback.Mail.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.DataAccessObject" id="apidoc.element.loopback.Mail.prototype.DataAccessObject">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>DataAccessObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mailer() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.defaultTransport" id="apidoc.element.loopback.Mail.prototype.defaultTransport">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>defaultTransport
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultTransport = function () {
  return this.transports[0] || this.stubTransport;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.setupTransport" id="apidoc.element.loopback.Mail.prototype.setupTransport">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>setupTransport
        <span class="apidocSignatureSpan">(setting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupTransport = function (setting) {
  var connector = this;
  connector.transports = connector.transports || [];
  connector.transportsIndex = connector.transportsIndex || {};

  var transport;
  var transportType = (setting.type || &#x27;STUB&#x27;).toLowerCase();
  if (transportType === &#x27;direct&#x27;) {
    transport = mailer.createTransport();
  } else if (transportType === &#x27;smtp&#x27;) {
    transport = mailer.createTransport(setting);
  } else {
    var transportModuleName = &#x27;nodemailer-&#x27; + transportType + &#x27;-transport&#x27;;
    var transportModule = require(transportModuleName);
    transport = mailer.createTransport(transportModule(setting));
  }

  connector.transportsIndex[setting.alias || setting.type] = transport;
  connector.transports.push(transport);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.transportForName" id="apidoc.element.loopback.Mail.prototype.transportForName">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>transportForName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transportForName = function (name) {
  return this.transportsIndex[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Mail.prototype.DataAccessObject" id="apidoc.module.loopback.Mail.prototype.DataAccessObject">module loopback.Mail.prototype.DataAccessObject</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.DataAccessObject.DataAccessObject" id="apidoc.element.loopback.Mail.prototype.DataAccessObject.DataAccessObject">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.</span>DataAccessObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Mailer() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.DataAccessObject.send" id="apidoc.element.loopback.Mail.prototype.DataAccessObject.send">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.DataAccessObject.</span>send
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (options, fn) {
  var dataSource = this.dataSource;
  var settings = dataSource &#x26;&#x26; dataSource.settings;
  var connector = dataSource.connector;
  assert(connector, &#x27;Cannot send mail without a connector!&#x27;);

  var transport = connector.transportForName(options.transport);

  if (!transport) {
    transport = connector.defaultTransport();
  }

  if (debug.enabled || settings &#x26;&#x26; settings.debug) {
    g.log(&#x27;Sending Mail:&#x27;);
    if (options.transport) {
      console.log(g.f(&#x27;\t TRANSPORT:%s&#x27;, options.transport));
    }
    g.log(&#x27;\t TO:%s&#x27;, options.to);
    g.log(&#x27;\t FROM:%s&#x27;, options.from);
    g.log(&#x27;\t SUBJECT:%s&#x27;, options.subject);
    g.log(&#x27;\t TEXT:%s&#x27;, options.text);
    g.log(&#x27;\t HTML:%s&#x27;, options.html);
  }

  if (transport) {
    assert(transport.sendMail,
      &#x27;You must supply an Email.settings.transports containing a valid transport&#x27;);
    transport.sendMail(options, fn);
  } else {
    g.warn(&#x27;Warning: No email transport specified for sending email.&#x27; +
      &#x27; Setup a transport to send mail messages.&#x27;);
    process.nextTick(function() {
      fn(null, options);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.get(&#x27;/&#x27;, function(req, res){
*   res.<span class="apidocCodeKeywordSpan">send</span>(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
* @header var app = loopback()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Mail.prototype.DataAccessObject.prototype" id="apidoc.module.loopback.Mail.prototype.DataAccessObject.prototype">module loopback.Mail.prototype.DataAccessObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Mail.prototype.DataAccessObject.prototype.send" id="apidoc.element.loopback.Mail.prototype.DataAccessObject.prototype.send">
        function <span class="apidocSignatureSpan">loopback.Mail.prototype.DataAccessObject.prototype.</span>send
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (fn) {
  this.constructor.send(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.get(&#x27;/&#x27;, function(req, res){
*   res.<span class="apidocCodeKeywordSpan">send</span>(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
* @header var app = loopback()
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Memory" id="apidoc.module.loopback.Memory">module loopback.Memory</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Memory.Memory" id="apidoc.element.loopback.Memory.Memory">
        function <span class="apidocSignatureSpan">loopback.</span>Memory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Memory() {
  // TODO implement entire memory connector
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Memory.initialize" id="apidoc.element.loopback.Memory.initialize">
        function <span class="apidocSignatureSpan">loopback.Memory.</span>initialize
        <span class="apidocSignatureSpan">(dataSource, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initializeDataSource(dataSource, callback) {
  dataSource.connector = new Memory(null, dataSource.settings);
  // Use dataSource.connect to avoid duplicate file reads from cache
  dataSource.connect(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Memory.super_" id="apidoc.element.loopback.Memory.super_">
        function <span class="apidocSignatureSpan">loopback.Memory.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connector(options) {
  EventEmitter.apply(this, arguments);
  this.options = options;

  debug(&#x27;created with options&#x27;, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Remote" id="apidoc.module.loopback.Remote">module loopback.Remote</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Remote.Remote" id="apidoc.element.loopback.Remote.Remote">
        function <span class="apidocSignatureSpan">loopback.</span>Remote
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RemoteConnector(settings) {
  assert(typeof settings ===
    &#x27;object&#x27;,
    &#x27;cannot initiaze RemoteConnector without a settings object&#x27;);
  this.client = settings.client;
  this.adapter = settings.adapter || &#x27;rest&#x27;;
  this.protocol = settings.protocol || &#x27;http&#x27;;
  this.root = settings.root || &#x27;&#x27;;
  this.host = settings.host || &#x27;localhost&#x27;;
  this.port = settings.port || 3000;
  this.remotes = remoting.create();
  this.name = &#x27;remote-connector&#x27;;

  if (settings.url) {
    this.url = settings.url;
  } else {
    this.url = this.protocol + &#x27;://&#x27; + this.host + &#x27;:&#x27; + this.port + this.root;
  }

  // handle mixins in the define() method
  var DAO = this.DataAccessObject = function() {
  };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Remote.initialize" id="apidoc.element.loopback.Remote.initialize">
        function <span class="apidocSignatureSpan">loopback.Remote.</span>initialize
        <span class="apidocSignatureSpan">(dataSource, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialize = function (dataSource, callback) {
  var connector = dataSource.connector =
    new RemoteConnector(dataSource.settings);
  connector.connect();
  process.nextTick(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Remote.prototype" id="apidoc.module.loopback.Remote.prototype">module loopback.Remote.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Remote.prototype.connect" id="apidoc.element.loopback.Remote.prototype.connect">
        function <span class="apidocSignatureSpan">loopback.Remote.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  this.remotes.connect(this.url, this.adapter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Remote.prototype.define" id="apidoc.element.loopback.Remote.prototype.define">
        function <span class="apidocSignatureSpan">loopback.Remote.prototype.</span>define
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (definition) {
  var Model = definition.model;
  var remotes = this.remotes;

  assert(Model.sharedClass,
      &#x27;cannot attach &#x27; +
      Model.modelName +
      &#x27; to a remote connector without a Model.sharedClass&#x27;);

  jutil.mixin(Model, RelationMixin);
  jutil.mixin(Model, InclusionMixin);
  remotes.addClass(Model.sharedClass);
  this.resolve(Model);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @property {DataSource} Model.dataSource Data source to which the model is connected, if any. Static property.
 * @property {SharedClass} Model.sharedMethod The `strong-remoting` [SharedClass](http://apidocs.strongloop.com/strong-remoting/#
sharedclass) that contains remoting (and http) metadata. Static property.
 * @property {Object} settings Contains additional model settings.
 * @property {string} settings.http.path Base URL of the model HTTP route.
 * @property [{string}] settings.acls Array of ACLs for the model.
 * @class
 */
var Model = registry.modelBuilder.<span class="apidocCodeKeywordSpan">define</span>(&#x27;Model&#x27;);

Model.registry = registry;

/**
 * The `loopback.Model.extend()` method calls this when you create a model that extends another model.
 * Add any setup or configuration code you want executed when the model is created.
 * See  [Setting up a custom model](http://loopback.io/doc/en/lb2/Extending-built-in-models.html#setting-up-a-custom-model).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Remote.prototype.resolve" id="apidoc.element.loopback.Remote.prototype.resolve">
        function <span class="apidocSignatureSpan">loopback.Remote.prototype.</span>resolve
        <span class="apidocSignatureSpan">(Model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (Model) {
  var remotes = this.remotes;

  Model.sharedClass.methods().forEach(function(remoteMethod) {
    if (remoteMethod.name !== &#x27;Change&#x27; &#x26;&#x26; remoteMethod.name !== &#x27;Checkpoint&#x27;) {
      createProxyMethod(Model, remotes, remoteMethod);
    }
  });

  // setup a remoting type converter for this model
  remotes.defineObjectType(Model.modelName, function(data) {
    return new Model(data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },
},
mochaTest: {
  &#x27;unit&#x27;: {
    src: &#x27;test/*.js&#x27;,
    options: {
      reporter: &#x27;dot&#x27;,
      require: require.<span class="apidocCodeKeywordSpan">resolve</span>(&#x27;./test/helpers/use-english.js&#x27;),
    },
  },
  &#x27;unit-xml&#x27;: {
    src: &#x27;test/*.js&#x27;,
    options: {
      reporter: &#x27;xunit&#x27;,
      captureFile: &#x27;xunit.xml&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Role" id="apidoc.module.loopback.Role">module loopback.Role</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Role.Role" id="apidoc.element.loopback.Role.Role">
        function <span class="apidocSignatureSpan">loopback.</span>Role
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.ValidationError" id="apidoc.element.loopback.Role.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Role.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role._ACL" id="apidoc.element.loopback.Role._ACL">
        function <span class="apidocSignatureSpan">loopback.Role.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role._defineChangeModel" id="apidoc.element.loopback.Role._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.Role.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role._getAccessTypeForMethod" id="apidoc.element.loopback.Role._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Role.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role._notifyBaseObservers" id="apidoc.element.loopback.Role._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Role.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role._runWhenAttachedToApp" id="apidoc.element.loopback.Role._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Role.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.addListener" id="apidoc.element.loopback.Role.addListener">
        function <span class="apidocSignatureSpan">loopback.Role.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.afterRemote" id="apidoc.element.loopback.Role.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Role.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.afterRemoteError" id="apidoc.element.loopback.Role.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Role.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.attachTo" id="apidoc.element.loopback.Role.attachTo">
        function <span class="apidocSignatureSpan">loopback.Role.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.beforeRemote" id="apidoc.element.loopback.Role.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Role.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.belongsToRemoting" id="apidoc.element.loopback.Role.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Role.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.bulkUpdate" id="apidoc.element.loopback.Role.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.changes" id="apidoc.element.loopback.Role.changes">
        function <span class="apidocSignatureSpan">loopback.Role.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.checkAccess" id="apidoc.element.loopback.Role.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Role.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.checkpoint" id="apidoc.element.loopback.Role.checkpoint">
        function <span class="apidocSignatureSpan">loopback.Role.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.clearObservers" id="apidoc.element.loopback.Role.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Role.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.count" id="apidoc.element.loopback.Role.count">
        function <span class="apidocSignatureSpan">loopback.Role.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.create" id="apidoc.element.loopback.Role.create">
        function <span class="apidocSignatureSpan">loopback.Role.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.createChangeFilter" id="apidoc.element.loopback.Role.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.Role.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.createChangeStream" id="apidoc.element.loopback.Role.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.Role.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.createOptionsFromRemotingContext" id="apidoc.element.loopback.Role.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Role.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.createUpdates" id="apidoc.element.loopback.Role.createUpdates">
        function <span class="apidocSignatureSpan">loopback.Role.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.currentCheckpoint" id="apidoc.element.loopback.Role.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.Role.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.defineProperty" id="apidoc.element.loopback.Role.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Role.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.deleteAll" id="apidoc.element.loopback.Role.deleteAll">
        function <span class="apidocSignatureSpan">loopback.Role.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.deleteById" id="apidoc.element.loopback.Role.deleteById">
        function <span class="apidocSignatureSpan">loopback.Role.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.destroyAll" id="apidoc.element.loopback.Role.destroyAll">
        function <span class="apidocSignatureSpan">loopback.Role.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.destroyById" id="apidoc.element.loopback.Role.destroyById">
        function <span class="apidocSignatureSpan">loopback.Role.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.diff" id="apidoc.element.loopback.Role.diff">
        function <span class="apidocSignatureSpan">loopback.Role.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.disableRemoteMethod" id="apidoc.element.loopback.Role.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Role.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.disableRemoteMethodByName" id="apidoc.element.loopback.Role.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Role.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.emit" id="apidoc.element.loopback.Role.emit">
        function <span class="apidocSignatureSpan">loopback.Role.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.enableChangeTracking" id="apidoc.element.loopback.Role.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.Role.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.eventNames" id="apidoc.element.loopback.Role.eventNames">
        function <span class="apidocSignatureSpan">loopback.Role.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.exists" id="apidoc.element.loopback.Role.exists">
        function <span class="apidocSignatureSpan">loopback.Role.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.extend" id="apidoc.element.loopback.Role.extend">
        function <span class="apidocSignatureSpan">loopback.Role.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.find" id="apidoc.element.loopback.Role.find">
        function <span class="apidocSignatureSpan">loopback.Role.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.findById" id="apidoc.element.loopback.Role.findById">
        function <span class="apidocSignatureSpan">loopback.Role.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Role.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.findLastChange" id="apidoc.element.loopback.Role.findLastChange">
        function <span class="apidocSignatureSpan">loopback.Role.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.findOne" id="apidoc.element.loopback.Role.findOne">
        function <span class="apidocSignatureSpan">loopback.Role.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.findOrCreate" id="apidoc.element.loopback.Role.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.forEachProperty" id="apidoc.element.loopback.Role.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Role.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getApp" id="apidoc.element.loopback.Role.getApp">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getChangeModel" id="apidoc.element.loopback.Role.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getDataSource" id="apidoc.element.loopback.Role.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getIdName" id="apidoc.element.loopback.Role.getIdName">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getMaxListeners" id="apidoc.element.loopback.Role.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getPropertyType" id="apidoc.element.loopback.Role.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getRoles" id="apidoc.element.loopback.Role.getRoles">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getRoles
        <span class="apidocSignatureSpan">(context, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRoles = function (context, options, callback) {
  if (!callback) {
    if (typeof options === &#x27;function&#x27;) {
      callback = options;
      options = {};
    } else {
      callback = utils.createPromiseCallback();
    }
  }
  if (!options) options = {};

  context.registry = this.registry;
  if (!(context instanceof AccessContext)) {
    context = new AccessContext(context);
  }
  var roles = [];
  this.resolveRelatedModels();

  var addRole = function(role) {
    if (role &#x26;&#x26; roles.indexOf(role) === -1) {
      roles.push(role);
    }
  };

  var self = this;
  // Check against the smart roles
  var inRoleTasks = [];
  Object.keys(Role.resolvers).forEach(function(role) {
    inRoleTasks.push(function(done) {
      self.isInRole(role, context, function(err, inRole) {
        if (debug.enabled) {
          debug(&#x27;In role %j: %j&#x27;, role, inRole);
        }
        if (!err &#x26;&#x26; inRole) {
          addRole(role);
          done();
        } else {
          done(err, null);
        }
      });
    });
  });

  var roleMappingModel = this.roleMappingModel;
  context.principals.forEach(function(p) {
    // Check against the role mappings
    var principalType = p.type || undefined;
    var principalId = p.id == null ? undefined : p.id;

    if (typeof principalId !== &#x27;string&#x27; &#x26;&#x26; principalId != null) {
      principalId = principalId.toString();
    }

    // Add the role itself
    if (principalType === RoleMapping.ROLE &#x26;&#x26; principalId) {
      addRole(principalId);
    }

    if (principalType &#x26;&#x26; principalId) {
      // Please find() treat undefined matches all values
      inRoleTasks.push(function(done) {
        var filter = {where: {principalType: principalType, principalId: principalId}};
        if (options.returnOnlyRoleNames === true) {
          filter.include = [&#x27;role&#x27;];
        }
        roleMappingModel.find(filter, function(err, mappings) {
          debug(&#x27;Role mappings found: %s %j&#x27;, err, mappings);
          if (err) {
            if (done) done(err);
            return;
          }
          mappings.forEach(function(m) {
            var role;
            if (options.returnOnlyRoleNames === true) {
              role = m.toJSON().role.name;
            } else {
              role = m.roleId;
            }
            addRole(role);
          });
          if (done) done();
        });
      });
    }
  });

  async.parallel(inRoleTasks, function(err, results) {
    debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
    if (callback) callback(err, roles);
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.getSourceId" id="apidoc.element.loopback.Role.getSourceId">
        function <span class="apidocSignatureSpan">loopback.Role.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.handleChangeError" id="apidoc.element.loopback.Role.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.Role.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.hasManyRemoting" id="apidoc.element.loopback.Role.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Role.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.hasOneRemoting" id="apidoc.element.loopback.Role.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Role.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.isAuthenticated" id="apidoc.element.loopback.Role.isAuthenticated">
        function <span class="apidocSignatureSpan">loopback.Role.</span>isAuthenticated
        <span class="apidocSignatureSpan">(context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAuthenticated(context, callback) {
  if (!callback) callback = utils.createPromiseCallback();
  process.nextTick(function() {
    if (callback) callback(null, context.isAuthenticated());
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   debug(&#x27;accessType %s&#x27;, this.accessType);
   if (this.accessToken) {
     debug(&#x27;accessToken:&#x27;);
     debug(&#x27;  id %j&#x27;, this.accessToken.id);
     debug(&#x27;  ttl %j&#x27;, this.accessToken.ttl);
   }
   debug(&#x27;getUserId() %s&#x27;, this.getUserId());
   debug(&#x27;isAuthenticated() %s&#x27;, this.<span class="apidocCodeKeywordSpan">isAuthenticated</span>());
 }
};

/**
* This class represents the abstract notion of a principal, which can be used
* to represent any entity, such as an individual, a corporation, and a login id
* @param {String} type The principal type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.isHiddenProperty" id="apidoc.element.loopback.Role.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Role.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.isInRole" id="apidoc.element.loopback.Role.isInRole">
        function <span class="apidocSignatureSpan">loopback.Role.</span>isInRole
        <span class="apidocSignatureSpan">(role, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInRole = function (role, context, callback) {
  context.registry = this.registry;
  if (!(context instanceof AccessContext)) {
    context = new AccessContext(context);
  }

  if (!callback) {
    callback = utils.createPromiseCallback();
    // historically, isInRole is returning the Role instance instead of true
    // we are preserving that behaviour for callback-based invocation,
    // but fixing it when invoked in Promise mode
    callback.promise = callback.promise.then(function(isInRole) {
      return !!isInRole;
    });
  }

  this.resolveRelatedModels();

  debug(&#x27;isInRole(): %s&#x27;, role);
  context.debug();

  var resolver = Role.resolvers[role];
  if (resolver) {
    debug(&#x27;Custom resolver found for role %s&#x27;, role);

    var promise = resolver(role, context, callback);
    if (promise &#x26;&#x26; typeof promise.then === &#x27;function&#x27;) {
      promise.then(
        function(result) { callback(null, result); },
        callback
      );
    }
    return callback.promise;
  }

  if (context.principals.length === 0) {
    debug(&#x27;isInRole() returns: false&#x27;);
    process.nextTick(function() {
      if (callback) callback(null, false);
    });
    return callback.promise;
  }

  var inRole = context.principals.some(function(p) {
    var principalType = p.type || undefined;
    var principalId = p.id || undefined;

    // Check if it&#x27;s the same role
    return principalType === RoleMapping.ROLE &#x26;&#x26; principalId === role;
  });

  if (inRole) {
    debug(&#x27;isInRole() returns: %j&#x27;, inRole);
    process.nextTick(function() {
      if (callback) callback(null, true);
    });
    return callback.promise;
  }

  var roleMappingModel = this.roleMappingModel;
  this.findOne({where: {name: role}}, function(err, result) {
    if (err) {
      if (callback) callback(err);
      return;
    }
    if (!result) {
      if (callback) callback(null, false);
      return;
    }
    debug(&#x27;Role found: %j&#x27;, result);

    // Iterate through the list of principals
    async.some(context.principals, function(p, done) {
      var principalType = p.type || undefined;
      var principalId = p.id || undefined;
      var roleId = result.id.toString();
      var principalIdIsString = typeof principalId === &#x27;string&#x27;;

      if (principalId !== null &#x26;&#x26; principalId !== undefined &#x26;&#x26; !principalIdIsString) {
        principalId = principalId.toString();
      }

      if (principalType &#x26;&#x26; principalId) {
        roleMappingModel.findOne({where: {roleId: roleId,
          principalType: principalType, principalId: principalId}},
          function(err, result) {
            debug(&#x27;Role mapping found: %j&#x27;, result);
            done(!err &#x26;&#x26; result); // The only arg is the result
          });
      } else {
        process.nextTick(function() {
          done(false);
        });
      }
    }, function(inRole) {
      debug(&#x27;isInRole() returns: %j&#x27;, inRole);
      if (callback) callback(null, inRole);
    });
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
}

// Check role matches
if (acl.principalType === ACL.ROLE) {
  inRoleTasks.push(function(done) {
    roleModel.<span class="apidocCodeKeywordSpan">isInRole</span>(acl.principalId, context,
      function(err, inRole) {
        if (!err &#x26;&#x26; inRole) {
          effectiveACLs.push(acl);
          // add the role to authorizedRoles if allowed
          if (acl.isAllowed(modelDefaultPermission))
            authorizedRoles[acl.principalId] = true;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.isOwner" id="apidoc.element.loopback.Role.isOwner">
        function <span class="apidocSignatureSpan">loopback.Role.</span>isOwner
        <span class="apidocSignatureSpan">(modelClass, modelId, userId, principalType, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOwner(modelClass, modelId, userId, principalType, options, callback) {
  if (!callback &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (!callback &#x26;&#x26; typeof principalType === &#x27;function&#x27;) {
    callback = principalType;
    principalType = undefined;
    options = {};
  }
  principalType = principalType || Principal.USER;

  assert(modelClass, &#x27;Model class is required&#x27;);
  if (!callback) callback = utils.createPromiseCallback();

  debug(&#x27;isOwner(): %s %s userId: %s principalType: %s&#x27;,
    modelClass &#x26;&#x26; modelClass.modelName, modelId, userId, principalType);

  // Return false if userId is missing
  if (!userId) {
    process.nextTick(function() {
      callback(null, false);
    });
    return callback.promise;
  }

  // Is the modelClass User or a subclass of User?
  if (isUserClass(modelClass)) {
    var userModelName = modelClass.modelName;
    // matching ids is enough if principalType is USER or matches given user model name
    if (principalType === Principal.USER || principalType === userModelName) {
      process.nextTick(function() {
        callback(null, matches(modelId, userId));
      });
    }
    return callback.promise;
  }

  modelClass.findById(modelId, options, function(err, inst) {
    if (err || !inst) {
      debug(&#x27;Model not found for id %j&#x27;, modelId);
      return callback(err, false);
    }
    debug(&#x27;Model found: %j&#x27;, inst);

    // Historically, for principalType USER, we were resolving isOwner()
    // as true if the model has &#x22;userId&#x22; or &#x22;owner&#x22; property matching
    // id of the current user (principalId), even though there was no
    // belongsTo relation set up.
    var ownerId = inst.userId || inst.owner;
    if (principalType === Principal.USER &#x26;&#x26; ownerId &#x26;&#x26; &#x27;function&#x27; !== typeof ownerId) {
      return callback(null, matches(ownerId, userId));
    }

    // Try to follow belongsTo
    for (var r in modelClass.relations) {
      var rel = modelClass.relations[r];
      // relation should be belongsTo and target a User based class
      var belongsToUser = rel.type === &#x27;belongsTo&#x27; &#x26;&#x26; isUserClass(rel.modelTo);
      if (!belongsToUser) {
        continue;
      }
      // checking related user
      var userModelName = rel.modelTo.modelName;
      if (principalType === Principal.USER || principalType === userModelName) {
        debug(&#x27;Checking relation %s to %s: %j&#x27;, r, userModelName, rel);
        inst[r](processRelatedUser);
        return;
      }
    }
    debug(&#x27;No matching belongsTo relation found for model %j - user %j principalType %j&#x27;,
      modelId, userId, principalType);
    callback(null, false);

    function processRelatedUser(err, user) {
      if (!err &#x26;&#x26; user) {
        debug(&#x27;User found: %j&#x27;, user.id);
        callback(null, matches(user.id, userId));
      } else {
        callback(err, false);
      }
    }
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  var modelClass = context.model;
  var modelId = context.modelId;
  var user = context.getUser();
  var userId = user &#x26;&#x26; user.id;
  var principalType = user &#x26;&#x26; user.principalType;
  var opts = {accessToken: context.accessToken};
  Role.<span class="apidocCodeKeywordSpan">isOwner</span>(modelClass, modelId, userId, principalType, opts, callback);
});

function isUserClass(modelClass) {
  if (!modelClass) return false;
  var User = modelClass.modelBuilder.models.User;
  if (!User) return false;
  return modelClass == User || modelClass.prototype instanceof User;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.isProtectedProperty" id="apidoc.element.loopback.Role.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Role.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.listenerCount" id="apidoc.element.loopback.Role.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Role.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.listeners" id="apidoc.element.loopback.Role.listeners">
        function <span class="apidocSignatureSpan">loopback.Role.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.mixin" id="apidoc.element.loopback.Role.mixin">
        function <span class="apidocSignatureSpan">loopback.Role.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.nestRemoting" id="apidoc.element.loopback.Role.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Role.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.notifyObserversAround" id="apidoc.element.loopback.Role.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Role.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.notifyObserversOf" id="apidoc.element.loopback.Role.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.observe" id="apidoc.element.loopback.Role.observe">
        function <span class="apidocSignatureSpan">loopback.Role.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.on" id="apidoc.element.loopback.Role.on">
        function <span class="apidocSignatureSpan">loopback.Role.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.once" id="apidoc.element.loopback.Role.once">
        function <span class="apidocSignatureSpan">loopback.Role.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.patchOrCreate" id="apidoc.element.loopback.Role.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.patchOrCreateWithWhere" id="apidoc.element.loopback.Role.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.Role.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.prependListener" id="apidoc.element.loopback.Role.prependListener">
        function <span class="apidocSignatureSpan">loopback.Role.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.prependOnceListener" id="apidoc.element.loopback.Role.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Role.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.rectifyAllChanges" id="apidoc.element.loopback.Role.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.Role.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.rectifyChange" id="apidoc.element.loopback.Role.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.Role.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.registerProperty" id="apidoc.element.loopback.Role.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Role.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.registerResolver" id="apidoc.element.loopback.Role.registerResolver">
        function <span class="apidocSignatureSpan">loopback.Role.</span>registerResolver
        <span class="apidocSignatureSpan">(role, resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerResolver = function (role, resolver) {
  if (!Role.resolvers) {
    Role.resolvers = {};
  }
  Role.resolvers[role] = resolver;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Role.registerResolver = function(role, resolver) {
  if (!Role.resolvers) {
    Role.resolvers = {};
  }
  Role.resolvers[role] = resolver;
};

Role.<span class="apidocCodeKeywordSpan">registerResolver</span>(Role.OWNER, function(role, context, callback) {
  if (!context || !context.model || !context.modelId) {
    process.nextTick(function() {
      if (callback) callback(null, false);
    });
    return;
  }
  var modelClass = context.model;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.remoteMethod" id="apidoc.element.loopback.Role.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Role.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.remove" id="apidoc.element.loopback.Role.remove">
        function <span class="apidocSignatureSpan">loopback.Role.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.removeAllListeners" id="apidoc.element.loopback.Role.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Role.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.removeById" id="apidoc.element.loopback.Role.removeById">
        function <span class="apidocSignatureSpan">loopback.Role.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.removeListener" id="apidoc.element.loopback.Role.removeListener">
        function <span class="apidocSignatureSpan">loopback.Role.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.removeObserver" id="apidoc.element.loopback.Role.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Role.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.replaceById" id="apidoc.element.loopback.Role.replaceById">
        function <span class="apidocSignatureSpan">loopback.Role.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.replaceOrCreate" id="apidoc.element.loopback.Role.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.replicate" id="apidoc.element.loopback.Role.replicate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.resolveRelatedModels" id="apidoc.element.loopback.Role.resolveRelatedModels">
        function <span class="apidocSignatureSpan">loopback.Role.</span>resolveRelatedModels
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveRelatedModels = function () {
  if (!this.userModel) {
    var reg = this.registry;
    this.roleMappingModel = reg.getModelByType(&#x27;RoleMapping&#x27;);
    this.userModel = reg.getModelByType(&#x27;User&#x27;);
    this.applicationModel = reg.getModelByType(&#x27;Application&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @callback {Function} callback Callback function
   * @param {String|Error} err The error object.
   * @param {AccessRequest} result The resolved access request.
   */
  ACL.checkAccessForContext = function(context, callback) {
if (!callback) callback = utils.createPromiseCallback();
var self = this;
self.<span class="apidocCodeKeywordSpan">resolveRelatedModels</span>();
var roleModel = self.roleModel;

if (!(context instanceof AccessContext)) {
  context.registry = this.registry;
  context = new AccessContext(context);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.scopeRemoting" id="apidoc.element.loopback.Role.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Role.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.setMaxListeners" id="apidoc.element.loopback.Role.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Role.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.setup" id="apidoc.element.loopback.Role.setup">
        function <span class="apidocSignatureSpan">loopback.Role.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.setupRemoting" id="apidoc.element.loopback.Role.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.Role.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.sharedCtor" id="apidoc.element.loopback.Role.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Role.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Role.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Role.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.super_" id="apidoc.element.loopback.Role.super_">
        function <span class="apidocSignatureSpan">loopback.Role.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.update" id="apidoc.element.loopback.Role.update">
        function <span class="apidocSignatureSpan">loopback.Role.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.updateAll" id="apidoc.element.loopback.Role.updateAll">
        function <span class="apidocSignatureSpan">loopback.Role.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.updateLastChange" id="apidoc.element.loopback.Role.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.Role.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.updateOrCreate" id="apidoc.element.loopback.Role.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.upsert" id="apidoc.element.loopback.Role.upsert">
        function <span class="apidocSignatureSpan">loopback.Role.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.upsertWithWhere" id="apidoc.element.loopback.Role.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.Role.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validate" id="apidoc.element.loopback.Role.validate">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validateAsync" id="apidoc.element.loopback.Role.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesAbsenceOf" id="apidoc.element.loopback.Role.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesExclusionOf" id="apidoc.element.loopback.Role.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesFormatOf" id="apidoc.element.loopback.Role.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesInclusionOf" id="apidoc.element.loopback.Role.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesLengthOf" id="apidoc.element.loopback.Role.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesNumericalityOf" id="apidoc.element.loopback.Role.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesPresenceOf" id="apidoc.element.loopback.Role.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Role.validatesUniquenessOf" id="apidoc.element.loopback.Role.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Role.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>
















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Role.resolvers" id="apidoc.module.loopback.Role.resolvers">module loopback.Role.resolvers</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Role.settings" id="apidoc.module.loopback.Role.settings">module loopback.Role.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.Role.settings.base" id="apidoc.element.loopback.Role.settings.base">
        function <span class="apidocSignatureSpan">loopback.Role.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Role.sharedClass" id="apidoc.module.loopback.Role.sharedClass">module loopback.Role.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Role.sharedClass.ctor" id="apidoc.element.loopback.Role.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.Role.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.RoleMapping" id="apidoc.module.loopback.RoleMapping">module loopback.RoleMapping</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.RoleMapping" id="apidoc.element.loopback.RoleMapping.RoleMapping">
        function <span class="apidocSignatureSpan">loopback.</span>RoleMapping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.ValidationError" id="apidoc.element.loopback.RoleMapping.ValidationError">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping._ACL" id="apidoc.element.loopback.RoleMapping._ACL">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping._defineChangeModel" id="apidoc.element.loopback.RoleMapping._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping._getAccessTypeForMethod" id="apidoc.element.loopback.RoleMapping._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping._notifyBaseObservers" id="apidoc.element.loopback.RoleMapping._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping._runWhenAttachedToApp" id="apidoc.element.loopback.RoleMapping._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.addListener" id="apidoc.element.loopback.RoleMapping.addListener">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.afterRemote" id="apidoc.element.loopback.RoleMapping.afterRemote">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.afterRemoteError" id="apidoc.element.loopback.RoleMapping.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.attachTo" id="apidoc.element.loopback.RoleMapping.attachTo">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.beforeRemote" id="apidoc.element.loopback.RoleMapping.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.belongsToRemoting" id="apidoc.element.loopback.RoleMapping.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.bulkUpdate" id="apidoc.element.loopback.RoleMapping.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.changes" id="apidoc.element.loopback.RoleMapping.changes">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.checkAccess" id="apidoc.element.loopback.RoleMapping.checkAccess">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.checkpoint" id="apidoc.element.loopback.RoleMapping.checkpoint">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.clearObservers" id="apidoc.element.loopback.RoleMapping.clearObservers">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.count" id="apidoc.element.loopback.RoleMapping.count">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.create" id="apidoc.element.loopback.RoleMapping.create">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.createChangeFilter" id="apidoc.element.loopback.RoleMapping.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.createChangeStream" id="apidoc.element.loopback.RoleMapping.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.createOptionsFromRemotingContext" id="apidoc.element.loopback.RoleMapping.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.createUpdates" id="apidoc.element.loopback.RoleMapping.createUpdates">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.currentCheckpoint" id="apidoc.element.loopback.RoleMapping.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.defineProperty" id="apidoc.element.loopback.RoleMapping.defineProperty">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.deleteAll" id="apidoc.element.loopback.RoleMapping.deleteAll">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.deleteById" id="apidoc.element.loopback.RoleMapping.deleteById">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.destroyAll" id="apidoc.element.loopback.RoleMapping.destroyAll">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.destroyById" id="apidoc.element.loopback.RoleMapping.destroyById">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.diff" id="apidoc.element.loopback.RoleMapping.diff">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.disableRemoteMethod" id="apidoc.element.loopback.RoleMapping.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.disableRemoteMethodByName" id="apidoc.element.loopback.RoleMapping.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.emit" id="apidoc.element.loopback.RoleMapping.emit">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.enableChangeTracking" id="apidoc.element.loopback.RoleMapping.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.eventNames" id="apidoc.element.loopback.RoleMapping.eventNames">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.exists" id="apidoc.element.loopback.RoleMapping.exists">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.extend" id="apidoc.element.loopback.RoleMapping.extend">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.find" id="apidoc.element.loopback.RoleMapping.find">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.findById" id="apidoc.element.loopback.RoleMapping.findById">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.RoleMapping.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.findLastChange" id="apidoc.element.loopback.RoleMapping.findLastChange">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.findOne" id="apidoc.element.loopback.RoleMapping.findOne">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.findOrCreate" id="apidoc.element.loopback.RoleMapping.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.forEachProperty" id="apidoc.element.loopback.RoleMapping.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getApp" id="apidoc.element.loopback.RoleMapping.getApp">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getChangeModel" id="apidoc.element.loopback.RoleMapping.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getDataSource" id="apidoc.element.loopback.RoleMapping.getDataSource">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getIdName" id="apidoc.element.loopback.RoleMapping.getIdName">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getMaxListeners" id="apidoc.element.loopback.RoleMapping.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getPropertyType" id="apidoc.element.loopback.RoleMapping.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.getSourceId" id="apidoc.element.loopback.RoleMapping.getSourceId">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.handleChangeError" id="apidoc.element.loopback.RoleMapping.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.hasManyRemoting" id="apidoc.element.loopback.RoleMapping.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.hasOneRemoting" id="apidoc.element.loopback.RoleMapping.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.isHiddenProperty" id="apidoc.element.loopback.RoleMapping.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.isProtectedProperty" id="apidoc.element.loopback.RoleMapping.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.listenerCount" id="apidoc.element.loopback.RoleMapping.listenerCount">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.listeners" id="apidoc.element.loopback.RoleMapping.listeners">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.mixin" id="apidoc.element.loopback.RoleMapping.mixin">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.nestRemoting" id="apidoc.element.loopback.RoleMapping.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.notifyObserversAround" id="apidoc.element.loopback.RoleMapping.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.notifyObserversOf" id="apidoc.element.loopback.RoleMapping.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.observe" id="apidoc.element.loopback.RoleMapping.observe">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.on" id="apidoc.element.loopback.RoleMapping.on">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.once" id="apidoc.element.loopback.RoleMapping.once">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.patchOrCreate" id="apidoc.element.loopback.RoleMapping.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.patchOrCreateWithWhere" id="apidoc.element.loopback.RoleMapping.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.prependListener" id="apidoc.element.loopback.RoleMapping.prependListener">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.prependOnceListener" id="apidoc.element.loopback.RoleMapping.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.rectifyAllChanges" id="apidoc.element.loopback.RoleMapping.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.rectifyChange" id="apidoc.element.loopback.RoleMapping.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.registerProperty" id="apidoc.element.loopback.RoleMapping.registerProperty">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.remoteMethod" id="apidoc.element.loopback.RoleMapping.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.remove" id="apidoc.element.loopback.RoleMapping.remove">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.removeAllListeners" id="apidoc.element.loopback.RoleMapping.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.removeById" id="apidoc.element.loopback.RoleMapping.removeById">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.removeListener" id="apidoc.element.loopback.RoleMapping.removeListener">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.removeObserver" id="apidoc.element.loopback.RoleMapping.removeObserver">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.replaceById" id="apidoc.element.loopback.RoleMapping.replaceById">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.replaceOrCreate" id="apidoc.element.loopback.RoleMapping.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.replicate" id="apidoc.element.loopback.RoleMapping.replicate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.resolveRelatedModels" id="apidoc.element.loopback.RoleMapping.resolveRelatedModels">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>resolveRelatedModels
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveRelatedModels = function () {
  if (!this.userModel) {
    var reg = this.registry;
    this.roleModel = reg.getModelByType(&#x27;Role&#x27;);
    this.userModel = reg.getModelByType(&#x27;User&#x27;);
    this.applicationModel = reg.getModelByType(&#x27;Application&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @callback {Function} callback Callback function
   * @param {String|Error} err The error object.
   * @param {AccessRequest} result The resolved access request.
   */
  ACL.checkAccessForContext = function(context, callback) {
if (!callback) callback = utils.createPromiseCallback();
var self = this;
self.<span class="apidocCodeKeywordSpan">resolveRelatedModels</span>();
var roleModel = self.roleModel;

if (!(context instanceof AccessContext)) {
  context.registry = this.registry;
  context = new AccessContext(context);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.scopeRemoting" id="apidoc.element.loopback.RoleMapping.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.setMaxListeners" id="apidoc.element.loopback.RoleMapping.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.setup" id="apidoc.element.loopback.RoleMapping.setup">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.setupRemoting" id="apidoc.element.loopback.RoleMapping.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.sharedCtor" id="apidoc.element.loopback.RoleMapping.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.RoleMapping.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.RoleMapping.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.super_" id="apidoc.element.loopback.RoleMapping.super_">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.update" id="apidoc.element.loopback.RoleMapping.update">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.updateAll" id="apidoc.element.loopback.RoleMapping.updateAll">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.updateLastChange" id="apidoc.element.loopback.RoleMapping.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.updateOrCreate" id="apidoc.element.loopback.RoleMapping.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.upsert" id="apidoc.element.loopback.RoleMapping.upsert">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.upsertWithWhere" id="apidoc.element.loopback.RoleMapping.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validate" id="apidoc.element.loopback.RoleMapping.validate">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validateAsync" id="apidoc.element.loopback.RoleMapping.validateAsync">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesAbsenceOf" id="apidoc.element.loopback.RoleMapping.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesExclusionOf" id="apidoc.element.loopback.RoleMapping.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesFormatOf" id="apidoc.element.loopback.RoleMapping.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesInclusionOf" id="apidoc.element.loopback.RoleMapping.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesLengthOf" id="apidoc.element.loopback.RoleMapping.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesNumericalityOf" id="apidoc.element.loopback.RoleMapping.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesPresenceOf" id="apidoc.element.loopback.RoleMapping.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.validatesUniquenessOf" id="apidoc.element.loopback.RoleMapping.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>












































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.RoleMapping.prototype" id="apidoc.module.loopback.RoleMapping.prototype">module loopback.RoleMapping.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.prototype.application" id="apidoc.element.loopback.RoleMapping.prototype.application">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.prototype.</span>application
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">application = function (callback) {
  callback = callback || utils.createPromiseCallback();
  this.constructor.resolveRelatedModels();

  if (this.principalType === RoleMapping.APPLICATION) {
    var applicationModel = this.constructor.applicationModel;
    applicationModel.findById(this.principalId, callback);
  } else {
    process.nextTick(function() {
      callback(null, null);
    });
  }
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.prototype.childRole" id="apidoc.element.loopback.RoleMapping.prototype.childRole">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.prototype.</span>childRole
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childRole = function (callback) {
  callback = callback || utils.createPromiseCallback();
  this.constructor.resolveRelatedModels();

  if (this.principalType === RoleMapping.ROLE) {
    var roleModel = this.constructor.roleModel;
    roleModel.findById(this.principalId, callback);
  } else {
    process.nextTick(function() {
      callback(null, null);
    });
  }
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.prototype.user" id="apidoc.element.loopback.RoleMapping.prototype.user">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.prototype.</span>user
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">user = function (callback) {
  callback = callback || utils.createPromiseCallback();
  this.constructor.resolveRelatedModels();
  var userModel;

  if (this.principalType === RoleMapping.USER) {
    userModel = this.constructor.userModel;
    userModel.findById(this.principalId, callback);
    return callback.promise;
  }

  // try resolving a user model that matches principalType
  userModel = this.constructor.registry.findModel(this.principalType);
  if (userModel) {
    userModel.findById(this.principalId, callback);
  } else {
    process.nextTick(function() {
      callback(null, null);
    });
  }
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.RoleMapping.settings" id="apidoc.module.loopback.RoleMapping.settings">module loopback.RoleMapping.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.settings.base" id="apidoc.element.loopback.RoleMapping.settings.base">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.RoleMapping.sharedClass" id="apidoc.module.loopback.RoleMapping.sharedClass">module loopback.RoleMapping.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.RoleMapping.sharedClass.ctor" id="apidoc.element.loopback.RoleMapping.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.RoleMapping.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Route" id="apidoc.module.loopback.Route">module loopback.Route</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Route.Route" id="apidoc.element.loopback.Route.Route">
        function <span class="apidocSignatureSpan">loopback.</span>Route
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Route(path) {
  this.path = path;
  this.stack = [];

  debug(&#x27;new %o&#x27;, path)

  // route handlers for various http methods
  this.methods = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Route.prototype" id="apidoc.module.loopback.Route.prototype">module loopback.Route.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Route.prototype._handles_method" id="apidoc.element.loopback.Route.prototype._handles_method">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>_handles_method
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  var name = method.toLowerCase();

  if (name === &#x27;head&#x27; &#x26;&#x26; !this.methods[&#x27;head&#x27;]) {
    name = &#x27;get&#x27;;
  }

  return Boolean(this.methods[name]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype._options" id="apidoc.element.loopback.Route.prototype._options">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>_options
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _options() {
  var methods = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get &#x26;&#x26; !this.methods.head) {
    methods.push(&#x27;head&#x27;);
  }

  for (var i = 0; i &#x3c; methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.acl" id="apidoc.element.loopback.Route.prototype.acl">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>acl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acl = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.all" id="apidoc.element.loopback.Route.prototype.all">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all() {
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.all() requires callback functions but got a &#x27; + type;
      throw new TypeError(msg);
    }

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.bind" id="apidoc.element.loopback.Route.prototype.bind">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>bind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  accepts: [
    {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
    {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
  ],
  description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
  accessType: &#x27;READ&#x27;,
  returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
  rest: {after: convertNullToNotFoundError.<span class="apidocCodeKeywordSpan">bind</span>(null, toModelName)},
});

define(&#x27;__create__&#x27; + relationName, {
  isStatic: false,
  http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
  accepts: [
    {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.checkout" id="apidoc.element.loopback.Route.prototype.checkout">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>checkout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkout = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.connect" id="apidoc.element.loopback.Route.prototype.connect">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.copy" id="apidoc.element.loopback.Route.prototype.copy">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.delete" id="apidoc.element.loopback.Route.prototype.delete">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>delete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.dispatch" id="apidoc.element.loopback.Route.prototype.dispatch">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(req, res, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dispatch(req, res, done) {
  var idx = 0;
  var stack = this.stack;
  if (stack.length === 0) {
    return done();
  }

  var method = req.method.toLowerCase();
  if (method === &#x27;head&#x27; &#x26;&#x26; !this.methods[&#x27;head&#x27;]) {
    method = &#x27;get&#x27;;
  }

  req.route = this;

  next();

  function next(err) {
    // signal to exit route
    if (err &#x26;&#x26; err === &#x27;route&#x27;) {
      return done();
    }

    // signal to exit router
    if (err &#x26;&#x26; err === &#x27;router&#x27;) {
      return done(err)
    }

    var layer = stack[idx++];
    if (!layer) {
      return done(err);
    }

    if (layer.method &#x26;&#x26; layer.method !== method) {
      return next(err);
    }

    if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.get" id="apidoc.element.loopback.Route.prototype.get">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* supports Express middleware. See
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/&#x27;, function(req, res){
*   res.send(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.head" id="apidoc.element.loopback.Route.prototype.head">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>head
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.link" id="apidoc.element.loopback.Route.prototype.link">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>link
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.lock" id="apidoc.element.loopback.Route.prototype.lock">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>lock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.m-search" id="apidoc.element.loopback.Route.prototype.m-search">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>m-search
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">m-search = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.merge" id="apidoc.element.loopback.Route.prototype.merge">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.mkactivity" id="apidoc.element.loopback.Route.prototype.mkactivity">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>mkactivity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkactivity = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.mkcalendar" id="apidoc.element.loopback.Route.prototype.mkcalendar">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>mkcalendar
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkcalendar = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.mkcol" id="apidoc.element.loopback.Route.prototype.mkcol">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>mkcol
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkcol = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.move" id="apidoc.element.loopback.Route.prototype.move">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>move
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.notify" id="apidoc.element.loopback.Route.prototype.notify">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>notify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notify = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.options" id="apidoc.element.loopback.Route.prototype.options">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>options
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">options = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.patch" id="apidoc.element.loopback.Route.prototype.patch">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>patch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patch = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.post" id="apidoc.element.loopback.Route.prototype.post">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>post
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.propfind" id="apidoc.element.loopback.Route.prototype.propfind">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>propfind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propfind = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.proppatch" id="apidoc.element.loopback.Route.prototype.proppatch">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>proppatch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">proppatch = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.purge" id="apidoc.element.loopback.Route.prototype.purge">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>purge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.put" id="apidoc.element.loopback.Route.prototype.put">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>put
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.rebind" id="apidoc.element.loopback.Route.prototype.rebind">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>rebind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebind = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.report" id="apidoc.element.loopback.Route.prototype.report">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>report
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.search" id="apidoc.element.loopback.Route.prototype.search">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>search
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.subscribe" id="apidoc.element.loopback.Route.prototype.subscribe">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>subscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.trace" id="apidoc.element.loopback.Route.prototype.trace">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>trace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.unbind" id="apidoc.element.loopback.Route.prototype.unbind">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unbind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.unlink" id="apidoc.element.loopback.Route.prototype.unlink">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unlink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.unlock" id="apidoc.element.loopback.Route.prototype.unlock">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Route.prototype.unsubscribe" id="apidoc.element.loopback.Route.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">loopback.Route.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (){
  var handles = flatten(slice.call(arguments));

  for (var i = 0; i &#x3c; handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== &#x27;function&#x27;) {
      var type = toString.call(handle);
      var msg = &#x27;Route.&#x27; + method + &#x27;() requires callback functions but got a &#x27; + type;
      throw new Error(msg);
    }

    debug(&#x27;%s %o&#x27;, method, this.path)

    var layer = Layer(&#x27;/&#x27;, {}, handle);
    layer.method = method;

    this.methods[method] = true;
    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Router" id="apidoc.module.loopback.Router">module loopback.Router</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Router.Router" id="apidoc.element.loopback.Router.Router">
        function <span class="apidocSignatureSpan">loopback.</span>Router
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.acl" id="apidoc.element.loopback.Router.acl">
        function <span class="apidocSignatureSpan">loopback.Router.</span>acl
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acl = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.all" id="apidoc.element.loopback.Router.all">
        function <span class="apidocSignatureSpan">loopback.Router.</span>all
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.bind" id="apidoc.element.loopback.Router.bind">
        function <span class="apidocSignatureSpan">loopback.Router.</span>bind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  accepts: [
    {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
    {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
  ],
  description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
  accessType: &#x27;READ&#x27;,
  returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
  rest: {after: convertNullToNotFoundError.<span class="apidocCodeKeywordSpan">bind</span>(null, toModelName)},
});

define(&#x27;__create__&#x27; + relationName, {
  isStatic: false,
  http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
  accepts: [
    {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.checkout" id="apidoc.element.loopback.Router.checkout">
        function <span class="apidocSignatureSpan">loopback.Router.</span>checkout
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkout = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.connect" id="apidoc.element.loopback.Router.connect">
        function <span class="apidocSignatureSpan">loopback.Router.</span>connect
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.copy" id="apidoc.element.loopback.Router.copy">
        function <span class="apidocSignatureSpan">loopback.Router.</span>copy
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.delete" id="apidoc.element.loopback.Router.delete">
        function <span class="apidocSignatureSpan">loopback.Router.</span>delete
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.get" id="apidoc.element.loopback.Router.get">
        function <span class="apidocSignatureSpan">loopback.Router.</span>get
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* supports Express middleware. See
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/&#x27;, function(req, res){
*   res.send(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.handle" id="apidoc.element.loopback.Router.handle">
        function <span class="apidocSignatureSpan">loopback.Router.</span>handle
        <span class="apidocSignatureSpan">(req, res, out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handle(req, res, out) {
  var self = this;

  debug(&#x27;dispatching %s %s&#x27;, req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || &#x27;&#x27;
  var removed = &#x27;&#x27;;
  var slashAdded = false;
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || &#x27;&#x27;;
  var done = restore(out, req, &#x27;baseUrl&#x27;, &#x27;next&#x27;, &#x27;params&#x27;);

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === &#x27;OPTIONS&#x27;) {
    done = wrap(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === &#x27;route&#x27;
      ? null
      : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.substr(1);
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = &#x27;&#x27;;
    }

    // signal to exit router
    if (layerError === &#x27;router&#x27;) {
      setImmediate(done, null)
      return
    }

    // no more matching layers
    if (idx &#x3e;= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // get pathname of request
    var path = getPathname(req);

    if (path == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer;
    var match;
    var route;

    while (match !== true &#x26;&#x26; idx &#x3c; stack.length) {
      layer = stack[idx++];
      match = matchLayer(layer, path);
      route = layer.route;

      if (typeof match !== &#x27;boolean&#x27;) {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route._handles_method(method);

      // build up automatic options response
      if (!has_method &#x26;&#x26; method === &#x27;OPTIONS&#x27;) {
        appendMethods(options, route._options());
      }

      // don&#x27;t even bother matching route
      if (!has_method &#x26;&#x26; method !== &#x27;HEAD&#x27;) {
        match = false;
        continue;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route) {
      req.route = route;
    }

    // Capture one-time layer values
    req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params;
    var layerPath = layer.path;

    // this should be done for the layer
    self.process_params(layer, paramcalled, req, res, function (err) {
      if (err) {
        return next(layerError || err);
      }

      if (route) {
        return layer.handle_request(req, res, next);
      }

      trim_prefix(layer, layerError, layerPath, path);
    });
  }

  function trim_prefix(layer, layerError, layerPath, path) {
    if (layerPath.length !== 0) {
      // Validate path breaks on a path separator
      var c = path[layerPath.length]
      if (c &#x26;&#x26; c !== &#x27;/&#x27; &#x26;&#x26; c !== &#x27;.&#x27;) return next(layerError)

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug(&#x27;trim prefix (%s) from url %s&#x27;, layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      // Ensure leading slash
      if (!protohost &#x26;&#x26; req.url[0] !== &#x27;/&#x27;) {
        req.url = &#x27;/&#x27; + req.url;
        slashAdded = true; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.head" id="apidoc.element.loopback.Router.head">
        function <span class="apidocSignatureSpan">loopback.Router.</span>head
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.link" id="apidoc.element.loopback.Router.link">
        function <span class="apidocSignatureSpan">loopback.Router.</span>link
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.lock" id="apidoc.element.loopback.Router.lock">
        function <span class="apidocSignatureSpan">loopback.Router.</span>lock
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.m-search" id="apidoc.element.loopback.Router.m-search">
        function <span class="apidocSignatureSpan">loopback.Router.</span>m-search
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">m-search = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.merge" id="apidoc.element.loopback.Router.merge">
        function <span class="apidocSignatureSpan">loopback.Router.</span>merge
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.mkactivity" id="apidoc.element.loopback.Router.mkactivity">
        function <span class="apidocSignatureSpan">loopback.Router.</span>mkactivity
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkactivity = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.mkcalendar" id="apidoc.element.loopback.Router.mkcalendar">
        function <span class="apidocSignatureSpan">loopback.Router.</span>mkcalendar
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkcalendar = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.mkcol" id="apidoc.element.loopback.Router.mkcol">
        function <span class="apidocSignatureSpan">loopback.Router.</span>mkcol
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkcol = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.move" id="apidoc.element.loopback.Router.move">
        function <span class="apidocSignatureSpan">loopback.Router.</span>move
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.notify" id="apidoc.element.loopback.Router.notify">
        function <span class="apidocSignatureSpan">loopback.Router.</span>notify
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notify = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.options" id="apidoc.element.loopback.Router.options">
        function <span class="apidocSignatureSpan">loopback.Router.</span>options
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">options = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.param" id="apidoc.element.loopback.Router.param">
        function <span class="apidocSignatureSpan">loopback.Router.</span>param
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function param(name, fn) {
  // param logic
  if (typeof name === &#x27;function&#x27;) {
    deprecate(&#x27;router.param(fn): Refactor to use path params&#x27;);
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === &#x27;:&#x27;) {
    deprecate(&#x27;router.param(&#x27; + JSON.stringify(name) + &#x27;, fn): Use router.param(&#x27; + JSON.stringify(name.substr(1)) + &#x27;, fn) instead
&#x27;);
    name = name.substr(1);
  }

  for (var i = 0; i &#x3c; len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if (&#x27;function&#x27; !== typeof fn) {
    throw new Error(&#x27;invalid param() call for &#x27; + name + &#x27;, got &#x27; + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  remotes.authorization = function(ctx, next) {
var method = ctx.method;
var req = ctx.req;
var Model = method.ctor;
var modelInstance = ctx.instance;

var modelId = modelInstance &#x26;&#x26; modelInstance.id ||
  // replacement for deprecated req.<span class="apidocCodeKeywordSpan">param</span>()
  (req.params &#x26;&#x26; req.params.id !== undefined ? req.params.id :
   req.body &#x26;&#x26; req.body.id !== undefined ? req.body.id :
   req.query &#x26;&#x26; req.query.id !== undefined ? req.query.id :
   undefined);

var modelName = Model.modelName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.patch" id="apidoc.element.loopback.Router.patch">
        function <span class="apidocSignatureSpan">loopback.Router.</span>patch
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patch = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.post" id="apidoc.element.loopback.Router.post">
        function <span class="apidocSignatureSpan">loopback.Router.</span>post
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.process_params" id="apidoc.element.loopback.Router.process_params">
        function <span class="apidocSignatureSpan">loopback.Router.</span>process_params
        <span class="apidocSignatureSpan">(layer, called, req, res, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function process_params(layer, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i &#x3e;= keys.length ) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled &#x26;&#x26; (paramCalled.match === paramVal
      || (paramCalled.error &#x26;&#x26; paramCalled.error !== &#x27;route&#x27;))) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.propfind" id="apidoc.element.loopback.Router.propfind">
        function <span class="apidocSignatureSpan">loopback.Router.</span>propfind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propfind = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.proppatch" id="apidoc.element.loopback.Router.proppatch">
        function <span class="apidocSignatureSpan">loopback.Router.</span>proppatch
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">proppatch = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.purge" id="apidoc.element.loopback.Router.purge">
        function <span class="apidocSignatureSpan">loopback.Router.</span>purge
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.put" id="apidoc.element.loopback.Router.put">
        function <span class="apidocSignatureSpan">loopback.Router.</span>put
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.rebind" id="apidoc.element.loopback.Router.rebind">
        function <span class="apidocSignatureSpan">loopback.Router.</span>rebind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebind = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.report" id="apidoc.element.loopback.Router.report">
        function <span class="apidocSignatureSpan">loopback.Router.</span>report
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.route" id="apidoc.element.loopback.Router.route">
        function <span class="apidocSignatureSpan">loopback.Router.</span>route
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function route(path) {
  var route = new Route(path);

  var layer = new Layer(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route.dispatch.bind(route));

  layer.route = route;

  this.stack.push(layer);
  return route;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.search" id="apidoc.element.loopback.Router.search">
        function <span class="apidocSignatureSpan">loopback.Router.</span>search
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.subscribe" id="apidoc.element.loopback.Router.subscribe">
        function <span class="apidocSignatureSpan">loopback.Router.</span>subscribe
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.trace" id="apidoc.element.loopback.Router.trace">
        function <span class="apidocSignatureSpan">loopback.Router.</span>trace
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.unbind" id="apidoc.element.loopback.Router.unbind">
        function <span class="apidocSignatureSpan">loopback.Router.</span>unbind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.unlink" id="apidoc.element.loopback.Router.unlink">
        function <span class="apidocSignatureSpan">loopback.Router.</span>unlink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.unlock" id="apidoc.element.loopback.Router.unlock">
        function <span class="apidocSignatureSpan">loopback.Router.</span>unlock
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.unsubscribe" id="apidoc.element.loopback.Router.unsubscribe">
        function <span class="apidocSignatureSpan">loopback.Router.</span>unsubscribe
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (path){
  var route = this.route(path)
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Router.use" id="apidoc.element.loopback.Router.use">
        function <span class="apidocSignatureSpan">loopback.Router.</span>use
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(fn) {
  var offset = 0;
  var path = &#x27;/&#x27;;

  // default path to &#x27;/&#x27;
  // disambiguate router.use([fn])
  if (typeof fn !== &#x27;function&#x27;) {
    var arg = fn;

    while (Array.isArray(arg) &#x26;&#x26; arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== &#x27;function&#x27;) {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError(&#x27;Router.use() requires middleware functions&#x27;);
  }

  for (var i = 0; i &#x3c; callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== &#x27;function&#x27;) {
      throw new TypeError(&#x27;Router.use() requires middleware function but got a &#x27; + gettype(fn));
    }

    // add the middleware
    debug(&#x27;use %o %s&#x27;, path, fn.name || &#x27;&#x3c;anonymous&#x3e;&#x27;)

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    this.stack.push(layer);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (this._requestHandlingPhases.indexOf(name) === -1)
  throw new Error(g.f(&#x27;Unknown {{middleware}} phase %s&#x27;, name));

debug(&#x27;use %s %s %s&#x27;, fullPhaseName, paths, handlerName);

this._skipLayerSorting = true;
this.<span class="apidocCodeKeywordSpan">use</span>(paths, handler);

var layer = this._findLayerByHandler(handler);
if (layer) {
  // Set the phase name for sorting
  layer.phase = fullPhaseName;
} else {
  debug(&#x27;No matching layer is found for %s %s&#x27;, fullPhaseName, handlerName);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Scope" id="apidoc.module.loopback.Scope">module loopback.Scope</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Scope.Scope" id="apidoc.element.loopback.Scope.Scope">
        function <span class="apidocSignatureSpan">loopback.</span>Scope
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.ValidationError" id="apidoc.element.loopback.Scope.ValidationError">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope._ACL" id="apidoc.element.loopback.Scope._ACL">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope._defineChangeModel" id="apidoc.element.loopback.Scope._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope._getAccessTypeForMethod" id="apidoc.element.loopback.Scope._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope._notifyBaseObservers" id="apidoc.element.loopback.Scope._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope._runWhenAttachedToApp" id="apidoc.element.loopback.Scope._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.addListener" id="apidoc.element.loopback.Scope.addListener">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.afterRemote" id="apidoc.element.loopback.Scope.afterRemote">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.afterRemoteError" id="apidoc.element.loopback.Scope.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.attachTo" id="apidoc.element.loopback.Scope.attachTo">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.beforeRemote" id="apidoc.element.loopback.Scope.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.belongsToRemoting" id="apidoc.element.loopback.Scope.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.bulkUpdate" id="apidoc.element.loopback.Scope.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.changes" id="apidoc.element.loopback.Scope.changes">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.checkAccess" id="apidoc.element.loopback.Scope.checkAccess">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.checkPermission" id="apidoc.element.loopback.Scope.checkPermission">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>checkPermission
        <span class="apidocSignatureSpan">(scope, model, property, accessType, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPermission = function (scope, model, property, accessType, callback) {
  this.resolveRelatedModels();
  var aclModel = this.aclModel;
  assert(aclModel,
    &#x27;ACL model must be defined before Scope.checkPermission is called&#x27;);

  this.findOne({where: {name: scope}}, function(err, scope) {
    if (err) {
      if (callback) callback(err);
    } else {
      aclModel.checkPermission(
        aclModel.SCOPE, scope.id, model, property, accessType, callback);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    assert(aclModel,
      &#x27;ACL model must be defined before Scope.checkPermission is called&#x27;);

    this.findOne({where: {name: scope}}, function(err, scope) {
      if (err) {
        if (callback) callback(err);
      } else {
        aclModel.<span class="apidocCodeKeywordSpan">checkPermission</span>(
          aclModel.SCOPE, scope.id, model, property, accessType, callback);
      }
    });
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.checkpoint" id="apidoc.element.loopback.Scope.checkpoint">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.clearObservers" id="apidoc.element.loopback.Scope.clearObservers">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.count" id="apidoc.element.loopback.Scope.count">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.create" id="apidoc.element.loopback.Scope.create">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.createChangeFilter" id="apidoc.element.loopback.Scope.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.createChangeStream" id="apidoc.element.loopback.Scope.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.createOptionsFromRemotingContext" id="apidoc.element.loopback.Scope.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.createUpdates" id="apidoc.element.loopback.Scope.createUpdates">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.currentCheckpoint" id="apidoc.element.loopback.Scope.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.defineProperty" id="apidoc.element.loopback.Scope.defineProperty">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.deleteAll" id="apidoc.element.loopback.Scope.deleteAll">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.deleteById" id="apidoc.element.loopback.Scope.deleteById">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.destroyAll" id="apidoc.element.loopback.Scope.destroyAll">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.destroyById" id="apidoc.element.loopback.Scope.destroyById">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.diff" id="apidoc.element.loopback.Scope.diff">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.disableRemoteMethod" id="apidoc.element.loopback.Scope.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.disableRemoteMethodByName" id="apidoc.element.loopback.Scope.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.emit" id="apidoc.element.loopback.Scope.emit">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.enableChangeTracking" id="apidoc.element.loopback.Scope.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.eventNames" id="apidoc.element.loopback.Scope.eventNames">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.exists" id="apidoc.element.loopback.Scope.exists">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.extend" id="apidoc.element.loopback.Scope.extend">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.find" id="apidoc.element.loopback.Scope.find">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.findById" id="apidoc.element.loopback.Scope.findById">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Scope.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.findLastChange" id="apidoc.element.loopback.Scope.findLastChange">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.findOne" id="apidoc.element.loopback.Scope.findOne">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.findOrCreate" id="apidoc.element.loopback.Scope.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.forEachProperty" id="apidoc.element.loopback.Scope.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getApp" id="apidoc.element.loopback.Scope.getApp">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getChangeModel" id="apidoc.element.loopback.Scope.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getDataSource" id="apidoc.element.loopback.Scope.getDataSource">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getIdName" id="apidoc.element.loopback.Scope.getIdName">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getMaxListeners" id="apidoc.element.loopback.Scope.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getPropertyType" id="apidoc.element.loopback.Scope.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.getSourceId" id="apidoc.element.loopback.Scope.getSourceId">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.handleChangeError" id="apidoc.element.loopback.Scope.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.hasManyRemoting" id="apidoc.element.loopback.Scope.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.hasOneRemoting" id="apidoc.element.loopback.Scope.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.isHiddenProperty" id="apidoc.element.loopback.Scope.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.isProtectedProperty" id="apidoc.element.loopback.Scope.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.listenerCount" id="apidoc.element.loopback.Scope.listenerCount">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.listeners" id="apidoc.element.loopback.Scope.listeners">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.mixin" id="apidoc.element.loopback.Scope.mixin">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.nestRemoting" id="apidoc.element.loopback.Scope.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.notifyObserversAround" id="apidoc.element.loopback.Scope.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.notifyObserversOf" id="apidoc.element.loopback.Scope.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.observe" id="apidoc.element.loopback.Scope.observe">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.on" id="apidoc.element.loopback.Scope.on">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.once" id="apidoc.element.loopback.Scope.once">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.patchOrCreate" id="apidoc.element.loopback.Scope.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.patchOrCreateWithWhere" id="apidoc.element.loopback.Scope.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.prependListener" id="apidoc.element.loopback.Scope.prependListener">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.prependOnceListener" id="apidoc.element.loopback.Scope.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.rectifyAllChanges" id="apidoc.element.loopback.Scope.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.rectifyChange" id="apidoc.element.loopback.Scope.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.registerProperty" id="apidoc.element.loopback.Scope.registerProperty">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.remoteMethod" id="apidoc.element.loopback.Scope.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.remove" id="apidoc.element.loopback.Scope.remove">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.removeAllListeners" id="apidoc.element.loopback.Scope.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.removeById" id="apidoc.element.loopback.Scope.removeById">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.removeListener" id="apidoc.element.loopback.Scope.removeListener">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.removeObserver" id="apidoc.element.loopback.Scope.removeObserver">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.replaceById" id="apidoc.element.loopback.Scope.replaceById">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.replaceOrCreate" id="apidoc.element.loopback.Scope.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.replicate" id="apidoc.element.loopback.Scope.replicate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.resolveRelatedModels" id="apidoc.element.loopback.Scope.resolveRelatedModels">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>resolveRelatedModels
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveRelatedModels = function () {
  if (!this.aclModel) {
    var reg = this.registry;
    this.aclModel = reg.getModelByType(loopback.ACL);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @callback {Function} callback Callback function
   * @param {String|Error} err The error object.
   * @param {AccessRequest} result The resolved access request.
   */
  ACL.checkAccessForContext = function(context, callback) {
if (!callback) callback = utils.createPromiseCallback();
var self = this;
self.<span class="apidocCodeKeywordSpan">resolveRelatedModels</span>();
var roleModel = self.roleModel;

if (!(context instanceof AccessContext)) {
  context.registry = this.registry;
  context = new AccessContext(context);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.scopeRemoting" id="apidoc.element.loopback.Scope.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.setMaxListeners" id="apidoc.element.loopback.Scope.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.setup" id="apidoc.element.loopback.Scope.setup">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupPersistedModel() {
  // call Model.setup first
  Model.setup.call(this);

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.setupRemoting" id="apidoc.element.loopback.Scope.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.sharedCtor" id="apidoc.element.loopback.Scope.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.Scope.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.Scope.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.super_" id="apidoc.element.loopback.Scope.super_">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.update" id="apidoc.element.loopback.Scope.update">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.updateAll" id="apidoc.element.loopback.Scope.updateAll">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.updateLastChange" id="apidoc.element.loopback.Scope.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.updateOrCreate" id="apidoc.element.loopback.Scope.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.upsert" id="apidoc.element.loopback.Scope.upsert">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.upsertWithWhere" id="apidoc.element.loopback.Scope.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validate" id="apidoc.element.loopback.Scope.validate">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validateAsync" id="apidoc.element.loopback.Scope.validateAsync">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesAbsenceOf" id="apidoc.element.loopback.Scope.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesExclusionOf" id="apidoc.element.loopback.Scope.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesFormatOf" id="apidoc.element.loopback.Scope.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesInclusionOf" id="apidoc.element.loopback.Scope.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesLengthOf" id="apidoc.element.loopback.Scope.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesNumericalityOf" id="apidoc.element.loopback.Scope.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesPresenceOf" id="apidoc.element.loopback.Scope.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.Scope.validatesUniquenessOf" id="apidoc.element.loopback.Scope.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.Scope.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Scope.settings" id="apidoc.module.loopback.Scope.settings">module loopback.Scope.settings</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.Scope.settings.base" id="apidoc.element.loopback.Scope.settings.base">
        function <span class="apidocSignatureSpan">loopback.Scope.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.Scope.sharedClass" id="apidoc.module.loopback.Scope.sharedClass">module loopback.Scope.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.Scope.sharedClass.ctor" id="apidoc.element.loopback.Scope.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.Scope.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.User" id="apidoc.module.loopback.User">module loopback.User</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.User.User" id="apidoc.element.loopback.User.User">
        function <span class="apidocSignatureSpan">loopback.</span>User
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.ValidationError" id="apidoc.element.loopback.User.ValidationError">
        function <span class="apidocSignatureSpan">loopback.User.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User._ACL" id="apidoc.element.loopback.User._ACL">
        function <span class="apidocSignatureSpan">loopback.User.</span>_ACL
        <span class="apidocSignatureSpan">(ACL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getACL(ACL) {
  var registry = this.registry;
  if (ACL !== undefined) {
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.getModelByType(aclModel);
  return _aclModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {String|Error} err The error object.
   * @param {Boolean} allowed True if the request is allowed; false otherwise.
   */

  Model.checkAccess = function(token, modelId, sharedMethod, ctx, callback) {
var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
token = token || ANONYMOUS;
var aclModel = Model.<span class="apidocCodeKeywordSpan">_ACL</span>();

ctx = ctx || {};
if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
  callback = ctx;
  ctx = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User._defineChangeModel" id="apidoc.element.loopback.User._defineChangeModel">
        function <span class="apidocSignatureSpan">loopback.User.</span>_defineChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineChangeModel = function () {
  var BaseChangeModel = this.registry.getModel(&#x27;Change&#x27;);
  assert(BaseChangeModel,
    &#x27;Change model must be defined before enabling change replication&#x27;);

  const additionalChangeModelProperties =
    this.settings.additionalChangeModelProperties || {};

  this.Change = BaseChangeModel.extend(this.modelName + &#x27;-change&#x27;,
    additionalChangeModelProperties,
    {trackModel: this}
  );

  if (this.dataSource) {
    attachRelatedModels(this);
  }

  // Re-attach related models whenever our datasource is changed.
  var self = this;
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.attachTo(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// call Model.setup first
Model.setup.call(this);

var PersistedModel = this;

// enable change tracking (usually for replication)
if (this.settings.trackChanges) {
  PersistedModel.<span class="apidocCodeKeywordSpan">_defineChangeModel</span>();
  PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
    PersistedModel.enableChangeTracking();
  });
} else if (this.settings.enableRemoteReplication) {
  PersistedModel._defineChangeModel();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User._getAccessTypeForMethod" id="apidoc.element.loopback.User._getAccessTypeForMethod">
        function <span class="apidocSignatureSpan">loopback.User.</span>_getAccessTypeForMethod
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getAccessTypeForMethod = function (method) {
  if (typeof method === &#x27;string&#x27;) {
    method = {name: method};
  }
  assert(
    typeof method === &#x27;object&#x27;,
    &#x27;method is a required argument and must be a RemoteMethod object&#x27;
  );

  var ACL = Model._ACL();

  // Check the explicit setting of accessType
  if (method.accessType) {
    assert(method.accessType === ACL.READ ||
      method.accessType === ACL.REPLICATE ||
      method.accessType === ACL.WRITE ||
      method.accessType === ACL.EXECUTE, &#x27;invalid accessType &#x27; +
      method.accessType +
      &#x27;. It must be &#x22;READ&#x22;, &#x22;REPLICATE&#x22;, &#x22;WRITE&#x22;, or &#x22;EXECUTE&#x22;&#x27;);
    return method.accessType;
  }

  // Default GET requests to READ
  var verb = method.http &#x26;&#x26; method.http.verb;
  if (typeof verb === &#x27;string&#x27;) {
    verb = verb.toUpperCase();
  }
  if (verb === &#x27;GET&#x27; || verb === &#x27;HEAD&#x27;) {
    return ACL.READ;
  }

  switch (method.name) {
    case &#x27;create&#x27;:
      return ACL.WRITE;
    case &#x27;updateOrCreate&#x27;:
      return ACL.WRITE;
    case &#x27;upsertWithWhere&#x27;:
      return ACL.WRITE;
    case &#x27;upsert&#x27;:
      return ACL.WRITE;
    case &#x27;exists&#x27;:
      return ACL.READ;
    case &#x27;findById&#x27;:
      return ACL.READ;
    case &#x27;find&#x27;:
      return ACL.READ;
    case &#x27;findOne&#x27;:
      return ACL.READ;
    case &#x27;destroyById&#x27;:
      return ACL.WRITE;
    case &#x27;deleteById&#x27;:
      return ACL.WRITE;
    case &#x27;removeById&#x27;:
      return ACL.WRITE;
    case &#x27;count&#x27;:
      return ACL.READ;
    default:
      return ACL.EXECUTE;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.sharedMethod) {
  this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
} else {
  this.methodNames = [];
}

if (this.sharedMethod) {
  this.accessType = this.model.<span class="apidocCodeKeywordSpan">_getAccessTypeForMethod</span>(this.sharedMethod);
}

this.accessType = context.accessType || AccessContext.ALL;
assert(loopback.AccessToken,
  &#x27;AccessToken model must be defined before AccessContext model&#x27;);
this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User._invalidateAccessTokensOfUsers" id="apidoc.element.loopback.User._invalidateAccessTokensOfUsers">
        function <span class="apidocSignatureSpan">loopback.User.</span>_invalidateAccessTokensOfUsers
        <span class="apidocSignatureSpan">(userIds, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_invalidateAccessTokensOfUsers = function (userIds, options, cb) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; cb === undefined) {
    cb = options;
    options = {};
  }

  if (!Array.isArray(userIds) || !userIds.length)
    return process.nextTick(cb);

  var accessTokenRelation = this.relations.accessTokens;
  if (!accessTokenRelation)
    return process.nextTick(cb);

  var AccessToken = accessTokenRelation.modelTo;
  var query = {userId: {inq: userIds}};
  var tokenPK = AccessToken.definition.idName() || &#x27;id&#x27;;
  if (options.accessToken &#x26;&#x26; tokenPK in options.accessToken) {
    query[tokenPK] = {neq: options.accessToken[tokenPK]};
  }
  // add principalType in AccessToken.query if using polymorphic relations
  // between AccessToken and User
  var relatedUser = AccessToken.relations.user;
  var isRelationPolymorphic = relatedUser &#x26;&#x26; relatedUser.polymorphic &#x26;&#x26;
    !relatedUser.modelTo;
  if (isRelationPolymorphic) {
    query.principalType = this.modelName;
  }
  AccessToken.deleteAll(query, options, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var userIdsToExpire = ctx.hookState.originalUserData.filter(function(u) {
    return (newEmail &#x26;&#x26; u.email !== newEmail) ||
      (newPassword &#x26;&#x26; u.password !== newPassword);
  }).map(function(u) {
    return u[pkName];
  });
  ctx.Model.<span class="apidocCodeKeywordSpan">_invalidateAccessTokensOfUsers</span>(userIdsToExpire, ctx.options, next);
});
};

function emailValidator(err, done) {
var value = this.email;
if (value == null)
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User._notifyBaseObservers" id="apidoc.element.loopback.User._notifyBaseObservers">
        function <span class="apidocSignatureSpan">loopback.User.</span>_notifyBaseObservers
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notifyBaseObservers = function (operation, context, callback) {
  if (this.base &#x26;&#x26; this.base.notifyObserversOf)
    this.base.notifyObserversOf(operation, context, callback);
  else
    callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User._runWhenAttachedToApp" id="apidoc.element.loopback.User._runWhenAttachedToApp">
        function <span class="apidocSignatureSpan">loopback.User.</span>_runWhenAttachedToApp
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runWhenAttachedToApp = function (fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.once(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ModelCtor,
  remotingOptions
);

// before remote hook
ModelCtor.beforeRemote = function(name, fn) {
  var className = this.modelName;
  this.<span class="apidocCodeKeywordSpan">_runWhenAttachedToApp</span>(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.accessToken" id="apidoc.element.loopback.User.accessToken">
        function <span class="apidocSignatureSpan">loopback.User.</span>accessToken
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.addListener" id="apidoc.element.loopback.User.addListener">
        function <span class="apidocSignatureSpan">loopback.User.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.afterRemote" id="apidoc.element.loopback.User.afterRemote">
        function <span class="apidocSignatureSpan">loopback.User.</span>afterRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.after(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
        if (before &#x26;&#x26; before[delegateTo.name]) {
          self.beforeRemote(m, function(ctx, result, next) {
            before[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
        if (after &#x26;&#x26; after[delegateTo.name]) {
          self.<span class="apidocCodeKeywordSpan">afterRemote</span>(m, function(ctx, result, next) {
            after[delegateTo.name]._listeners.call(null, ctx, next);
          });
        }
      }
    });
  });
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.afterRemoteError" id="apidoc.element.loopback.User.afterRemoteError">
        function <span class="apidocSignatureSpan">loopback.User.</span>afterRemoteError
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterRemoteError = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.attachTo" id="apidoc.element.loopback.User.attachTo">
        function <span class="apidocSignatureSpan">loopback.User.</span>attachTo
        <span class="apidocSignatureSpan">(dataSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachTo = function (dataSource) {
  dataSource.attach(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.on(&#x27;dataSourceAttached&#x27;, function() {
    attachRelatedModels(self);
  });

  return this.Change;

  function attachRelatedModels(self) {
    self.Change.<span class="apidocCodeKeywordSpan">attachTo</span>(self.dataSource);
    self.Change.getCheckpointModel().attachTo(self.dataSource);
  }
};

PersistedModel.rectifyAllChanges = function(callback) {
  this.getChangeModel().rectifyAll(callback);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.beforeRemote" id="apidoc.element.loopback.User.beforeRemote">
        function <span class="apidocSignatureSpan">loopback.User.</span>beforeRemote
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">beforeRemote = function (name, fn) {
  var className = this.modelName;
  this._runWhenAttachedToApp(function(app) {
    var remotes = app.remotes();
    remotes.before(className + &#x27;.&#x27; + name, function(ctx, next) {
      return fn(ctx, ctx.result, next);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        sharedClass.methods().forEach(function(method) {
var delegateTo = method.rest &#x26;&#x26; method.rest.delegateTo;
if (delegateTo &#x26;&#x26; delegateTo.ctor == relation.modelTo) {
  var before = method.isStatic ? beforeListeners : beforeListeners[&#x27;prototype&#x27;];
  var after = method.isStatic ? afterListeners : afterListeners[&#x27;prototype&#x27;];
  var m = method.isStatic ? method.name : &#x27;prototype.&#x27; + method.name;
  if (before &#x26;&#x26; before[delegateTo.name]) {
    self.<span class="apidocCodeKeywordSpan">beforeRemote</span>(m, function(ctx, result, next) {
      before[delegateTo.name]._listeners.call(null, ctx, next);
    });
  }
  if (after &#x26;&#x26; after[delegateTo.name]) {
    self.afterRemote(m, function(ctx, result, next) {
      after[delegateTo.name]._listeners.call(null, ctx, next);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.belongsToRemoting" id="apidoc.element.loopback.User.belongsToRemoting">
        function <span class="apidocSignatureSpan">loopback.User.</span>belongsToRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">belongsToRemoting = function (relationName, relation, define) {
  var modelName = relation.modelTo &#x26;&#x26; relation.modelTo.modelName;
  modelName = modelName || &#x27;PersistedModel&#x27;;
  var fn = this.prototype[relationName];
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    accessType: &#x27;READ&#x27;,
    description: format(&#x27;Fetches belongsTo relation %s.&#x27;, relationName),
    returns: {arg: relationName, type: modelName, root: true},
  }, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineRaw(name, options, fn);
};

// get the relations
for (var relationName in relations) {
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">belongsToRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.bulkUpdate" id="apidoc.element.loopback.User.bulkUpdate">
        function <span class="apidocSignatureSpan">loopback.User.</span>bulkUpdate
        <span class="apidocSignatureSpan">(updates, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkUpdate = function (updates, options, callback) {
  var tasks = [];
  var Model = this;
  var Change = this.getChangeModel();
  var conflicts = [];

  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  buildLookupOfAffectedModelData(Model, updates, function(err, currentMap) {
    if (err) return callback(err);

    updates.forEach(function(update) {
      var id = update.change.modelId;
      var current = currentMap[id];
      switch (update.type) {
        case Change.UPDATE:
          tasks.push(function(cb) {
            applyUpdate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;

        case Change.CREATE:
          tasks.push(function(cb) {
            applyCreate(Model, id, current, update.data, update.change, conflicts, options, cb);
          });
          break;
        case Change.DELETE:
          tasks.push(function(cb) {
            applyDelete(Model, id, current, update.change, conflicts, options, cb);
          });
          break;
      }
    });

    async.parallel(tasks, function(err) {
      if (err) return callback(err);
      if (conflicts.length) {
        err = new Error(g.f(&#x27;Conflict&#x27;));
        err.statusCode = 409;
        err.details = {conflicts: conflicts};
        return callback(err);
      }
      callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function bulkUpdate(_updates, cb) {
debug(&#x27;\tstarting bulk update&#x27;);
updates = _updates;
utils.uploadInChunks(
  updates,
  replicationChunkSize,
  function(smallArray, chunkCallback) {
    return targetModel.<span class="apidocCodeKeywordSpan">bulkUpdate</span>(smallArray, options, function(err) {
      // bulk update is a special case where we want to process all chunks and aggregate all errors
      chunkCallback(null, err);
    });
  },
  function(notUsed, err) {
    var conflicts = err &#x26;&#x26; err.details &#x26;&#x26; err.details.conflicts;
    if (conflicts &#x26;&#x26; err.statusCode == 409) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.changePassword" id="apidoc.element.loopback.User.changePassword">
        function <span class="apidocSignatureSpan">loopback.User.</span>changePassword
        <span class="apidocSignatureSpan">(userId, oldPassword, newPassword, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changePassword = function (userId, oldPassword, newPassword, options, cb) {
  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }
  cb = cb || utils.createPromiseCallback();

  // Make sure to use the constructor of the (sub)class
  // where the method is invoked from (`this` instead of `User`)
  this.findById(userId, options, (err, inst) =&#x3e; {
    if (err) return cb(err);

    if (!inst) {
      const err = new Error(`User ${userId} not found`);
      Object.assign(err, {
        code: &#x27;USER_NOT_FOUND&#x27;,
        statusCode: 401,
      });
      return cb(err);
    }

    inst.changePassword(oldPassword, newPassword, options, cb);
  });

  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      Object.assign(err, {
        code: &#x27;USER_NOT_FOUND&#x27;,
        statusCode: 401,
      });
      return cb(err);
    }

    inst.<span class="apidocCodeKeywordSpan">changePassword</span>(oldPassword, newPassword, options, cb);
  });

  return cb.promise;
};

/**
 * Change this user&#x27;s password (prototype/instance version).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.changes" id="apidoc.element.loopback.User.changes">
        function <span class="apidocSignatureSpan">loopback.User.</span>changes
        <span class="apidocSignatureSpan">(since, filter, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changes = function (since, filter, callback) {
  if (typeof since === &#x27;function&#x27;) {
    filter = {};
    callback = since;
    since = -1;
  }
  if (typeof filter === &#x27;function&#x27;) {
    callback = filter;
    since = -1;
    filter = {};
  }

  var idName = this.dataSource.idName(this.modelName);
  var Change = this.getChangeModel();
  var model = this;
  const changeFilter = this.createChangeFilter(since, filter);

  filter = filter || {};
  filter.fields = {};
  filter.where = filter.where || {};
  filter.fields[idName] = true;

  // TODO(ritch) this whole thing could be optimized a bit more
  Change.find(changeFilter, function(err, changes) {
    if (err) return callback(err);
    if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
    var ids = changes.map(function(change) {
      return change.getModelId();
    });
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.type() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.waterfall(tasks, done);

    function getSourceChanges(cb) {
utils.downloadInChunks(
  options.filter,
  replicationChunkSize,
  function(filter, pagingCallback) {
    sourceModel.<span class="apidocCodeKeywordSpan">changes</span>(since.source, filter, pagingCallback);
  },
  debug.enabled ? log : cb);

function log(err, result) {
  if (err) return cb(err);
  debug(&#x27;\tusing source changes&#x27;);
  result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.checkAccess" id="apidoc.element.loopback.User.checkAccess">
        function <span class="apidocSignatureSpan">loopback.User.</span>checkAccess
        <span class="apidocSignatureSpan">(token, modelId, sharedMethod, ctx, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAccess = function (token, modelId, sharedMethod, ctx, callback) {
  var ANONYMOUS = registry.getModel(&#x27;AccessToken&#x27;).ANONYMOUS;
  token = token || ANONYMOUS;
  var aclModel = Model._ACL();

  ctx = ctx || {};
  if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; callback === undefined) {
    callback = ctx;
    ctx = {};
  }

  aclModel.checkAccessForContext({
    accessToken: token,
    model: this,
    property: sharedMethod.name,
    method: sharedMethod.name,
    sharedMethod: sharedMethod,
    modelId: modelId,
    accessType: this._getAccessTypeForMethod(sharedMethod),
    remotingContext: ctx,
  }, function(err, accessRequest) {
    if (err) return callback(err);
    callback(null, accessRequest.isAllowed());
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var modelSettings = Model.settings || {};
var errStatusCode = modelSettings.aclErrorStatus || app.get(&#x27;aclErrorStatus&#x27;) || 401;
if (!req.accessToken) {
  errStatusCode = 401;
}

if (Model.checkAccess) {
  Model.<span class="apidocCodeKeywordSpan">checkAccess</span>(
    req.accessToken,
    modelId,
    method,
    ctx,
    function(err, allowed) {
      if (err) {
        console.log(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.checkpoint" id="apidoc.element.loopback.User.checkpoint">
        function <span class="apidocSignatureSpan">loopback.User.</span>checkpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.bumpLastSeq(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      cb(err);
    });
}

function checkpoints() {
  var cb = arguments[arguments.length - 1];
  sourceModel.<span class="apidocCodeKeywordSpan">checkpoint</span>(function(err, source) {
    if (err) return cb(err);
    newSourceCp = source.seq;
    targetModel.checkpoint(function(err, target) {
      if (err) return cb(err);
      newTargetCp = target.seq;
      debug(&#x27;\tcreated checkpoints&#x27;);
      debug(&#x27;\t\t%s for source model %s&#x27;, newSourceCp, sourceModel.modelName);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.clearObservers" id="apidoc.element.loopback.User.clearObservers">
        function <span class="apidocSignatureSpan">loopback.User.</span>clearObservers
        <span class="apidocSignatureSpan">(operation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearObservers = function (operation) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  this._observers[operation].length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.confirm" id="apidoc.element.loopback.User.confirm">
        function <span class="apidocSignatureSpan">loopback.User.</span>confirm
        <span class="apidocSignatureSpan">(uid, token, redirect, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">confirm = function (uid, token, redirect, fn) {
  fn = fn || utils.createPromiseCallback();
  this.findById(uid, function(err, user) {
    if (err) {
      fn(err);
    } else {
      if (user &#x26;&#x26; user.verificationToken === token) {
        user.verificationToken = null;
        user.emailVerified = true;
        user.save(function(err) {
          if (err) {
            fn(err);
          } else {
            fn();
          }
        });
      } else {
        if (user) {
          err = new Error(g.f(&#x27;Invalid token: %s&#x27;, token));
          err.statusCode = 400;
          err.code = &#x27;INVALID_TOKEN&#x27;;
        } else {
          err = new Error(g.f(&#x27;User not found: %s&#x27;, uid));
          err.statusCode = 404;
          err.code = &#x27;USER_NOT_FOUND&#x27;;
        }
        fn(err);
      }
    }
  });
  return fn.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.count" id="apidoc.element.loopback.User.count">
        function <span class="apidocSignatureSpan">loopback.User.</span>count
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (where, cb) {
  throwNotAttached(this.modelName, &#x27;count&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.create" id="apidoc.element.loopback.User.create">
        function <span class="apidocSignatureSpan">loopback.User.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
  throwNotAttached(this.modelName, &#x27;create&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 } else {
   var options = {};

   if (this.get) {
     options = this.get(&#x27;remoting&#x27;);
   }

   return (this._remotes = RemoteObjects.<span class="apidocCodeKeywordSpan">create</span>(options));
 }
};

/*!
* Remove a route by reference.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.createChangeFilter" id="apidoc.element.loopback.User.createChangeFilter">
        function <span class="apidocSignatureSpan">loopback.User.</span>createChangeFilter
        <span class="apidocSignatureSpan">(since, modelFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeFilter = function (since, modelFilter) {
  return {
    where: {
      checkpoint: {gte: since},
      modelName: this.modelName,
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  since = -1;
  filter = {};
}

var idName = this.dataSource.idName(this.modelName);
var Change = this.getChangeModel();
var model = this;
const changeFilter = this.<span class="apidocCodeKeywordSpan">createChangeFilter</span>(since, filter);

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.createChangeStream" id="apidoc.element.loopback.User.createChangeStream">
        function <span class="apidocSignatureSpan">loopback.User.</span>createChangeStream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChangeStream = function (options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }

  var idName = this.getIdName();
  var Model = this;
  var changes = new PassThrough({objectMode: true});
  var writeable = true;

  changes.destroy = function() {
    changes.removeAllListeners(&#x27;error&#x27;);
    changes.removeAllListeners(&#x27;end&#x27;);
    writeable = false;
    changes = null;
  };

  changes.on(&#x27;error&#x27;, function() {
    writeable = false;
  });
  changes.on(&#x27;end&#x27;, function() {
    writeable = false;
  });

  process.nextTick(function() {
    cb(null, changes);
  });

  Model.observe(&#x27;after save&#x27;, createChangeHandler(&#x27;save&#x27;));
  Model.observe(&#x27;after delete&#x27;, createChangeHandler(&#x27;delete&#x27;));

  function createChangeHandler(type) {
    return function(ctx, next) {
      // since it might have set to null via destroy
      if (!changes) {
        return next();
      }

      var where = ctx.where;
      var data = ctx.instance || ctx.data;
      var whereId = where &#x26;&#x26; where[idName];

      // the data includes the id
      // or the where includes the id
      var target;

      if (data &#x26;&#x26; (data[idName] || data[idName] === 0)) {
        target = data[idName];
      } else if (where &#x26;&#x26; (where[idName] || where[idName] === 0)) {
        target = where[idName];
      }

      var hasTarget = target === 0 || !!target;

      var change = {
        target: target,
        where: where,
        data: data,
      };

      switch (type) {
        case &#x27;save&#x27;:
          if (ctx.isNewInstance === undefined) {
            change.type = hasTarget ? &#x27;update&#x27; : &#x27;create&#x27;;
          } else {
            change.type = ctx.isNewInstance ? &#x27;create&#x27; : &#x27;update&#x27;;
          }

          break;
        case &#x27;delete&#x27;:
          change.type = &#x27;remove&#x27;;
          break;
      }

      // TODO(ritch) this is ugly... maybe a ReadableStream would be better
      if (writeable) {
        changes.write(change);
      }

      next();
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.createOptionsFromRemotingContext" id="apidoc.element.loopback.User.createOptionsFromRemotingContext">
        function <span class="apidocSignatureSpan">loopback.User.</span>createOptionsFromRemotingContext
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createOptionsFromRemotingContext = function (ctx) {
  return {
    accessToken: ctx.req.accessToken,
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EMPTY_OPTIONS = {};
  var ModelCtor = ctx.method &#x26;&#x26; ctx.method.ctor;
  if (!ModelCtor)
    return EMPTY_OPTIONS;
  if (typeof ModelCtor.createOptionsFromRemotingContext !== &#x27;function&#x27;)
    return EMPTY_OPTIONS;
  debug(&#x27;createOptionsFromRemotingContext for %s&#x27;, ctx.method.stringName);
  return ModelCtor.<span class="apidocCodeKeywordSpan">createOptionsFromRemotingContext</span>(ctx);
}

/**
 * Disable remote invocation for the method with the given name.
 *
 * @param {String} name The name of the method.
 * @param {Boolean} isStatic Is the method static (eg. `MyModel.myMethod`)? Pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.createUpdates" id="apidoc.element.loopback.User.createUpdates">
        function <span class="apidocSignatureSpan">loopback.User.</span>createUpdates
        <span class="apidocSignatureSpan">(deltas, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUpdates = function (deltas, cb) {
  var Change = this.getChangeModel();
  var updates = [];
  var Model = this;
  var tasks = [];

  deltas.forEach(function(change) {
    change = new Change(change);
    var type = change.type();
    var update = {type: type, change: change};
    switch (type) {
      case Change.CREATE:
      case Change.UPDATE:
        tasks.push(function(cb) {
          Model.findById(change.modelId, function(err, inst) {
            if (err) return cb(err);
            if (!inst) {
              return cb &#x26;&#x26;
                cb(new Error(g.f(&#x27;Missing data for change: %s&#x27;, change.modelId)));
            }
            if (inst.toObject) {
              update.data = inst.toObject();
            } else {
              update.data = inst;
            }
            updates.push(update);
            cb();
          });
        });
        break;
      case Change.DELETE:
        updates.push(update);
        break;
    }
  });

  async.parallel(tasks, function(err) {
    if (err) return cb(err);
    cb(null, updates);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (diff &#x26;&#x26; diff.deltas &#x26;&#x26; diff.deltas.length) {
    debug(&#x27;\tbuilding a list of updates&#x27;);
    utils.uploadInChunks(
      diff.deltas,
      replicationChunkSize,
      function(smallArray, chunkCallback) {
        return sourceModel.<span class="apidocCodeKeywordSpan">createUpdates</span>(smallArray, chunkCallback);
      },
      cb);
  } else {
    // nothing to replicate
    done();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.currentCheckpoint" id="apidoc.element.loopback.User.currentCheckpoint">
        function <span class="apidocSignatureSpan">loopback.User.</span>currentCheckpoint
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentCheckpoint = function (cb) {
  var Checkpoint = this.getChangeModel().getCheckpointModel();
  Checkpoint.current(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.defineProperty" id="apidoc.element.loopback.User.defineProperty">
        function <span class="apidocSignatureSpan">loopback.User.</span>defineProperty
        <span class="apidocSignatureSpan">(prop, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineProperty = function (prop, params) {
  if (this.dataSource) {
    this.dataSource.defineProperty(this.modelName, prop, params);
  } else {
    this.modelBuilder.defineProperty(this.modelName, prop, params);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.deleteAll" id="apidoc.element.loopback.User.deleteAll">
        function <span class="apidocSignatureSpan">loopback.User.</span>deleteAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.modelName, id);
debug(&#x27;\tExpected revision: %s&#x27;, change.rev);
debug(&#x27;\tActual revision:   %s&#x27;, rev);
conflicts.push(change);
return Change.rectifyModelChanges(Model.modelName, [id], cb);
    }

    Model.<span class="apidocCodeKeywordSpan">deleteAll</span>(current.toObject(), options, function(err, result) {
if (err) return cb(err);

var count = result &#x26;&#x26; result.count;
switch (count) {
  case 1:
    // The happy path, exactly one record was updated
    return cb();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.deleteById" id="apidoc.element.loopback.User.deleteById">
        function <span class="apidocSignatureSpan">loopback.User.</span>deleteById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  Conflict.prototype.resolveUsingTarget = function(cb) {
var conflict = this;

conflict.models(function(err, source, target) {
  if (err) return done(err);
  if (target === null) {
    return conflict.SourceModel.<span class="apidocCodeKeywordSpan">deleteById</span>(conflict.modelId, done);
  }
  var inst = new conflict.SourceModel(
    target.toObject(),
    {persisted: true});
  inst.save(done);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.destroyAll" id="apidoc.element.loopback.User.destroyAll">
        function <span class="apidocSignatureSpan">loopback.User.</span>destroyAll
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctx.Model.find({where: ctx.where, fields: [pkName]}, function(err, list) {
    if (err) return next(err);

    var ids = list.map(function(u) { return u[pkName]; });
    ctx.where = {};
    ctx.where[pkName] = {inq: ids};

    AccessToken.<span class="apidocCodeKeywordSpan">destroyAll</span>({userId: {inq: ids}}, next);
  });
});

/**
 * Compare the given `password` with the users hashed password.
 *
 * @param {String} password The plain text password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.destroyById" id="apidoc.element.loopback.User.destroyById">
        function <span class="apidocSignatureSpan">loopback.User.</span>destroyById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!tokenId) {
  err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
  err.status = 401;
  process.nextTick(fn, err);
  return fn.promise;
}

this.relations.accessTokens.modelTo.<span class="apidocCodeKeywordSpan">destroyById</span>(tokenId, function(err, info) {
  if (err) {
    fn(err);
  } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
    err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
    err.status = 401;
    fn(err);
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.diff" id="apidoc.element.loopback.User.diff">
        function <span class="apidocSignatureSpan">loopback.User.</span>diff
        <span class="apidocSignatureSpan">(since, remoteChanges, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function (since, remoteChanges, callback) {
  var Change = this.getChangeModel();
  Change.diff(this.modelName, since, remoteChanges, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },
  });
};

/**
 * Get a set of deltas and conflicts since the given checkpoint.
 *
 * See [Change.<span class="apidocCodeKeywordSpan">diff</span>()](#change-diff) for details.
 *
 * @param  {Number}  since  Find deltas since this checkpoint.
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.disableRemoteMethod" id="apidoc.element.loopback.User.disableRemoteMethod">
        function <span class="apidocSignatureSpan">loopback.User.</span>disableRemoteMethod
        <span class="apidocSignatureSpan">(name, isStatic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethod = function (name, isStatic) {
  deprecated(&#x27;Model.disableRemoteMethod is deprecated. &#x27; +
    &#x27;Use Model.disableRemoteMethodByName instead.&#x27;);
  var key = this.sharedClass.getKeyFromMethodNameAndTarget(name, isStatic);
  this.sharedClass.disableMethodByName(key);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.disableRemoteMethodByName" id="apidoc.element.loopback.User.disableRemoteMethodByName">
        function <span class="apidocSignatureSpan">loopback.User.</span>disableRemoteMethodByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disableRemoteMethodByName = function (name) {
  this.sharedClass.disableMethodByName(name);
  this.emit(&#x27;remoteMethodDisabled&#x27;, this.sharedClass, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.email" id="apidoc.element.loopback.User.email">
        function <span class="apidocSignatureSpan">loopback.User.</span>email
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.emit" id="apidoc.element.loopback.User.emit">
        function <span class="apidocSignatureSpan">loopback.User.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new Model(data);
  });
  this.remotes().addClass(Model.sharedClass);
  if (Model.settings.trackChanges &#x26;&#x26; Model.Change) {
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.on(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.enableChangeTracking" id="apidoc.element.loopback.User.enableChangeTracking">
        function <span class="apidocSignatureSpan">loopback.User.</span>enableChangeTracking
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enableChangeTracking = function () {
  var Model = this;
  var Change = this.Change || this._defineChangeModel();
  var cleanupInterval = Model.settings.changeCleanupInterval || 30000;

  assert(this.dataSource, &#x27;Cannot enableChangeTracking(): &#x27; + this.modelName +
    &#x27; is not attached to a dataSource&#x27;);

  var idName = this.getIdName();
  var idProp = this.definition.properties[idName];
  var idType = idProp &#x26;&#x26; idProp.type;
  var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
  if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
    deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
      &#x27;which requires a string id with GUID/UUID default value.&#x27;);
  }

  Model.observe(&#x27;after save&#x27;, rectifyOnSave);

  Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

  // Only run if the run time is server
  // Can switch off cleanup by setting the interval to -1
  if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
    // initial cleanup
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var PersistedModel = this;

  // enable change tracking (usually for replication)
  if (this.settings.trackChanges) {
    PersistedModel._defineChangeModel();
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.<span class="apidocCodeKeywordSpan">enableChangeTracking</span>();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.setupRemoting();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.eventNames" id="apidoc.element.loopback.User.eventNames">
        function <span class="apidocSignatureSpan">loopback.User.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.exists" id="apidoc.element.loopback.User.exists">
        function <span class="apidocSignatureSpan">loopback.User.</span>exists
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(id, cb) {
  throwNotAttached(this.modelName, &#x27;exists&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.extend" id="apidoc.element.loopback.User.extend">
        function <span class="apidocSignatureSpan">loopback.User.</span>extend
        <span class="apidocSignatureSpan">(className, subclassProperties, subclassSettings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (className, subclassProperties, subclassSettings) {
  var properties = ModelClass.definition.properties;
  var settings = ModelClass.definition.settings;

  subclassProperties = subclassProperties || {};
  subclassSettings = subclassSettings || {};

  // Check if subclass redefines the ids
  var idFound = false;
  for (var k in subclassProperties) {
    if (subclassProperties[k] &#x26;&#x26; subclassProperties[k].id) {
      idFound = true;
      break;
    }
  }

  // Merging the properties
  var keys = Object.keys(properties);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    var key = keys[i];

    if (idFound &#x26;&#x26; properties[key].id) {
      // don&#x27;t inherit id properties
      continue;
    }
    if (subclassProperties[key] === undefined) {
      var baseProp = properties[key];
      var basePropCopy = baseProp;
      if (baseProp &#x26;&#x26; typeof baseProp === &#x27;object&#x27;) {
        // Deep clone the base prop
        basePropCopy = mergeSettings(null, baseProp);
      }
      subclassProperties[key] = basePropCopy;
    }
  }

  // Merge the settings
  var originalSubclassSettings = subclassSettings;
  subclassSettings = mergeSettings(settings, subclassSettings);

  // Ensure &#x27;base&#x27; is not inherited. Note we don&#x27;t have to delete &#x27;super&#x27;
  // as that is removed from settings by modelBuilder.define and thus
  // it is never inherited
  if (!originalSubclassSettings.base) {
    subclassSettings.base = ModelClass;
  }

  // Define the subclass
  var subClass = modelBuilder.define(className, subclassProperties, subclassSettings, ModelClass);

  // Calling the setup function
  if (typeof subClass.setup === &#x27;function&#x27;) {
    subClass.setup.call(subClass);
  }

  return subClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The base class for **all models**.
*
* **Inheriting from `Model`**
*
* ```js
* var properties = {...};
* var options = {...};
* var MyModel = loopback.Model.<span class="apidocCodeKeywordSpan">extend</span>(&#x27;MyModel&#x27;, properties, options);
* ```
*
* **Options**
*
*  - `trackChanges` - If true, changes to the model will be tracked. **Required
* for replication.**
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.find" id="apidoc.element.loopback.User.find">
        function <span class="apidocSignatureSpan">loopback.User.</span>find
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(filter, cb) {
  throwNotAttached(this.modelName, &#x27;find&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

filter = filter || {};
filter.fields = {};
filter.where = filter.where || {};
filter.fields[idName] = true;

// TODO(ritch) this whole thing could be optimized a bit more
Change.<span class="apidocCodeKeywordSpan">find</span>(changeFilter, function(err, changes) {
  if (err) return callback(err);
  if (!Array.isArray(changes) || changes.length === 0) return callback(null, []);
  var ids = changes.map(function(change) {
    return change.getModelId();
  });
  filter.where[idName] = {inq: ids};
  model.find(filter, function(err, models) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.findById" id="apidoc.element.loopback.User.findById">
        function <span class="apidocSignatureSpan">loopback.User.</span>findById
        <span class="apidocSignatureSpan">(id, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, filter, cb) {
  throwNotAttached(this.modelName, &#x27;findById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var model = new ModelCtor(data);
  model.id = id;
  fn(null, model);
} else if (data) {
  fn(null, new ModelCtor(data));
} else if (id) {
  var filter = {};
  ModelCtor.<span class="apidocCodeKeywordSpan">findById</span>(id, filter, options, function(err, model) {
    if (err) {
      fn(err);
    } else if (model) {
      fn(null, model);
    } else {
      err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.User.findById %s&#x27;, id));
      err.statusCode = 404;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.findLastChange" id="apidoc.element.loopback.User.findLastChange">
        function <span class="apidocSignatureSpan">loopback.User.</span>findLastChange
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastChange = function (id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.findOne({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.<span class="apidocCodeKeywordSpan">findLastChange</span>(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.findOne" id="apidoc.element.loopback.User.findOne">
        function <span class="apidocSignatureSpan">loopback.User.</span>findOne
        <span class="apidocSignatureSpan">(filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(filter, cb) {
  throwNotAttached(this.modelName, &#x27;findOne&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PersistedModel.rectifyChange = function(id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
};

PersistedModel.findLastChange = function(id, cb) {
  var Change = this.getChangeModel();
  Change.<span class="apidocCodeKeywordSpan">findOne</span>({where: {modelId: id}}, cb);
};

PersistedModel.updateLastChange = function(id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.findOrCreate" id="apidoc.element.loopback.User.findOrCreate">
        function <span class="apidocSignatureSpan">loopback.User.</span>findOrCreate
        <span class="apidocSignatureSpan">(query, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOrCreate(query, data, callback) {
  throwNotAttached(this.modelName, &#x27;findOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cb(err, cp.seq);
  });
};

Checkpoint._getSingleton = function(cb) {
  var query = {limit: 1}; // match all instances, return only one
  var initialData = {seq: 1};
  this.<span class="apidocCodeKeywordSpan">findOrCreate</span>(query, initialData, cb);
};

/**
 * Increase the current checkpoint if it already exists otherwise initialize it
 * @callback {Function} callback
 * @param {Error} err
 * @param {Object} checkpoint The current checkpoint
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.forEachProperty" id="apidoc.element.loopback.User.forEachProperty">
        function <span class="apidocSignatureSpan">loopback.User.</span>forEachProperty
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachProperty = function (cb) {
  var props = ModelClass.definition.properties;
  var keys = Object.keys(props);
  for (var i = 0, n = keys.length; i &#x3c; n; i++) {
    cb(keys[i], props[keys[i]]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.generateVerificationToken" id="apidoc.element.loopback.User.generateVerificationToken">
        function <span class="apidocSignatureSpan">loopback.User.</span>generateVerificationToken
        <span class="apidocSignatureSpan">(user, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateVerificationToken = function (user, cb) {
  crypto.randomBytes(64, function(err, buf) {
    cb(err, buf &#x26;&#x26; buf.toString(&#x27;hex&#x27;));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getApp" id="apidoc.element.loopback.User.getApp">
        function <span class="apidocSignatureSpan">loopback.User.</span>getApp
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getApp = function (callback) {
  var self = this;
  self._runWhenAttachedToApp(function(app) {
    assert(self.app);
    assert.equal(app, self.app);
    callback(null, app);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getChangeModel" id="apidoc.element.loopback.User.getChangeModel">
        function <span class="apidocSignatureSpan">loopback.User.</span>getChangeModel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getChangeModel = function () {
  var changeModel = this.Change;
  var isSetup = changeModel &#x26;&#x26; changeModel.dataSource;

  assert(isSetup, &#x27;Cannot get a setup Change model for &#x27; + this.modelName);

  return changeModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array}  remoteChanges  An array of change objects.
 * @callback {Function} callback Callback function called with `(err, result)` arguments.  Required.
 * @param {Error} err Error object; see [Error object](http://loopback.io/doc/en/lb2/Error-object.html).
 * @param {Object} result Object with `deltas` and `conflicts` properties; see [Change.diff()](#change-diff) for details.
 */

PersistedModel.diff = function(since, remoteChanges, callback) {
  var Change = this.<span class="apidocCodeKeywordSpan">getChangeModel</span>();
  Change.diff(this.modelName, since, remoteChanges, callback);
};

/**
 * Get the changes to a model since the specified checkpoint. Provide a filter object
 * to reduce the number of results returned.
 * @param  {Number}   since    Return only changes since this checkpoint.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getDataSource" id="apidoc.element.loopback.User.getDataSource">
        function <span class="apidocSignatureSpan">loopback.User.</span>getDataSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataSource = function () {
  return this.dataSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * connector that defines it.  Otherwise, uses the default lookup.
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.<span class="apidocCodeKeywordSpan">getDataSource</span>();
  this[this.getIdName()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getIdName" id="apidoc.element.loopback.User.getIdName">
        function <span class="apidocSignatureSpan">loopback.User.</span>getIdName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdName = function () {
  var Model = this;
  var ds = Model.getDataSource();

  if (ds.idName) {
    return ds.idName(Model.modelName);
  } else {
    return &#x27;id&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Override this method to handle complex IDs.
 *
 * @param {*} val The `id` value. Will be converted to the type that the `id` property specifies.
 */

PersistedModel.prototype.setId = function(val) {
  var ds = this.getDataSource();
  this[this.<span class="apidocCodeKeywordSpan">getIdName</span>()] = val;
};

/**
 * Get the `id` value for the `PersistedModel`.
 *
 * @returns {*} The `id` value
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getMaxListeners" id="apidoc.element.loopback.User.getMaxListeners">
        function <span class="apidocSignatureSpan">loopback.User.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getPropertyType" id="apidoc.element.loopback.User.getPropertyType">
        function <span class="apidocSignatureSpan">loopback.User.</span>getPropertyType
        <span class="apidocSignatureSpan">(propName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPropertyType = function (propName) {
  var prop = this.definition.properties[propName];
  if (!prop) {
    // The property is not part of the definition
    return null;
  }
  if (!prop.type) {
    throw new Error(g.f(&#x27;Type not defined for property %s.%s&#x27;, this.modelName, propName));
    // return null;
  }
  return prop.type.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.getSourceId" id="apidoc.element.loopback.User.getSourceId">
        function <span class="apidocSignatureSpan">loopback.User.</span>getSourceId
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceId = function (cb) {
  var dataSource = this.dataSource;
  if (!dataSource) {
    this.once(&#x27;dataSourceAttached&#x27;, this.getSourceId.bind(this, cb));
  }
  assert(
    dataSource.connector.name,
    &#x27;Model.getSourceId: cannot get id without dataSource.connector.name&#x27;
  );
  var id = [dataSource.connector.name, this.modelName].join(&#x27;-&#x27;);
  cb(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.handleChangeError" id="apidoc.element.loopback.User.handleChangeError">
        function <span class="apidocSignatureSpan">loopback.User.</span>handleChangeError
        <span class="apidocSignatureSpan">(err, operationName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleChangeError = function (err, operationName) {
  if (!err) return;
  this.emit(&#x27;error&#x27;, err, operationName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.rectifyAllChanges(function(err) {
      if (err) {
        Model.<span class="apidocCodeKeywordSpan">handleChangeError</span>(err, &#x27;cleanup&#x27;);
      }
    });
  }
};

function rectifyOnSave(ctx, next) {
  var instance = ctx.instance || ctx.currentInstance;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.hasManyRemoting" id="apidoc.element.loopback.User.hasManyRemoting">
        function <span class="apidocSignatureSpan">loopback.User.</span>hasManyRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasManyRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  var findByIdFunc = this.prototype[&#x27;__findById__&#x27; + relationName];
  define(&#x27;__findById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Find a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  }, findByIdFunc);

  var destroyByIdFunc = this.prototype[&#x27;__destroyById__&#x27; + relationName];
  define(&#x27;__destroyById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {
        arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Delete a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: [],
  }, destroyByIdFunc);

  var updateByIdFunc = this.prototype[&#x27;__updateById__&#x27; + relationName];
  define(&#x27;__updateById__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/:fk&#x27;},
    accepts: [
      {arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName, http: {source: &#x27;body&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update a related item by id for %s.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;result&#x27;, type: toModelName, root: true},
  }, updateByIdFunc);

  if (relation.modelThrough || relation.type === &#x27;referencesMany&#x27;) {
    var modelThrough = relation.modelThrough || relation.modelTo;

    var accepts = [];
    if (relation.type === &#x27;hasMany&#x27; &#x26;&#x26; relation.modelThrough) {
      // Restrict: only hasManyThrough relation can have additional properties
      accepts.push({
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: modelThrough.modelName,
        http: {source: &#x27;body&#x27;},
      });
    }

    var addFunc = this.prototype[&#x27;__link__&#x27; + relationName];
    define(&#x27;__link__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [{arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
        description: format(&#x27;Foreign key for %s&#x27;, relationName),
        required: true,
        http: {source: &#x27;path&#x27;}},
      ].concat(accepts).concat([
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ]),
      description: format(&#x27;Add a related item by id for %s.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: {arg: relationName, type: modelThrough.modelName, root: true},
    }, addFunc);

    var removeFunc = this.prototype[&#x27;__unlink__&#x27; + relationName];
    define(&#x27;__unlink__&#x27; + relationName, {
      isStatic: false,
      http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/rel/:fk&#x27;},
      accepts: [
        {
          arg: &#x27;fk&#x27;, type: &#x27;any&#x27;,
          description: format(&#x27;Foreign key for %s&#x27;, relationName),
          required: true,
          http: {source: &#x27;path&#x27;},
        },
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      description: format(&#x27;Remove the %s relation to an item by id.&#x27;, relationName),
      accessType: &#x27;WRITE&#x27;,
      returns: [],
    }, removeFunc);

    // FIXME: [rfeng] How to map a function with callback(err, true|false) to HEAD?
    // true --&#x3e; 200 and false --&#x3e; 404?
    var existsFunc = this.prototype[&#x27;__exists__&#x27; + relatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.hasOneRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasManyRemoting</span>(relationName, relation, define);
  }
}

// handle scopes
var scopes = ModelCtor.scopes || {};
for (var scopeName in scopes) {
  ModelCtor.scopeRemoting(scopeName, scopes[scopeName], define);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.hasOneRemoting" id="apidoc.element.loopback.User.hasOneRemoting">
        function <span class="apidocSignatureSpan">loopback.User.</span>hasOneRemoting
        <span class="apidocSignatureSpan">(relationName, relation, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOneRemoting = function (relationName, relation, define) {
  var pathName = (relation.options.http &#x26;&#x26; relation.options.http.path) || relationName;
  var toModelName = relation.modelTo.modelName;

  define(&#x27;__get__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
    rest: {after: convertNullToNotFoundError.bind(null, toModelName)},
  });

  define(&#x27;__create__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__update__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;put&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Update %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__destroy__&#x27; + relationName, {
    isStatic: false,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes %s of this model.&#x27;, relationName),
    accessType: &#x27;WRITE&#x27;,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var relation = relations[relationName];
  if (relation.type === &#x27;belongsTo&#x27;) {
    ModelCtor.belongsToRemoting(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasOne&#x27; ||
    relation.type === &#x27;embedsOne&#x27;
  ) {
    ModelCtor.<span class="apidocCodeKeywordSpan">hasOneRemoting</span>(relationName, relation, define);
  } else if (
    relation.type === &#x27;hasMany&#x27; ||
    relation.type === &#x27;embedsMany&#x27; ||
    relation.type === &#x27;referencesMany&#x27;) {
    ModelCtor.hasManyRemoting(relationName, relation, define);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.hashPassword" id="apidoc.element.loopback.User.hashPassword">
        function <span class="apidocSignatureSpan">loopback.User.</span>hashPassword
        <span class="apidocSignatureSpan">(plain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashPassword = function (plain) {
  this.validatePassword(plain);
  var salt = bcrypt.genSaltSync(this.settings.saltWorkFactor || SALT_WORK_FACTOR);
  return bcrypt.hashSync(plain, salt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
  if (plain.indexOf(&#x27;$2a$&#x27;) === 0 &#x26;&#x26; plain.length === 60) {
    // The password is already hashed. It can be the case
    // when the instance is loaded from DB
    this.$password = plain;
  } else {
    this.$password = this.constructor.<span class="apidocCodeKeywordSpan">hashPassword</span>(plain);
  }
};

// Make sure emailVerified is not set by creation
UserModel.beforeRemote(&#x27;create&#x27;, function(ctx, user, next) {
  var body = ctx.req.body;
  if (body &#x26;&#x26; body.emailVerified) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.isHiddenProperty" id="apidoc.element.loopback.User.isHiddenProperty">
        function <span class="apidocSignatureSpan">loopback.User.</span>isHiddenProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHiddenProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var hiddenProperties = settings &#x26;&#x26; (settings.hiddenProperties || settings.hidden);
  if (Array.isArray(hiddenProperties)) {
    // Cache the hidden properties as an object for quick lookup
    settings.hiddenProperties = {};
    for (var i = 0; i &#x3c; hiddenProperties.length; i++) {
      settings.hiddenProperties[hiddenProperties[i]] = true;
    }
    hiddenProperties = settings.hiddenProperties;
  }
  if (hiddenProperties) {
    return hiddenProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.isProtectedProperty" id="apidoc.element.loopback.User.isProtectedProperty">
        function <span class="apidocSignatureSpan">loopback.User.</span>isProtectedProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProtectedProperty = function (propertyName) {
  var Model = this;
  var settings = Model.definition &#x26;&#x26; Model.definition.settings;
  var protectedProperties = settings &#x26;&#x26; (settings.protectedProperties || settings.protected);
  if (Array.isArray(protectedProperties)) {
    // Cache the protected properties as an object for quick lookup
    settings.protectedProperties = {};
    for (var i = 0; i &#x3c; protectedProperties.length; i++) {
      settings.protectedProperties[protectedProperties[i]] = true;
    }
    protectedProperties = settings.protectedProperties;
  }
  if (protectedProperties) {
    return protectedProperties[propertyName];
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.listenerCount" id="apidoc.element.loopback.User.listenerCount">
        function <span class="apidocSignatureSpan">loopback.User.</span>listenerCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.listeners" id="apidoc.element.loopback.User.listeners">
        function <span class="apidocSignatureSpan">loopback.User.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.login" id="apidoc.element.loopback.User.login">
        function <span class="apidocSignatureSpan">loopback.User.</span>login
        <span class="apidocSignatureSpan">(credentials, include, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">login = function (credentials, include, fn) {
  var self = this;
  if (typeof include === &#x27;function&#x27;) {
    fn = include;
    include = undefined;
  }

  fn = fn || utils.createPromiseCallback();

  include = (include || &#x27;&#x27;);
  if (Array.isArray(include)) {
    include = include.map(function(val) {
      return val.toLowerCase();
    });
  } else {
    include = include.toLowerCase();
  }

  var realmDelimiter;
  // Check if realm is required
  var realmRequired = !!(self.settings.realmRequired ||
    self.settings.realmDelimiter);
  if (realmRequired) {
    realmDelimiter = self.settings.realmDelimiter;
  }
  var query = self.normalizeCredentials(credentials, realmRequired,
    realmDelimiter);

  if (realmRequired &#x26;&#x26; !query.realm) {
    var err1 = new Error(g.f(&#x27;{{realm}} is required&#x27;));
    err1.statusCode = 400;
    err1.code = &#x27;REALM_REQUIRED&#x27;;
    fn(err1);
    return fn.promise;
  }
  if (!query.email &#x26;&#x26; !query.username) {
    var err2 = new Error(g.f(&#x27;{{username}} or {{email}} is required&#x27;));
    err2.statusCode = 400;
    err2.code = &#x27;USERNAME_EMAIL_REQUIRED&#x27;;
    fn(err2);
    return fn.promise;
  }

  self.findOne({where: query}, function(err, user) {
    var defaultError = new Error(g.f(&#x27;login failed&#x27;));
    defaultError.statusCode = 401;
    defaultError.code = &#x27;LOGIN_FAILED&#x27;;

    function tokenHandler(err, token) {
      if (err) return fn(err);
      if (Array.isArray(include) ? include.indexOf(&#x27;user&#x27;) !== -1 : include === &#x27;user&#x27;) {
        // NOTE(bajtos) We can&#x27;t set token.user here:
        //  1. token.user already exists, it&#x27;s a function injected by
        //     &#x22;AccessToken belongsTo User&#x22; relation
        //  2. ModelBaseClass.toJSON() ignores own properties, thus
        //     the value won&#x27;t be included in the HTTP response
        // See also loopback#161 and loopback#162
        token.__data.user = user;
      }
      fn(err, token);
    }

    if (err) {
      debug(&#x27;An error is reported from User.findOne: %j&#x27;, err);
      fn(defaultError);
    } else if (user) {
      user.hasPassword(credentials.password, function(err, isMatch) {
        if (err) {
          debug(&#x27;An error is reported from User.hasPassword: %j&#x27;, err);
          fn(defaultError);
        } else if (isMatch) {
          if (self.settings.emailVerificationRequired &#x26;&#x26; !user.emailVerified) {
            // Fail to log in if email verification is not done yet
            debug(&#x27;User email has not been verified&#x27;);
            err = new Error(g.f(&#x27;login failed as the email has not been verified&#x27;));
            err.statusCode = 401;
            err.code = &#x27;LOGIN_FAILED_EMAIL_NOT_VERIFIED&#x27;;
            fn(err);
          } else {
            if (user.createAccessToken.length === 2) {
              user.createAccessToken(credentials.ttl, tokenHandler);
            } else {
              user.createAccessToken(credentials.ttl, credentials, tokenHandler);
            }
          }
        } else {
          debug(&#x27;The password is invalid for user %s&#x27;, query.email || query.username);
          fn(defaultError);
        }
      });
    } else {
      debug(&#x27;No matching record is found for user %s&#x27;, query.email || query.username);
      fn(defaultError);
    }
  });
  return fn.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @property {String} email Must be valid email.
* @property {Boolean} emailVerified Set when a user&#x27;s email has been verified via `confirm()`.
* @property {String} verificationToken Set when `verify()` is called.
* @property {String} realm The namespace the user belongs to. See [Partitioning users with realms](http://loopback.io/doc/en/lb2
/Partitioning-users-with-realms.html) for details.
* @property {Object} settings Extends the `Model.settings` object.
* @property {Boolean} settings.emailVerificationRequired Require the email verification
* process before allowing a login.
* @property {Number} settings.ttl Default time to live (in seconds) for the `AccessToken` created by `User.<span class="apidocCodeKeywordSpan
">login</span>() / user.createAccessToken()`.
* Default is `1209600` (2 weeks)
* @property {Number} settings.maxTTL The max value a user can request a token to be alive / valid for.
* Default is `31556926` (1 year)
* @property {Boolean} settings.realmRequired Require a realm when logging in a user.
* @property {String} settings.realmDelimiter When set a realm is required.
* @property {Number} settings.resetPasswordTokenTTL Time to live for password reset `AccessToken`. Default is `900` (15 minutes).
* @property {Number} settings.saltWorkFactor The `bcrypt` salt work factor. Default is `10`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.logout" id="apidoc.element.loopback.User.logout">
        function <span class="apidocSignatureSpan">loopback.User.</span>logout
        <span class="apidocSignatureSpan">(tokenId, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logout = function (tokenId, fn) {
  fn = fn || utils.createPromiseCallback();

  var err;
  if (!tokenId) {
    err = new Error(g.f(&#x27;{{accessToken}} is required to logout&#x27;));
    err.status = 401;
    process.nextTick(fn, err);
    return fn.promise;
  }

  this.relations.accessTokens.modelTo.destroyById(tokenId, function(err, info) {
    if (err) {
      fn(err);
    } else if (&#x27;count&#x27; in info &#x26;&#x26; info.count === 0) {
      err = new Error(g.f(&#x27;Could not find {{accessToken}}&#x27;));
      err.status = 401;
      fn(err);
    } else {
      fn();
    }
  });
  return fn.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return fn.promise;
};

/**
 * Logout a user with the given accessToken id.
 *
 * ```js
 *    User.<span class="apidocCodeKeywordSpan">logout</span>(&#x27;asd0a9f8dsj9s0s3223mk&#x27;, function (err) {
*      console.log(err || &#x27;Logged out&#x27;);
*    });
 * ```
 *
 * @param {String} accessTokenID
 * @callback {Function} callback
 * @param {Error} err
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.mixin" id="apidoc.element.loopback.User.mixin">
        function <span class="apidocSignatureSpan">loopback.User.</span>mixin
        <span class="apidocSignatureSpan">(anotherClass, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (anotherClass, options) {
  if (typeof anotherClass === &#x27;string&#x27;) {
    this.modelBuilder.mixins.applyMixin(this, anotherClass, options);
  } else {
    if (anotherClass.prototype instanceof ModelBaseClass) {
      var props = anotherClass.definition.properties;
      for (var i in props) {
        if (this.definition.properties[i]) {
          continue;
        }
        this.defineProperty(i, props[i]);
      }
    }
    return jutil.mixin(this, anotherClass, options);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.nestRemoting" id="apidoc.element.loopback.User.nestRemoting">
        function <span class="apidocSignatureSpan">loopback.User.</span>nestRemoting
        <span class="apidocSignatureSpan">(relationName, options, filterCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nestRemoting = function (relationName, options, filterCallback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !filterCallback) {
    filterCallback = options;
    options = {};
  }
  options = options || {};

  var regExp = /^__([^_]+)__([^_]+)$/;
  var relation = this.relations[relationName];
  if (relation &#x26;&#x26; relation.modelTo &#x26;&#x26; relation.modelTo.sharedClass) {
    var self = this;
    var sharedClass = this.sharedClass;
    var sharedToClass = relation.modelTo.sharedClass;
    var toModelName = relation.modelTo.modelName;

    var pathName = options.pathName || relation.options.path || relationName;
    var paramName = options.paramName || &#x27;nk&#x27;;

    var http = [].concat(sharedToClass.http || [])[0];
    var httpPath, acceptArgs;

    if (relation.multiple) {
      httpPath = pathName + &#x27;/:&#x27; + paramName;
      acceptArgs = [
        {
          arg: paramName, type: &#x27;any&#x27;, http: {source: &#x27;path&#x27;},
          description: format(&#x27;Foreign key for %s.&#x27;,  relation.name),
          required: true,
        },
      ];
    } else {
      httpPath = pathName;
      acceptArgs = [];
    }

    if (httpPath[0] !== &#x27;/&#x27;) {
      httpPath = &#x27;/&#x27; + httpPath;
    }

    // A method should return the method name to use, if it is to be
    // included as a nested method - a falsy return value will skip.
    var filter = filterCallback || options.filterMethod || function(method, relation) {
      var matches = method.name.match(regExp);
      if (matches) {
        return &#x27;__&#x27; + matches[1] + &#x27;__&#x27; + relation.name + &#x27;__&#x27; + matches[2];
      }
    };

    sharedToClass.methods().forEach(function(method) {
      var methodName;
      if (!method.isStatic &#x26;&#x26; (methodName = filter(method, relation))) {
        var prefix = relation.multiple ? &#x27;__findById__&#x27; : &#x27;__get__&#x27;;
        var getterName = options.getterName || (prefix + relationName);

        var getterFn = relation.modelFrom.prototype[getterName];
        if (typeof getterFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, getterName));
        }

        var nestedFn = relation.modelTo.prototype[method.name];
        if (typeof nestedFn !== &#x27;function&#x27;) {
          throw new Error(g.f(&#x27;Invalid remote method: `%s`&#x27;, method.name));
        }

        var opts = {};

        opts.accepts = acceptArgs.concat(method.accepts || []);
        opts.returns = [].concat(method.returns || []);
        opts.description = method.description;
        opts.accessType = method.accessType;
        opts.rest = extend({}, method.rest || {});
        opts.rest.delegateTo = method;

        opts.http = [];
        var routes = [].concat(method.http || []);
        routes.forEach(function(route) {
          if (route.path) {
            var copy = extend({}, route);
            copy.path = httpPath + route.path;
            opts.http.push(copy);
          }
        });

        if (relation.multiple) {
          sharedClass.defineMethod(methodName, opts, function(fkId) {
            var args = Array.prototype.slice.call(arguments, 1);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](fkId, function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return cb(err);
                }
              } else if (cb) {
                cb(err, null);
              }
            });
          }, method.isStatic);
        } else {
          sharedClass.defineMethod(methodName, opts, function() {
            var args = Array.prototype.slice.call(arguments);
            var last = args[args.length - 1];
            var cb = typeof last === &#x27;function&#x27; ? last : null;
            this[getterName](function(err, inst) {
              if (err &#x26;&#x26; cb) return cb(err);
              if (inst instanceof relation.modelTo) {
                try {
                  nestedFn.apply(inst, args);
                } catch (err) {
                  if (cb) return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.normalizeCredentials" id="apidoc.element.loopback.User.normalizeCredentials">
        function <span class="apidocSignatureSpan">loopback.User.</span>normalizeCredentials
        <span class="apidocSignatureSpan">(credentials, realmRequired, realmDelimiter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeCredentials = function (credentials, realmRequired, realmDelimiter) {
  var query = {};
  credentials = credentials || {};
  if (!realmRequired) {
    if (credentials.email) {
      query.email = credentials.email;
    } else if (credentials.username) {
      query.username = credentials.username;
    }
  } else {
    if (credentials.realm) {
      query.realm = credentials.realm;
    }
    var parts;
    if (credentials.email) {
      parts = splitPrincipal(credentials.email, realmDelimiter);
      query.email = parts[1];
      if (parts[0]) {
        query.realm = parts[0];
      }
    } else if (credentials.username) {
      parts = splitPrincipal(credentials.username, realmDelimiter);
      query.username = parts[1];
      if (parts[0]) {
        query.realm = parts[0];
      }
    }
  }
  return query;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var realmDelimiter;
// Check if realm is required
var realmRequired = !!(self.settings.realmRequired ||
  self.settings.realmDelimiter);
if (realmRequired) {
  realmDelimiter = self.settings.realmDelimiter;
}
var query = self.<span class="apidocCodeKeywordSpan">normalizeCredentials</span>(credentials, realmRequired,
  realmDelimiter);

if (realmRequired &#x26;&#x26; !query.realm) {
  var err1 = new Error(g.f(&#x27;{{realm}} is required&#x27;));
  err1.statusCode = 400;
  err1.code = &#x27;REALM_REQUIRED&#x27;;
  fn(err1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.notifyObserversAround" id="apidoc.element.loopback.User.notifyObserversAround">
        function <span class="apidocSignatureSpan">loopback.User.</span>notifyObserversAround
        <span class="apidocSignatureSpan">(operation, context, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversAround = function (operation, context, fn, callback) {
  var self = this;
  context = context || {};
  // Add callback to the context object so that an observer can skip other
  // ones by calling the callback function directly and not calling next
  if (context.end === undefined) {
    context.end = callback;
  }
  // First notify before observers
  return self.notifyObserversOf(&#x27;before &#x27; + operation, context,
    function(err, context) {
      if (err) return callback(err);

      function cbForWork(err) {
        var args = [].slice.call(arguments, 0);
        if (err) return callback.apply(null, args);
        // Find the list of params from the callback in addition to err
        var returnedArgs = args.slice(1);
        // Set up the array of results
        context.results = returnedArgs;
        // Notify after observers
        self.notifyObserversOf(&#x27;after &#x27; + operation, context,
          function(err, context) {
            if (err) return callback(err, context);
            var results = returnedArgs;
            if (context &#x26;&#x26; Array.isArray(context.results)) {
              // Pickup the results from context
              results = context.results;
            }
            // Build the list of params for final callback
            var args = [err].concat(results);
            callback.apply(null, args);
          });
      }

      if (fn.length === 1) {
        // fn(done)
        fn(cbForWork);
      } else {
        // fn(context, done)
        fn(context, cbForWork);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.notifyObserversOf" id="apidoc.element.loopback.User.notifyObserversOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>notifyObserversOf
        <span class="apidocSignatureSpan">(operation, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyObserversOf = function (operation, context, callback) {
  var self = this;
  if (!callback) callback = utils.createPromiseCallback();

  function createNotifier(op) {
    return function(ctx, done) {
      if (typeof ctx === &#x27;function&#x27; &#x26;&#x26; done === undefined) {
        done = ctx;
        ctx = context;
      }
      self.notifyObserversOf(op, context, done);
    };
  }

  if (Array.isArray(operation)) {
    var tasks = [];
    for (var i = 0, n = operation.length; i &#x3c; n; i++) {
      tasks.push(createNotifier(operation[i]));
    }
    return async.waterfall(tasks, callback);
  }

  var observers = this._observers &#x26;&#x26; this._observers[operation];

  this._notifyBaseObservers(operation, context, function doNotify(err) {
    if (err) return callback(err, context);
    if (!observers || !observers.length) return callback(null, context);

    async.eachSeries(
      observers,
      function notifySingleObserver(fn, next) {
        var retval = fn(context, next);
        if (retval &#x26;&#x26; typeof retval.then === &#x27;function&#x27;) {
          retval.then(
            function() { next(); return null; },
            next // error handler
          );
        }
      },
      function(err) { callback(err, context); }
    );
  });
  return callback.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.observe" id="apidoc.element.loopback.User.observe">
        function <span class="apidocSignatureSpan">loopback.User.</span>observe
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (operation, listener) {
  this._observers = this._observers || {};
  if (!this._observers[operation]) {
    this._observers[operation] = [];
  }

  this._observers[operation].push(listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var idType = idProp &#x26;&#x26; idProp.type;
var idDefn = idProp &#x26;&#x26; idProp.defaultFn;
if (idType !== String || !(idDefn === &#x27;uuid&#x27; || idDefn === &#x27;guid&#x27;)) {
  deprecated(&#x27;The model &#x27; + this.modelName + &#x27; is tracking changes, &#x27; +
    &#x27;which requires a string id with GUID/UUID default value.&#x27;);
}

Model.<span class="apidocCodeKeywordSpan">observe</span>(&#x27;after save&#x27;, rectifyOnSave);

Model.observe(&#x27;after delete&#x27;, rectifyOnDelete);

// Only run if the run time is server
// Can switch off cleanup by setting the interval to -1
if (runtime.isServer &#x26;&#x26; cleanupInterval &#x3e; 0) {
  // initial cleanup
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.on" id="apidoc.element.loopback.User.on">
        function <span class="apidocSignatureSpan">loopback.User.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.remotes().addClass(Model.Change.sharedClass);
  }
  clearHandlerCache(this);
  this.emit(&#x27;modelRemoted&#x27;, Model.sharedClass);
}

var self = this;
Model.<span class="apidocCodeKeywordSpan">on</span>(&#x27;remoteMethodDisabled&#x27;, function(model, methodName) {
  self.emit(&#x27;remoteMethodDisabled&#x27;, model, methodName);
});
Model.on(&#x27;remoteMethodAdded&#x27;, function(model) {
  self.emit(&#x27;remoteMethodAdded&#x27;, model);
});

Model.shared = isPublic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.once" id="apidoc.element.loopback.User.once">
        function <span class="apidocSignatureSpan">loopback.User.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    remotes.afterError(className + &#x27;.&#x27; + name, fn);
  });
};

ModelCtor._runWhenAttachedToApp = function(fn) {
  if (this.app) return fn(this.app);
  var self = this;
  self.<span class="apidocCodeKeywordSpan">once</span>(&#x27;attached&#x27;, function() {
    fn(self.app);
  });
};

if (&#x27;injectOptionsFromRemoteContext&#x27; in options) {
  console.warn(g.f(
    &#x27;%s is using model setting %s which is no longer available.&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.patchOrCreate" id="apidoc.element.loopback.User.patchOrCreate">
        function <span class="apidocSignatureSpan">loopback.User.</span>patchOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.patchOrCreateWithWhere" id="apidoc.element.loopback.User.patchOrCreateWithWhere">
        function <span class="apidocSignatureSpan">loopback.User.</span>patchOrCreateWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.prependListener" id="apidoc.element.loopback.User.prependListener">
        function <span class="apidocSignatureSpan">loopback.User.</span>prependListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.prependOnceListener" id="apidoc.element.loopback.User.prependOnceListener">
        function <span class="apidocSignatureSpan">loopback.User.</span>prependOnceListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.rectifyAllChanges" id="apidoc.element.loopback.User.rectifyAllChanges">
        function <span class="apidocSignatureSpan">loopback.User.</span>rectifyAllChanges
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyAllChanges = function (callback) {
  this.getChangeModel().rectifyAll(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cleanup();

    // cleanup
    setInterval(cleanup, cleanupInterval);
  }

  function cleanup() {
    Model.<span class="apidocCodeKeywordSpan">rectifyAllChanges</span>(function(err) {
      if (err) {
        Model.handleChangeError(err, &#x27;cleanup&#x27;);
      }
    });
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.rectifyChange" id="apidoc.element.loopback.User.rectifyChange">
        function <span class="apidocSignatureSpan">loopback.User.</span>rectifyChange
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rectifyChange = function (id, callback) {
  var Change = this.getChangeModel();
  Change.rectifyModelChanges(this.modelName, [id], callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  debug(&#x27;rectifyOnSave %s -&#x3e; &#x27; + (id ? &#x27;id %j&#x27; : &#x27;%s&#x27;),
    ctx.Model.modelName, id ? id : &#x27;ALL&#x27;);
  debug(&#x27;context instance:%j currentInstance:%j where:%j data %j&#x27;,
    ctx.instance, ctx.currentInstance, ctx.where, ctx.data);
}

if (id) {
  ctx.Model.<span class="apidocCodeKeywordSpan">rectifyChange</span>(id, reportErrorAndNext);
} else {
  ctx.Model.rectifyAllChanges(reportErrorAndNext);
}

function reportErrorAndNext(err) {
  if (err) {
    ctx.Model.handleChangeError(err, &#x27;after save&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.registerProperty" id="apidoc.element.loopback.User.registerProperty">
        function <span class="apidocSignatureSpan">loopback.User.</span>registerProperty
        <span class="apidocSignatureSpan">(propertyName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerProperty = function (propertyName) {
  var properties = modelDefinition.build();
  var prop = properties[propertyName];
  var DataType = prop.type;
  if (!DataType) {
    throw new Error(g.f(&#x27;Invalid type for property %s&#x27;, propertyName));
  }

  if (prop.required) {
    var requiredOptions = typeof prop.required === &#x27;object&#x27; ? prop.required : undefined;
    ModelClass.validatesPresenceOf(propertyName, requiredOptions);
  }

  Object.defineProperty(ModelClass.prototype, propertyName, {
    get: function() {
      if (ModelClass.getter[propertyName]) {
        return ModelClass.getter[propertyName].call(this); // Try getter first
      } else {
        return this.__data &#x26;&#x26; this.__data[propertyName]; // Try __data
      }
    },
    set: function(value) {
      var DataType = ModelClass.definition.properties[propertyName].type;
      if (Array.isArray(DataType) || DataType === Array) {
        DataType = List;
      } else if (DataType === Date) {
        DataType = DateType;
      } else if (DataType === Boolean) {
        DataType = BooleanType;
      } else if (typeof DataType === &#x27;string&#x27;) {
        DataType = modelBuilder.resolveType(DataType);
      }

      var persistUndefinedAsNull = ModelClass.definition.settings.persistUndefinedAsNull;
      if (value === undefined &#x26;&#x26; persistUndefinedAsNull) {
        value = null;
      }

      if (ModelClass.setter[propertyName]) {
        ModelClass.setter[propertyName].call(this, value); // Try setter first
      } else {
        this.__data = this.__data || {};
        if (value === null || value === undefined) {
          this.__data[propertyName] = value;
        } else {
          if (DataType === List) {
            this.__data[propertyName] = DataType(value, properties[propertyName].type, this.__data);
          } else {
            // Assume the type constructor handles Constructor() call
            // If not, we should call new DataType(value).valueOf();
            this.__data[propertyName] = (value instanceof DataType) ? value : DataType(value);
          }
        }
      }
    },
    configurable: true,
    enumerable: true,
  });

  // FIXME: [rfeng] Do we need to keep the raw data?
  // Use $ as the prefix to avoid conflicts with properties such as _id
  Object.defineProperty(ModelClass.prototype, &#x27;$&#x27; + propertyName, {
    get: function() {
      return this.__data &#x26;&#x26; this.__data[propertyName];
    },
    set: function(value) {
      if (!this.__data) {
        this.__data = {};
      }
      this.__data[propertyName] = value;
    },
    configurable: true,
    enumerable: false,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.remoteMethod" id="apidoc.element.loopback.User.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.User.</span>remoteMethod
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (name, options) {
  if (options.isStatic === undefined) {
    var m = name.match(/^prototype\.(.*)$/);
    options.isStatic = !m;
    name = options.isStatic ? name : m[1];
  }

  if (options.accepts) {
    options = extend({}, options);
    options.accepts = setupOptionsArgs(options.accepts);
  }

  this.sharedClass.defineMethod(name, options);
  this.emit(&#x27;remoteMethodAdded&#x27;, this.sharedClass);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.remove" id="apidoc.element.loopback.User.remove">
        function <span class="apidocSignatureSpan">loopback.User.</span>remove
        <span class="apidocSignatureSpan">(where, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyAll(where, cb) {
  throwNotAttached(this.modelName, &#x27;destroyAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debug(&#x27;update checkpoint to&#x27;, checkpoint);
      change.checkpoint = checkpoint;
    }

    if (change.prev === Change.UNKNOWN) {
      // this occurs when a record of a change doesn&#x27;t exist
      // and its current revision is null (not found)
      change.<span class="apidocCodeKeywordSpan">remove</span>(cb);
    } else {
      change.save(cb);
    }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.removeAllListeners" id="apidoc.element.loopback.User.removeAllListeners">
        function <span class="apidocSignatureSpan">loopback.User.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var idName = this.getIdName();
var Model = this;
var changes = new PassThrough({objectMode: true});
var writeable = true;

changes.destroy = function() {
  changes.<span class="apidocCodeKeywordSpan">removeAllListeners</span>(&#x27;error&#x27;);
  changes.removeAllListeners(&#x27;end&#x27;);
  writeable = false;
  changes = null;
};

changes.on(&#x27;error&#x27;, function() {
  writeable = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.removeById" id="apidoc.element.loopback.User.removeById">
        function <span class="apidocSignatureSpan">loopback.User.</span>removeById
        <span class="apidocSignatureSpan">(id, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteById(id, cb) {
  throwNotAttached(this.modelName, &#x27;deleteById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.removeListener" id="apidoc.element.loopback.User.removeListener">
        function <span class="apidocSignatureSpan">loopback.User.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.removeObserver" id="apidoc.element.loopback.User.removeObserver">
        function <span class="apidocSignatureSpan">loopback.User.</span>removeObserver
        <span class="apidocSignatureSpan">(operation, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeObserver = function (operation, listener) {
  if (!(this._observers &#x26;&#x26; this._observers[operation])) return;

  var index = this._observers[operation].indexOf(listener);
  if (index !== -1) {
    return this._observers[operation].splice(index, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.replaceById" id="apidoc.element.loopback.User.replaceById">
        function <span class="apidocSignatureSpan">loopback.User.</span>replaceById
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceById(id, data, cb) {
  throwNotAttached(this.modelName, &#x27;replaceById&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.replaceOrCreate" id="apidoc.element.loopback.User.replaceOrCreate">
        function <span class="apidocSignatureSpan">loopback.User.</span>replaceOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOrCreate(data, callback) {
  throwNotAttached(this.modelName, &#x27;replaceOrCreate&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.replicate" id="apidoc.element.loopback.User.replicate">
        function <span class="apidocSignatureSpan">loopback.User.</span>replicate
        <span class="apidocSignatureSpan">(since, targetModel, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replicate = function (since, targetModel, options, callback) {
  var lastArg = arguments[arguments.length - 1];

  if (typeof lastArg === &#x27;function&#x27; &#x26;&#x26; arguments.length &#x3e; 1) {
    callback = lastArg;
  }

  if (typeof since === &#x27;function&#x27; &#x26;&#x26; since.modelName) {
    targetModel = since;
    since = -1;
  }

  if (typeof since !== &#x27;object&#x27;) {
    since = {source: since, target: since};
  }

  if (typeof options === &#x27;function&#x27;) {
    options = {};
  }

  options = options || {};

  var sourceModel = this;
  callback = callback || utils.createPromiseCallback();

  debug(&#x27;replicating %s since %s to %s since %s&#x27;,
    sourceModel.modelName,
    since.source,
    targetModel.modelName,
    since.target);
  if (options.filter) {
    debug(&#x27;\twith filter %j&#x27;, options.filter);
  }

  // In order to avoid a race condition between the replication and
  // other clients modifying the data, we must create the new target
  // checkpoint as the first step of the replication process.
  // As a side-effect of that, the replicated changes are associated
  // with the new target checkpoint. This is actually desired behaviour,
  // because that way clients replicating *from* the target model
  // since the new checkpoint will pick these changes up.
  // However, it increases the likelihood of (false) conflicts being detected.
  // In order to prevent that, we run the replication multiple times,
  // until no changes were replicated, but at most MAX_ATTEMPTS times
  // to prevent starvation. In most cases, the second run will find no changes
  // to replicate and we are done.
  var MAX_ATTEMPTS = 3;

  run(1, since);
  return callback.promise;

  function run(attempt, since) {
    debug(&#x27;\titeration #%s&#x27;, attempt);
    tryReplicate(sourceModel, targetModel, since, options, next);

    function next(err, conflicts, cps, updates) {
      var finished = err || conflicts.length ||
        !updates || updates.length === 0 ||
        attempt &#x3e;= MAX_ATTEMPTS;

      if (finished)
        return callback(err, conflicts, cps);
      run(attempt + 1, cps);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.resetPassword" id="apidoc.element.loopback.User.resetPassword">
        function <span class="apidocSignatureSpan">loopback.User.</span>resetPassword
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetPassword = function (options, cb) {
  cb = cb || utils.createPromiseCallback();
  var UserModel = this;
  var ttl = UserModel.settings.resetPasswordTokenTTL || DEFAULT_RESET_PW_TTL;
  options = options || {};
  if (typeof options.email !== &#x27;string&#x27;) {
    var err = new Error(g.f(&#x27;Email is required&#x27;));
    err.statusCode = 400;
    err.code = &#x27;EMAIL_REQUIRED&#x27;;
    cb(err);
    return cb.promise;
  }

  try {
    if (options.password) {
      UserModel.validatePassword(options.password);
    }
  } catch (err) {
    return cb(err);
  }
  var where = {
    email: options.email,
  };
  if (options.realm) {
    where.realm = options.realm;
  }
  UserModel.findOne({where: where}, function(err, user) {
    if (err) {
      return cb(err);
    }
    if (!user) {
      err = new Error(g.f(&#x27;Email not found&#x27;));
      err.statusCode = 404;
      err.code = &#x27;EMAIL_NOT_FOUND&#x27;;
      return cb(err);
    }
    // create a short lived access token for temp login to change password
    // TODO(ritch) - eventually this should only allow password change
    if (UserModel.settings.emailVerificationRequired &#x26;&#x26; !user.emailVerified) {
      err = new Error(g.f(&#x27;Email has not been verified&#x27;));
      err.statusCode = 401;
      err.code = &#x27;RESET_FAILED_EMAIL_NOT_VERIFIED&#x27;;
      return cb(err);
    }

    user.createAccessToken(ttl, function(err, accessToken) {
      if (err) {
        return cb(err);
      }
      cb();
      UserModel.emit(&#x27;resetPasswordRequest&#x27;, {
        email: options.email,
        accessToken: accessToken,
        user: user,
        options: options,
      });
    });
  });

  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.scopeRemoting" id="apidoc.element.loopback.User.scopeRemoting">
        function <span class="apidocSignatureSpan">loopback.User.</span>scopeRemoting
        <span class="apidocSignatureSpan">(scopeName, scope, define)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scopeRemoting = function (scopeName, scope, define) {
  var pathName =
    (scope.options &#x26;&#x26; scope.options.http &#x26;&#x26; scope.options.http.path) || scopeName;

  var isStatic = scope.isStatic;
  var toModelName = scope.modelTo.modelName;

  // https://github.com/strongloop/loopback/issues/811
  // Check if the scope is for a hasMany relation
  var relation = this.relations[scopeName];
  if (relation &#x26;&#x26; relation.modelTo) {
    // For a relation with through model, the toModelName should be the one
    // from the target model
    toModelName = relation.modelTo.modelName;
  }

  define(&#x27;__get__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {arg: &#x27;filter&#x27;, type: &#x27;object&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Queries %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: scopeName, type: [toModelName], root: true},
  });

  define(&#x27;__create__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;data&#x27;,
        type: &#x27;object&#x27;,
        allowArray: true,
        model: toModelName,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Creates a new instance in %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
    returns: {arg: &#x27;data&#x27;, type: toModelName, root: true},
  });

  define(&#x27;__delete__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;delete&#x27;, path: &#x27;/&#x27; + pathName},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        // The &#x22;where&#x22; argument is not exposed in the REST API
        // but we need to provide a value so that we can pass &#x22;options&#x22;
        // as the third argument.
        http: function(ctx) { return undefined; },
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Deletes all %s of this model.&#x27;, scopeName),
    accessType: &#x27;WRITE&#x27;,
  });

  define(&#x27;__count__&#x27; + scopeName, {
    isStatic: isStatic,
    http: {verb: &#x27;get&#x27;, path: &#x27;/&#x27; + pathName + &#x27;/count&#x27;},
    accepts: [
      {
        arg: &#x27;where&#x27;, type: &#x27;object&#x27;,
        description: &#x27;Criteria to match model instances&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    description: format(&#x27;Counts %s of %s.&#x27;, scopeName, this.modelName),
    accessType: &#x27;READ&#x27;,
    returns: {arg: &#x27;count&#x27;,  type: &#x27;number&#x27;},
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ModelCtor.hasManyRemoting(relationName, relation, define);
      }
    }

    // handle scopes
    var scopes = ModelCtor.scopes || {};
    for (var scopeName in scopes) {
      ModelCtor.<span class="apidocCodeKeywordSpan">scopeRemoting</span>(scopeName, scopes[scopeName], define);
    }
  });

  return ModelCtor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.setMaxListeners" id="apidoc.element.loopback.User.setMaxListeners">
        function <span class="apidocSignatureSpan">loopback.User.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.setup" id="apidoc.element.loopback.User.setup">
        function <span class="apidocSignatureSpan">loopback.User.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function () {
  // We need to call the base class&#x27;s setup method
  User.base.setup.call(this);
  var UserModel = this;

  // max ttl
  this.settings.maxTTL = this.settings.maxTTL || DEFAULT_MAX_TTL;
  this.settings.ttl = this.settings.ttl || DEFAULT_TTL;

  UserModel.setter.email = function(value) {
    if (!UserModel.settings.caseSensitiveEmail) {
      this.$email = value.toLowerCase();
    } else {
      this.$email = value;
    }
  };

  UserModel.setter.password = function(plain) {
    if (typeof plain !== &#x27;string&#x27;) {
      return;
    }
    if (plain.indexOf(&#x27;$2a$&#x27;) === 0 &#x26;&#x26; plain.length === 60) {
      // The password is already hashed. It can be the case
      // when the instance is loaded from DB
      this.$password = plain;
    } else {
      this.$password = this.constructor.hashPassword(plain);
    }
  };

  // Make sure emailVerified is not set by creation
  UserModel.beforeRemote(&#x27;create&#x27;, function(ctx, user, next) {
    var body = ctx.req.body;
    if (body &#x26;&#x26; body.emailVerified) {
      body.emailVerified = false;
    }
    next();
  });

  UserModel.remoteMethod(
    &#x27;login&#x27;,
    {
      description: &#x27;Login a user with username/email and password.&#x27;,
      accepts: [
        {arg: &#x27;credentials&#x27;, type: &#x27;object&#x27;, required: true, http: {source: &#x27;body&#x27;}},
        {arg: &#x27;include&#x27;, type: [&#x27;string&#x27;], http: {source: &#x27;query&#x27;},
          description: &#x27;Related objects to include in the response. &#x27; +
          &#x27;See the description of return value for more details.&#x27;},
      ],
      returns: {
        arg: &#x27;accessToken&#x27;, type: &#x27;object&#x27;, root: true,
        description:
          g.f(&#x27;The response body contains properties of the {{AccessToken}} created on login.\n&#x27; +
          &#x27;Depending on the value of `include` parameter, the body may contain &#x27; +
          &#x27;additional properties:\n\n&#x27; +
          &#x27;  - `user` - `U+007BUserU+007D` - Data of the currently logged in user. &#x27; +
          &#x27;{{(`include=user`)}}\n\n&#x27;),
      },
      http: {verb: &#x27;post&#x27;},
    }
  );

  UserModel.remoteMethod(
    &#x27;logout&#x27;,
    {
      description: &#x27;Logout a user with access token.&#x27;,
      accepts: [
        {arg: &#x27;access_token&#x27;, type: &#x27;string&#x27;, http: function(ctx) {
          var req = ctx &#x26;&#x26; ctx.req;
          var accessToken = req &#x26;&#x26; req.accessToken;
          var tokenID = accessToken ? accessToken.id : undefined;

          return tokenID;
        }, description: &#x27;Do not supply this argument, it is automatically extracted &#x27; +
          &#x27;from request headers.&#x27;,
        },
      ],
      http: {verb: &#x27;all&#x27;},
    }
  );

  UserModel.remoteMethod(
    &#x27;confirm&#x27;,
    {
      description: &#x27;Confirm a user registration with email verification token.&#x27;,
      accepts: [
        {arg: &#x27;uid&#x27;, type: &#x27;string&#x27;, required: true},
        {arg: &#x27;token&#x27;, type: &#x27;string&#x27;, required: true},
        {arg: &#x27;redirect&#x27;, type: &#x27;string&#x27;},
      ],
      http: {verb: &#x27;get&#x27;, path: &#x27;/confirm&#x27;},
    }
  );

  UserModel.remoteMethod(
    &#x27;resetPassword&#x27;,
    {
      description: &#x27;Reset password for a user with email.&#x27;,
      accepts: [
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, required: true, http: {source: &#x27;body&#x27;}},
      ],
      http: {verb: &#x27;post&#x27;, path: &#x27;/reset&#x27;},
    }
  );

  UserModel.remoteMethod(
    &#x27;changePassword&#x27;,
    {
      description: &#x27;Change a user\&#x27;s password.&#x27;,
      accepts: [
        {arg: &#x27;id&#x27;, type: &#x27;any&#x27;,
          http: ctx =&#x3e; ctx.req.accessToken &#x26;&#x26; ctx.req.accessToken.userId,
        },
        {arg: &#x27;oldPassword&#x27;, type: &#x27;string&#x27;, required: true, http: {source: &#x27;form&#x27;}},
        {arg: &#x27;newPassword&#x27;, type: &#x27;string&#x27;, required: true, http: {source: &#x27;form&#x27;}},
        {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
      ],
      http: {verb: &#x27;POST&#x27;, path: &#x27;/change-password&#x27;},
    }
  );

  UserModel.afterRemote(&#x27;confirm&#x27;, function(ctx, inst, next) {
    if (ctx.args.redirect !== undefined) {
      if (!ctx.res) {
        return next(new Error(g.f(&#x27;The transport does not support HTTP redirects.&#x27;)));
      }
      ctx.res.location(ctx.args.redirect);
      ctx.res.status(302);
    }
    next();
  });

  // default models
  assert(loopb ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Model.createOptionsFromRemotingContext = function(ctx) {
    return {
      accessToken: ctx.req.accessToken,
    };
  };

  // setup the initial model
  Model.<span class="apidocCodeKeywordSpan">setup</span>();

  return Model;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.setupRemoting" id="apidoc.element.loopback.User.setupRemoting">
        function <span class="apidocSignatureSpan">loopback.User.</span>setupRemoting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupRemoting = function () {
  var PersistedModel = this;
  var typeName = PersistedModel.modelName;
  var options = PersistedModel.settings;

  // This is just for LB 3.x
  options.replaceOnPUT = options.replaceOnPUT !== false;

  function setRemoting(scope, name, options) {
    var fn = scope[name];
    fn._delegate = true;
    options.isStatic = scope === PersistedModel;
    PersistedModel.remoteMethod(name, options);
  }

  setRemoting(PersistedModel, &#x27;create&#x27;, {
    description: &#x27;Create a new instance of the model and persist it into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, allowArray: true,
        description: &#x27;Model instance data&#x27;,
        http: {source: &#x27;body&#x27;},
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27;},
  });

  var upsertOptions = {
    aliases: [&#x27;upsert&#x27;, &#x27;updateOrCreate&#x27;],
    description: &#x27;Patch an existing model instance or insert a new one &#x27; +
      &#x27;into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;patch&#x27;, path: &#x27;/&#x27;}],
  };

  if (!options.replaceOnPUT) {
    upsertOptions.http.unshift({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }
  setRemoting(PersistedModel, &#x27;patchOrCreate&#x27;, upsertOptions);

  var replaceOrCreateOptions = {
    description: &#x27;Replace an existing model instance or insert a new one into the data source.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {
        arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName,
        http: {source: &#x27;body&#x27;},
        description: &#x27;Model instance data&#x27;,
      },
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: [{verb: &#x27;post&#x27;, path: &#x27;/replaceOrCreate&#x27;}],
  };

  if (options.replaceOnPUT) {
    replaceOrCreateOptions.http.push({verb: &#x27;put&#x27;, path: &#x27;/&#x27;});
  }

  setRemoting(PersistedModel, &#x27;replaceOrCreate&#x27;, replaceOrCreateOptions);

  setRemoting(PersistedModel, &#x27;upsertWithWhere&#x27;, {
    aliases: [&#x27;patchOrCreateWithWhere&#x27;],
    description: &#x27;Update an existing model instance or insert a new one into &#x27; +
      &#x27;the data source based on the where criteria.&#x27;,
    accessType: &#x27;WRITE&#x27;,
    accepts: [
      {arg: &#x27;where&#x27;, type: &#x27;object&#x27;, http: {source: &#x27;query&#x27;},
        description: &#x27;Criteria to match model instances&#x27;},
      {arg: &#x27;data&#x27;, type: &#x27;object&#x27;, model: typeName, http: {source: &#x27;body&#x27;},
        description: &#x27;An object of model property name/value pairs&#x27;},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;data&#x27;, type: typeName, root: true},
    http: {verb: &#x27;post&#x27;, path: &#x27;/upsertWithWhere&#x27;},
  });

  setRemoting(PersistedModel, &#x27;exists&#x27;, {
    description: &#x27;Check whether a model instance exists in the data source.&#x27;,
    accessType: &#x27;READ&#x27;,
    accepts: [
      {arg: &#x27;id&#x27;, type: &#x27;any&#x27;, description: &#x27;Model id&#x27;, required: true},
      {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
    ],
    returns: {arg: &#x27;exists&#x27;, type: &#x27;boolean&#x27;},
    http: [
      {verb: &#x27;get&#x27;, path: &#x27;/:id/exists&#x27;},
      {verb: &#x27;head&#x27;, path: &#x27;/:id&#x27;},
    ],
    rest: {
      // After hook to map exists to 200/404 for HEAD
      after: function(ctx, cb) {
        if (ctx.req.method === &#x27;GET&#x27;) {
          // For GET, return {exists: true|false} as is
          return cb();
        }
        if (!ctx.result.exists) {
          var modelName = ctx.method.sharedClass.name;
          var id = ctx.getArgByName(&#x27;id&#x27;);
          var msg = &#x27;Unknown &#x22;&#x27; + modelName + &#x27;&#x22; id &#x22;&#x27; + id + &#x27;&#x22;.&#x27;;
          var error = new Error(msg);
          error.statusCode = error.status = 404;
          error.code = &#x27;MODEL_NOT_FOUND&#x27;;
          cb(error);
        } else {
          cb();
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    PersistedModel.once(&#x27;dataSourceAttached&#x27;, function() {
      PersistedModel.enableChangeTracking();
    });
  } else if (this.settings.enableRemoteReplication) {
    PersistedModel._defineChangeModel();
  }

  PersistedModel.<span class="apidocCodeKeywordSpan">setupRemoting</span>();
};

/*!
 * Throw an error telling the user that the method is not available and why.
 */

function throwNotAttached(modelName, methodName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.sharedCtor" id="apidoc.element.loopback.User.sharedCtor">
        function <span class="apidocSignatureSpan">loopback.User.</span>sharedCtor
        <span class="apidocSignatureSpan">(data, id, options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sharedCtor = function (data, id, options, fn) {
  var ModelCtor = this;

  var isRemoteInvocationWithOptions = typeof data !== &#x27;object&#x27; &#x26;&#x26;
    typeof id === &#x27;object&#x27; &#x26;&#x26;
    typeof options === &#x27;function&#x27;;
  if (isRemoteInvocationWithOptions) {
    // sharedCtor(id, options, fn)
    fn = options;
    options = id;
    id = data;
    data = null;
  } else if (typeof data === &#x27;function&#x27;) {
    // sharedCtor(fn)
    fn = data;
    data = null;
    id = null;
    options = null;
  } else if (typeof id === &#x27;function&#x27;) {
    // sharedCtor(data, fn)
    // sharedCtor(id, fn)
    fn = id;
    options = null;

    if (typeof data !== &#x27;object&#x27;) {
      id = data;
      data = null;
    } else {
      id = null;
    }
  }

  if (id &#x26;&#x26; data) {
    var model = new ModelCtor(data);
    model.id = id;
    fn(null, model);
  } else if (data) {
    fn(null, new ModelCtor(data));
  } else if (id) {
    var filter = {};
    ModelCtor.findById(id, filter, options, function(err, model) {
      if (err) {
        fn(err);
      } else if (model) {
        fn(null, model);
      } else {
        err = new Error(g.f(&#x27;could not find a model with apidoc.element.loopback.User.sharedCtor %s&#x27;, id));
        err.statusCode = 404;
        err.code = &#x27;MODEL_NOT_FOUND&#x27;;
        fn(err);
      }
    });
  } else {
    fn(new Error(g.f(&#x27;must specify an apidoc.element.loopback.User.sharedCtor or {{data}}&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.super_" id="apidoc.element.loopback.User.super_">
        function <span class="apidocSignatureSpan">loopback.User.</span>super_
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.update" id="apidoc.element.loopback.User.update">
        function <span class="apidocSignatureSpan">loopback.User.</span>update
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} str The string to be hashed
 * @return {String}     The hashed string
 */

Change.hash = function(str) {
  return crypto
    .createHash(Change.settings.hashAlgorithm || &#x27;sha1&#x27;)
    .<span class="apidocCodeKeywordSpan">update</span>(str)
    .digest(&#x27;hex&#x27;);
};

/**
 * Get the revision string for the given object
 * @param  {Object} inst The data to get the revision string for
 * @return {String}      The revision string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.updateAll" id="apidoc.element.loopback.User.updateAll">
        function <span class="apidocSignatureSpan">loopback.User.</span>updateAll
        <span class="apidocSignatureSpan">(where, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateAll(where, data, cb) {
  throwNotAttached(this.modelName, &#x27;updateAll&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Update multiple instances that match the where clause.
*
* Example:
*
*```js
* Employee.<span class="apidocCodeKeywordSpan">updateAll</span>({managerId: &#x27;x001&#x27;}, {managerId: &#x27;x002&#x27;}, function
(err, info) {
*     ...
* });
* ```
*
* @param {Object} [where] Optional `where` filter, like
* ```
* { key: val, key2: {gt: &#x27;val2&#x27;}, ...}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.updateLastChange" id="apidoc.element.loopback.User.updateLastChange">
        function <span class="apidocSignatureSpan">loopback.User.</span>updateLastChange
        <span class="apidocSignatureSpan">(id, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateLastChange = function (id, data, cb) {
  var self = this;
  this.findLastChange(id, function(err, inst) {
    if (err) return cb(err);
    if (!inst) {
      err = new Error(g.f(&#x27;No change record found for %s with id %s&#x27;,
        self.modelName, id));
      err.statusCode = 404;
      return cb(err);
    }

    inst.updateAttributes(data, cb);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Conflict.prototype.resolve = function(cb) {
  var conflict = this;
  conflict.TargetModel.findLastChange(
    this.modelId,
    function(err, targetChange) {
      if (err) return cb(err);
      conflict.SourceModel.<span class="apidocCodeKeywordSpan">updateLastChange</span>(
        conflict.modelId,
        {prev: targetChange.rev},
        cb);
    });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.updateOrCreate" id="apidoc.element.loopback.User.updateOrCreate">
        function <span class="apidocSignatureSpan">loopback.User.</span>updateOrCreate
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
      var ch = new Change({
        id: id,
        modelName: modelName,
        modelId: modelId,
      });
      ch.debug(&#x27;creating change&#x27;);
      Change.<span class="apidocCodeKeywordSpan">updateOrCreate</span>(ch, callback);
    }
  });
  return callback.promise;
};

/**
 * Update (or create) the change with the current revision.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.upsert" id="apidoc.element.loopback.User.upsert">
        function <span class="apidocSignatureSpan">loopback.User.</span>upsert
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsert(data, callback) {
  throwNotAttached(this.modelName, &#x27;upsert&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
});

// then save
function save() {
  inst.trigger(&#x27;save&#x27;, function(saveDone) {
    inst.trigger(&#x27;update&#x27;, function(updateDone) {
      Model.<span class="apidocCodeKeywordSpan">upsert</span>(inst, function(err) {
        inst._initProperties(data);
        updateDone.call(inst, function() {
          saveDone.call(inst, function() {
            callback(err, inst);
          });
        });
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.upsertWithWhere" id="apidoc.element.loopback.User.upsertWithWhere">
        function <span class="apidocSignatureSpan">loopback.User.</span>upsertWithWhere
        <span class="apidocSignatureSpan">(where, data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function upsertWithWhere(where, data, callback) {
  throwNotAttached(this.modelName, &#x27;upsertWithWhere&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validate" id="apidoc.element.loopback.User.validate">
        function <span class="apidocSignatureSpan">loopback.User.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var id = tokenIdForRequest(req, options);

if (id) {
  this.findById(id, function(err, token) {
    if (err) {
      cb(err);
    } else if (token) {
      token.<span class="apidocCodeKeywordSpan">validate</span>(function(err, isValid) {
        if (err) {
          cb(err);
        } else if (isValid) {
          cb(null, token);
        } else {
          var e = new Error(g.f(&#x27;Invalid Access Token&#x27;));
          e.status = e.statusCode = 401;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validateAsync" id="apidoc.element.loopback.User.validateAsync">
        function <span class="apidocSignatureSpan">loopback.User.</span>validateAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAsync = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatePassword" id="apidoc.element.loopback.User.validatePassword">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatePassword
        <span class="apidocSignatureSpan">(plain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatePassword = function (plain) {
  var err;
  if (plain &#x26;&#x26; typeof plain === &#x27;string&#x27; &#x26;&#x26; plain.length &#x3c;= MAX_PASSWORD_LENGTH) {
    return true;
  }
  if (plain.length &#x3e; MAX_PASSWORD_LENGTH) {
    err = new Error(g.f(&#x27;Password too long: %s&#x27;, plain));
    err.code = &#x27;PASSWORD_TOO_LONG&#x27;;
  } else {
    err =  new Error(g.f(&#x27;Invalid password: %s&#x27;, plain));
    err.code = &#x27;INVALID_PASSWORD&#x27;;
  }
  err.statusCode = 422;
  throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      code: &#x27;INVALID_PASSWORD&#x27;,
      statusCode: 400,
    });
    return cb(err);
  }

  try {
    User.<span class="apidocCodeKeywordSpan">validatePassword</span>(newPassword);
  } catch (err) {
    return cb(err);
  }

  const delta = {password: newPassword};
  this.patchAttributes(delta, options, (err, updated) =&#x3e; cb(err));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesAbsenceOf" id="apidoc.element.loopback.User.validatesAbsenceOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesAbsenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesAbsenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesExclusionOf" id="apidoc.element.loopback.User.validatesExclusionOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesExclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesExclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesFormatOf" id="apidoc.element.loopback.User.validatesFormatOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesFormatOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesFormatOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesInclusionOf" id="apidoc.element.loopback.User.validatesInclusionOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesInclusionOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesInclusionOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesLengthOf" id="apidoc.element.loopback.User.validatesLengthOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesLengthOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesLengthOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesNumericalityOf" id="apidoc.element.loopback.User.validatesNumericalityOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesNumericalityOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesNumericalityOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesPresenceOf" id="apidoc.element.loopback.User.validatesPresenceOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesPresenceOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesPresenceOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.validatesUniquenessOf" id="apidoc.element.loopback.User.validatesUniquenessOf">
        function <span class="apidocSignatureSpan">loopback.User.</span>validatesUniquenessOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatesUniquenessOf = function () {
  var args = Array.prototype.slice.call(arguments);
  args[1] = args[1] || {};
  configure(this, name, args, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    async.parallel(inRoleTasks, function(err, results) {
      debug(&#x27;getRoles() returns: %j %j&#x27;, err, roles);
      if (callback) callback(err, roles);
    });
    return callback.promise;
  };

  Role.<span class="apidocCodeKeywordSpan">validatesUniquenessOf</span>(&#x27;name&#x27;, {message: &#x27;already exists&#x27;});
};
...</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.User.prototype" id="apidoc.module.loopback.User.prototype">module loopback.User.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.User.prototype.changePassword" id="apidoc.element.loopback.User.prototype.changePassword">
        function <span class="apidocSignatureSpan">loopback.User.prototype.</span>changePassword
        <span class="apidocSignatureSpan">(oldPassword, newPassword, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changePassword = function (oldPassword, newPassword, options, cb) {
  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    cb = options;
    options = undefined;
  }
  cb = cb || utils.createPromiseCallback();

  this.hasPassword(oldPassword, (err, isMatch) =&#x3e; {
    if (err) return cb(err);
    if (!isMatch) {
      const err = new Error(&#x27;Invalid current password&#x27;);
      Object.assign(err, {
        code: &#x27;INVALID_PASSWORD&#x27;,
        statusCode: 400,
      });
      return cb(err);
    }

    try {
      User.validatePassword(newPassword);
    } catch (err) {
      return cb(err);
    }

    const delta = {password: newPassword};
    this.patchAttributes(delta, options, (err, updated) =&#x3e; cb(err));
  });
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      Object.assign(err, {
        code: &#x27;USER_NOT_FOUND&#x27;,
        statusCode: 401,
      });
      return cb(err);
    }

    inst.<span class="apidocCodeKeywordSpan">changePassword</span>(oldPassword, newPassword, options, cb);
  });

  return cb.promise;
};

/**
 * Change this user&#x27;s password (prototype/instance version).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.prototype.createAccessToken" id="apidoc.element.loopback.User.prototype.createAccessToken">
        function <span class="apidocSignatureSpan">loopback.User.prototype.</span>createAccessToken
        <span class="apidocSignatureSpan">(ttl, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createAccessToken = function (ttl, options, cb) {
  if (cb === undefined &#x26;&#x26; typeof options === &#x27;function&#x27;) {
    // createAccessToken(ttl, cb)
    cb = options;
    options = undefined;
  }

  cb = cb || utils.createPromiseCallback();

  if (typeof ttl === &#x27;object&#x27; &#x26;&#x26; !options) {
    // createAccessToken(options, cb)
    options = ttl;
    ttl = options.ttl;
  }
  options = options || {};
  var userModel = this.constructor;
  ttl = Math.min(ttl || userModel.settings.ttl, userModel.settings.maxTTL);
  this.accessTokens.create({
    ttl: ttl,
  }, cb);
  return cb.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @property {String} email Must be valid email.
* @property {Boolean} emailVerified Set when a user&#x27;s email has been verified via `confirm()`.
* @property {String} verificationToken Set when `verify()` is called.
* @property {String} realm The namespace the user belongs to. See [Partitioning users with realms](http://loopback.io/doc/en/lb2
/Partitioning-users-with-realms.html) for details.
* @property {Object} settings Extends the `Model.settings` object.
* @property {Boolean} settings.emailVerificationRequired Require the email verification
* process before allowing a login.
* @property {Number} settings.ttl Default time to live (in seconds) for the `AccessToken` created by `User.login() / user.<span
class="apidocCodeKeywordSpan">createAccessToken</span>()`.
* Default is `1209600` (2 weeks)
* @property {Number} settings.maxTTL The max value a user can request a token to be alive / valid for.
* Default is `31556926` (1 year)
* @property {Boolean} settings.realmRequired Require a realm when logging in a user.
* @property {String} settings.realmDelimiter When set a realm is required.
* @property {Number} settings.resetPasswordTokenTTL Time to live for password reset `AccessToken`. Default is `900` (15 minutes).
* @property {Number} settings.saltWorkFactor The `bcrypt` salt work factor. Default is `10`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.prototype.hasPassword" id="apidoc.element.loopback.User.prototype.hasPassword">
        function <span class="apidocSignatureSpan">loopback.User.prototype.</span>hasPassword
        <span class="apidocSignatureSpan">(plain, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasPassword = function (plain, fn) {
  fn = fn || utils.createPromiseCallback();
  if (this.password &#x26;&#x26; plain) {
    bcrypt.compare(plain, this.password, function(err, isMatch) {
      if (err) return fn(err);
      fn(null, isMatch);
    });
  } else {
    fn(null, false);
  }
  return fn.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fn(err, token);
}

if (err) {
  debug(&#x27;An error is reported from User.findOne: %j&#x27;, err);
  fn(defaultError);
} else if (user) {
  user.<span class="apidocCodeKeywordSpan">hasPassword</span>(credentials.password, function(err, isMatch) {
    if (err) {
      debug(&#x27;An error is reported from User.hasPassword: %j&#x27;, err);
      fn(defaultError);
    } else if (isMatch) {
      if (self.settings.emailVerificationRequired &#x26;&#x26; !user.emailVerified) {
        // Fail to log in if email verification is not done yet
        debug(&#x27;User email has not been verified&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.prototype.verify" id="apidoc.element.loopback.User.prototype.verify">
        function <span class="apidocSignatureSpan">loopback.User.prototype.</span>verify
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (options, fn) {
  fn = fn || utils.createPromiseCallback();

  var user = this;
  var userModel = this.constructor;
  var registry = userModel.registry;
  var pkName = userModel.definition.idName() || &#x27;id&#x27;;
  assert(typeof options === &#x27;object&#x27;, &#x27;options required when calling user.verify()&#x27;);
  assert(options.type, &#x27;You must supply a verification type (options.type)&#x27;);
  assert(options.type === &#x27;email&#x27;, &#x27;Unsupported verification type&#x27;);
  assert(options.to || this.email,
    &#x27;Must include options.to when calling user.verify() &#x27; +
    &#x27;or the user must have an email property&#x27;);
  assert(options.from, &#x27;Must include options.from when calling user.verify()&#x27;);

  options.redirect = options.redirect || &#x27;/&#x27;;
  var defaultTemplate = path.join(__dirname, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;templates&#x27;, &#x27;verify.ejs&#x27;);
  options.template = path.resolve(options.template || defaultTemplate);
  options.user = this;
  options.protocol = options.protocol || &#x27;http&#x27;;

  var app = userModel.app;
  options.host = options.host || (app &#x26;&#x26; app.get(&#x27;host&#x27;)) || &#x27;localhost&#x27;;
  options.port = options.port || (app &#x26;&#x26; app.get(&#x27;port&#x27;)) || 3000;
  options.restApiRoot = options.restApiRoot || (app &#x26;&#x26; app.get(&#x27;restApiRoot&#x27;)) || &#x27;/api&#x27;;

  var displayPort = (
    (options.protocol === &#x27;http&#x27; &#x26;&#x26; options.port == &#x27;80&#x27;) ||
    (options.protocol === &#x27;https&#x27; &#x26;&#x26; options.port == &#x27;443&#x27;)
  ) ? &#x27;&#x27; : &#x27;:&#x27; + options.port;

  var urlPath = joinUrlPath(
    options.restApiRoot,
    userModel.http.path,
    userModel.sharedClass.findMethodByName(&#x27;confirm&#x27;).http.path
  );

  options.verifyHref = options.verifyHref ||
    options.protocol +
    &#x27;://&#x27; +
    options.host +
    displayPort +
    urlPath +
    &#x27;?&#x27; + qs.stringify({
      uid: &#x27;&#x27; + options.user[pkName],
      redirect: options.redirect,
    });

  options.templateFn = options.templateFn || createVerificationEmailBody;

  // Email model
  var Email =
    options.mailer || this.constructor.email || registry.getModelByType(loopback.Email);

  // Set a default token generation function if one is not provided
  var tokenGenerator = options.generateVerificationToken || User.generateVerificationToken;
  assert(typeof tokenGenerator === &#x27;function&#x27;, &#x27;generateVerificationToken must be a function&#x27;);

  tokenGenerator(user, function(err, token) {
    if (err) { return fn(err); }

    user.verificationToken = token;
    user.save(function(err) {
      if (err) {
        fn(err);
      } else {
        sendEmail(user);
      }
    });
  });

  // TODO - support more verification types
  function sendEmail(user) {
    options.verifyHref += &#x27;&#x26;token=&#x27; + user.verificationToken;

    options.verificationToken = user.verificationToken;

    options.text = options.text || g.f(&#x27;Please verify your email by opening &#x27; +
      &#x27;this link in a web browser:\n\t%s&#x27;, options.verifyHref);

    options.text = options.text.replace(/\{href\}/g, options.verifyHref);

    options.to = options.to || user.email;

    options.subject = options.subject || g.f(&#x27;Thanks for Registering&#x27;);

    options.headers = options.headers || {};

    options.templateFn(options, function(err, html) {
      if (err) {
        fn(err);
      } else {
        setHtmlContentAndSend(html);
      }
    });

    function setHtmlContentAndSend(html) {
      options.html = html;

      // Remove options.template to prevent rejection by certain
      // nodemailer transport plugins.
      delete options.template;

      Email.send(options, function(err, email) {
        if (err) {
          fn(err);
        } else {
          fn(null, {email: email, token: user.verificationToken, uid: user[pkName]});
        }
      });
    }
  }
  return fn.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*      type: &#x27;email&#x27;,
*      to: user.email,
*      template: &#x27;verify.ejs&#x27;,
*      redirect: &#x27;/&#x27;,
*      tokenGenerator: function (user, cb) { cb(&#x22;random-token&#x22;); }
*    };
*
*    user.<span class="apidocCodeKeywordSpan">verify</span>(options, next);
* ```
*
* @options {Object} options
* @property {String} type Must be &#x27;email&#x27;.
* @property {String} to Email address to which verification email is sent.
* @property {String} from Sender email addresss, for example
*   `&#x27;noreply@myapp.com&#x27;`.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.User.setter" id="apidoc.module.loopback.User.setter">module loopback.User.setter</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.User.setter.email" id="apidoc.element.loopback.User.setter.email">
        function <span class="apidocSignatureSpan">loopback.User.setter.</span>email
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">email = function (value) {
  if (!UserModel.settings.caseSensitiveEmail) {
    this.$email = value.toLowerCase();
  } else {
    this.$email = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.User.setter.password" id="apidoc.element.loopback.User.setter.password">
        function <span class="apidocSignatureSpan">loopback.User.setter.</span>password
        <span class="apidocSignatureSpan">(plain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">password = function (plain) {
  if (typeof plain !== &#x27;string&#x27;) {
    return;
  }
  if (plain.indexOf(&#x27;$2a$&#x27;) === 0 &#x26;&#x26; plain.length === 60) {
    // The password is already hashed. It can be the case
    // when the instance is loaded from DB
    this.$password = plain;
  } else {
    this.$password = this.constructor.hashPassword(plain);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.User.settings" id="apidoc.module.loopback.User.settings">module loopback.User.settings</a></h1>








    <h2>
        <a href="#apidoc.element.loopback.User.settings.base" id="apidoc.element.loopback.User.settings.base">
        function <span class="apidocSignatureSpan">loopback.User.settings.</span>base
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.User.sharedClass" id="apidoc.module.loopback.User.sharedClass">module loopback.User.sharedClass</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.User.sharedClass.ctor" id="apidoc.element.loopback.User.sharedClass.ctor">
        function <span class="apidocSignatureSpan">loopback.User.sharedClass.</span>ctor
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ValidationError" id="apidoc.module.loopback.ValidationError">module loopback.ValidationError</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ValidationError.ValidationError" id="apidoc.element.loopback.ValidationError.ValidationError">
        function <span class="apidocSignatureSpan">loopback.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ValidationError.super_" id="apidoc.element.loopback.ValidationError.super_">
        function <span class="apidocSignatureSpan">loopback.ValidationError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.ValidationError.super_" id="apidoc.module.loopback.ValidationError.super_">module loopback.ValidationError.super_</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.ValidationError.super_.super_" id="apidoc.element.loopback.ValidationError.super_.super_">
        function <span class="apidocSignatureSpan">loopback.ValidationError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.ValidationError.super_.captureStackTrace" id="apidoc.element.loopback.ValidationError.super_.captureStackTrace">
        function <span class="apidocSignatureSpan">loopback.ValidationError.super_.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.access_context" id="apidoc.module.loopback.access_context">module loopback.access_context</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.access_context.AccessContext" id="apidoc.element.loopback.access_context.AccessContext">
        function <span class="apidocSignatureSpan">loopback.access_context.</span>AccessContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AccessContext(context) {
  if (!(this instanceof AccessContext)) {
    return new AccessContext(context);
  }
  context = context || {};

  assert(context.registry,
    &#x27;Application registry is mandatory in AccessContext but missing in provided context&#x27;);
  this.registry = context.registry;
  this.principals = context.principals || [];
  var model = context.model;
  model = (&#x27;string&#x27; === typeof model) ? this.registry.getModel(model) : model;
  this.model = model;
  this.modelName = model &#x26;&#x26; model.modelName;

  this.modelId = context.id || context.modelId;
  this.property = context.property || AccessContext.ALL;

  this.method = context.method;
  this.sharedMethod = context.sharedMethod;
  this.sharedClass = this.sharedMethod &#x26;&#x26; this.sharedMethod.sharedClass;
  if (this.sharedMethod) {
    this.methodNames = this.sharedMethod.aliases.concat([this.sharedMethod.name]);
  } else {
    this.methodNames = [];
  }

  if (this.sharedMethod) {
    this.accessType = this.model._getAccessTypeForMethod(this.sharedMethod);
  }

  this.accessType = context.accessType || AccessContext.ALL;
  assert(loopback.AccessToken,
    &#x27;AccessToken model must be defined before AccessContext model&#x27;);
  this.accessToken = context.accessToken || loopback.AccessToken.ANONYMOUS;

  var principalType = context.principalType || Principal.USER;
  var principalId = context.principalId || undefined;
  var principalName = context.principalName || undefined;

  if (principalId) {
    this.addPrincipal(principalType, principalId, principalName);
  }

  var token = this.accessToken || {};

  if (token.userId) {
    this.addPrincipal(Principal.USER, token.userId);
  }
  if (token.appId) {
    this.addPrincipal(Principal.APPLICATION, token.appId);
  }
  this.remotingContext = context.remotingContext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.access_context.AccessRequest" id="apidoc.element.loopback.access_context.AccessRequest">
        function <span class="apidocSignatureSpan">loopback.access_context.</span>AccessRequest
        <span class="apidocSignatureSpan">(model, property, accessType, permission, methodNames, registry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AccessRequest(model, property, accessType, permission, methodNames, registry) {
  if (!(this instanceof AccessRequest)) {
    return new AccessRequest(model, property, accessType, permission, methodNames);
  }
  if (arguments.length === 1 &#x26;&#x26; typeof model === &#x27;object&#x27;) {
    // The argument is an object that contains all required properties
    var obj = model || {};
    this.model = obj.model || AccessContext.ALL;
    this.property = obj.property || AccessContext.ALL;
    this.accessType = obj.accessType || AccessContext.ALL;
    this.permission = obj.permission || AccessContext.DEFAULT;
    this.methodNames = obj.methodNames || [];
    this.registry = obj.registry;
  } else {
    this.model = model || AccessContext.ALL;
    this.property = property || AccessContext.ALL;
    this.accessType = accessType || AccessContext.ALL;
    this.permission = permission || AccessContext.DEFAULT;
    this.methodNames = methodNames || [];
    this.registry = registry;
  }
  // do not create AccessRequest without a registry
  assert(this.registry,
    &#x27;Application registry is mandatory in AccessRequest but missing in provided argument(s)&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.access_context.Principal" id="apidoc.element.loopback.access_context.Principal">
        function <span class="apidocSignatureSpan">loopback.access_context.</span>Principal
        <span class="apidocSignatureSpan">(type, id, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Principal(type, id, name) {
  if (!(this instanceof Principal)) {
    return new Principal(type, id, name);
  }
  this.type = type;
  this.id = id;
  this.name = name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.application" id="apidoc.module.loopback.application">module loopback.application</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.application.acl" id="apidoc.element.loopback.application.acl">
        function <span class="apidocSignatureSpan">loopback.application.</span>acl
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acl = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.all" id="apidoc.element.loopback.application.all">
        function <span class="apidocSignatureSpan">loopback.application.</span>all
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(path) {
  this.lazyrouter();

  var route = this._router.route(path);
  var args = slice.call(arguments, 1);

  for (var i = 0; i &#x3c; methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.bind" id="apidoc.element.loopback.application.bind">
        function <span class="apidocSignatureSpan">loopback.application.</span>bind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bind = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  accepts: [
    {arg: &#x27;refresh&#x27;, type: &#x27;boolean&#x27;, http: {source: &#x27;query&#x27;}},
    {arg: &#x27;options&#x27;, type: &#x27;object&#x27;, http: &#x27;optionsFromRequest&#x27;},
  ],
  description: format(&#x27;Fetches hasOne relation %s.&#x27;, relationName),
  accessType: &#x27;READ&#x27;,
  returns: {arg: relationName, type: relation.modelTo.modelName, root: true},
  rest: {after: convertNullToNotFoundError.<span class="apidocCodeKeywordSpan">bind</span>(null, toModelName)},
});

define(&#x27;__create__&#x27; + relationName, {
  isStatic: false,
  http: {verb: &#x27;post&#x27;, path: &#x27;/&#x27; + pathName},
  accepts: [
    {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.checkout" id="apidoc.element.loopback.application.checkout">
        function <span class="apidocSignatureSpan">loopback.application.</span>checkout
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkout = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.connect" id="apidoc.element.loopback.application.connect">
        function <span class="apidocSignatureSpan">loopback.application.</span>connect
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.copy" id="apidoc.element.loopback.application.copy">
        function <span class="apidocSignatureSpan">loopback.application.</span>copy
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.defaultConfiguration" id="apidoc.element.loopback.application.defaultConfiguration">
        function <span class="apidocSignatureSpan">loopback.application.</span>defaultConfiguration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultConfiguration() {
  var env = process.env.NODE_ENV || &#x27;development&#x27;;

  // default settings
  this.enable(&#x27;x-powered-by&#x27;);
  this.set(&#x27;etag&#x27;, &#x27;weak&#x27;);
  this.set(&#x27;env&#x27;, env);
  this.set(&#x27;query parser&#x27;, &#x27;extended&#x27;);
  this.set(&#x27;subdomain offset&#x27;, 2);
  this.set(&#x27;trust proxy&#x27;, false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug(&#x27;booting in %s mode&#x27;, env);

  this.on(&#x27;mount&#x27;, function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true
      &#x26;&#x26; typeof parent.settings[&#x27;trust proxy fn&#x27;] === &#x27;function&#x27;) {
      delete this.settings[&#x27;trust proxy&#x27;];
      delete this.settings[&#x27;trust proxy fn&#x27;];
    }

    // inherit protos
    setPrototyeOf(this.request, parent.request)
    setPrototyeOf(this.response, parent.response)
    setPrototyeOf(this.engines, parent.engines)
    setPrototyeOf(this.settings, parent.settings)
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = &#x27;/&#x27;;

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set(&#x27;view&#x27;, View);
  this.set(&#x27;views&#x27;, resolve(&#x27;views&#x27;));
  this.set(&#x27;jsonp callback name&#x27;, &#x27;callback&#x27;);

  if (env === &#x27;production&#x27;) {
    this.enable(&#x27;view cache&#x27;);
  }

  Object.defineProperty(this, &#x27;router&#x27;, {
    get: function() {
      throw new Error(&#x27;\&#x27;app.router\&#x27; is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your
 app.&#x27;);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.del" id="apidoc.element.loopback.application.del">
        function <span class="apidocSignatureSpan">loopback.application.</span>del
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">del = function (arg0) {
&#x22;use strict&#x22;
log.call(deprecate, message, site)
return fn.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.delete" id="apidoc.element.loopback.application.delete">
        function <span class="apidocSignatureSpan">loopback.application.</span>delete
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.disable" id="apidoc.element.loopback.application.disable">
        function <span class="apidocSignatureSpan">loopback.application.</span>disable
        <span class="apidocSignatureSpan">(setting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disable(setting) {
  return this.set(setting, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.disabled" id="apidoc.element.loopback.application.disabled">
        function <span class="apidocSignatureSpan">loopback.application.</span>disabled
        <span class="apidocSignatureSpan">(setting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disabled(setting) {
  return !this.set(setting);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.enable" id="apidoc.element.loopback.application.enable">
        function <span class="apidocSignatureSpan">loopback.application.</span>enable
        <span class="apidocSignatureSpan">(setting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enable(setting) {
  return this.set(setting, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.enabled" id="apidoc.element.loopback.application.enabled">
        function <span class="apidocSignatureSpan">loopback.application.</span>enabled
        <span class="apidocSignatureSpan">(setting)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enabled(setting) {
  return Boolean(this.set(setting));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.engine" id="apidoc.element.loopback.application.engine">
        function <span class="apidocSignatureSpan">loopback.application.</span>engine
        <span class="apidocSignatureSpan">(ext, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function engine(ext, fn) {
  if (typeof fn !== &#x27;function&#x27;) {
    throw new Error(&#x27;callback function required&#x27;);
  }

  // get file extension
  var extension = ext[0] !== &#x27;.&#x27;
    ? &#x27;.&#x27; + ext
    : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.get" id="apidoc.element.loopback.application.get">
        function <span class="apidocSignatureSpan">loopback.application.</span>get
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* supports Express middleware. See
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/&#x27;, function(req, res){
*   res.send(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.handle" id="apidoc.element.loopback.application.handle">
        function <span class="apidocSignatureSpan">loopback.application.</span>handle
        <span class="apidocSignatureSpan">(req, res, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handle(req, res, callback) {
  var router = this._router;

  // final handler
  var done = callback || finalhandler(req, res, {
    env: this.get(&#x27;env&#x27;),
    onerror: logerror.bind(this)
  });

  // no routes
  if (!router) {
    debug(&#x27;no routes defined on app&#x27;);
    done();
    return;
  }

  router.handle(req, res, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.head" id="apidoc.element.loopback.application.head">
        function <span class="apidocSignatureSpan">loopback.application.</span>head
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">head = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.init" id="apidoc.element.loopback.application.init">
        function <span class="apidocSignatureSpan">loopback.application.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init() {
  this.cache = {};
  this.engines = {};
  this.settings = {};

  this.defaultConfiguration();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.lazyrouter" id="apidoc.element.loopback.application.lazyrouter">
        function <span class="apidocSignatureSpan">loopback.application.</span>lazyrouter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lazyrouter() {
  if (!this._router) {
    this._router = new Router({
      caseSensitive: this.enabled(&#x27;case sensitive routing&#x27;),
      strict: this.enabled(&#x27;strict routing&#x27;)
    });

    this._router.use(query(this.get(&#x27;query parser fn&#x27;)));
    this._router.use(middleware.init(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   names to add.
 *
 * @returns {object} this (fluent API)
 *
 * @header app.defineMiddlewarePhases(nameOrArray)
 */
proto.defineMiddlewarePhases = function(nameOrArray) {
this.<span class="apidocCodeKeywordSpan">lazyrouter</span>();

if (Array.isArray(nameOrArray)) {
  this._requestHandlingPhases =
    mergePhaseNameLists(this._requestHandlingPhases, nameOrArray);
} else {
  // add the new phase before &#x27;routes&#x27;
  var routesIx = this._requestHandlingPhases.indexOf(&#x27;routes&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.link" id="apidoc.element.loopback.application.link">
        function <span class="apidocSignatureSpan">loopback.application.</span>link
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.listen" id="apidoc.element.loopback.application.listen">
        function <span class="apidocSignatureSpan">loopback.application.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
grunt.loadNpmTasks(&#x27;grunt-eslint&#x27;);
grunt.loadNpmTasks(&#x27;grunt-contrib-watch&#x27;);
grunt.loadNpmTasks(&#x27;grunt-karma&#x27;);

grunt.registerTask(&#x27;e2e-server&#x27;, function() {
  var done = this.async();
  var app = require(&#x27;./test/fixtures/e2e/app&#x27;);
  app.<span class="apidocCodeKeywordSpan">listen</span>(0, function() {
    process.env.PORT = this.address().port;
    done();
  });
});

grunt.registerTask(&#x27;skip-karma-on-windows&#x27;, function() {
  console.log(&#x27;*** SKIPPING PHANTOM-JS BASED TESTS ON WINDOWS ***&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.lock" id="apidoc.element.loopback.application.lock">
        function <span class="apidocSignatureSpan">loopback.application.</span>lock
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.m-search" id="apidoc.element.loopback.application.m-search">
        function <span class="apidocSignatureSpan">loopback.application.</span>m-search
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">m-search = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.merge" id="apidoc.element.loopback.application.merge">
        function <span class="apidocSignatureSpan">loopback.application.</span>merge
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.mkactivity" id="apidoc.element.loopback.application.mkactivity">
        function <span class="apidocSignatureSpan">loopback.application.</span>mkactivity
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkactivity = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.mkcalendar" id="apidoc.element.loopback.application.mkcalendar">
        function <span class="apidocSignatureSpan">loopback.application.</span>mkcalendar
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkcalendar = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.mkcol" id="apidoc.element.loopback.application.mkcol">
        function <span class="apidocSignatureSpan">loopback.application.</span>mkcol
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkcol = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.move" id="apidoc.element.loopback.application.move">
        function <span class="apidocSignatureSpan">loopback.application.</span>move
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.notify" id="apidoc.element.loopback.application.notify">
        function <span class="apidocSignatureSpan">loopback.application.</span>notify
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notify = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.options" id="apidoc.element.loopback.application.options">
        function <span class="apidocSignatureSpan">loopback.application.</span>options
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">options = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.param" id="apidoc.element.loopback.application.param">
        function <span class="apidocSignatureSpan">loopback.application.</span>param
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i &#x3c; name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  remotes.authorization = function(ctx, next) {
var method = ctx.method;
var req = ctx.req;
var Model = method.ctor;
var modelInstance = ctx.instance;

var modelId = modelInstance &#x26;&#x26; modelInstance.id ||
  // replacement for deprecated req.<span class="apidocCodeKeywordSpan">param</span>()
  (req.params &#x26;&#x26; req.params.id !== undefined ? req.params.id :
   req.body &#x26;&#x26; req.body.id !== undefined ? req.body.id :
   req.query &#x26;&#x26; req.query.id !== undefined ? req.query.id :
   undefined);

var modelName = Model.modelName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.patch" id="apidoc.element.loopback.application.patch">
        function <span class="apidocSignatureSpan">loopback.application.</span>patch
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">patch = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.path" id="apidoc.element.loopback.application.path">
        function <span class="apidocSignatureSpan">loopback.application.</span>path
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function path() {
  return this.parent
    ? this.parent.path() + this.mountpath
    : &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.post" id="apidoc.element.loopback.application.post">
        function <span class="apidocSignatureSpan">loopback.application.</span>post
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.propfind" id="apidoc.element.loopback.application.propfind">
        function <span class="apidocSignatureSpan">loopback.application.</span>propfind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propfind = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.proppatch" id="apidoc.element.loopback.application.proppatch">
        function <span class="apidocSignatureSpan">loopback.application.</span>proppatch
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">proppatch = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.purge" id="apidoc.element.loopback.application.purge">
        function <span class="apidocSignatureSpan">loopback.application.</span>purge
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.put" id="apidoc.element.loopback.application.put">
        function <span class="apidocSignatureSpan">loopback.application.</span>put
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.rebind" id="apidoc.element.loopback.application.rebind">
        function <span class="apidocSignatureSpan">loopback.application.</span>rebind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebind = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.render" id="apidoc.element.loopback.application.render">
        function <span class="apidocSignatureSpan">loopback.application.</span>render
        <span class="apidocSignatureSpan">(name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var renderOptions = {};
  var view;

  // support callback function as second arg
  if (typeof options === &#x27;function&#x27;) {
    done = options;
    opts = {};
  }

  // merge app.locals
  merge(renderOptions, this.locals);

  // merge options._locals
  if (opts._locals) {
    merge(renderOptions, opts._locals);
  }

  // merge options
  merge(renderOptions, opts);

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled(&#x27;view cache&#x27;);
  }

  // primed cache
  if (renderOptions.cache) {
    view = cache[name];
  }

  // view
  if (!view) {
    var View = this.get(&#x27;view&#x27;);

    view = new View(name, {
      defaultEngine: this.get(&#x27;view engine&#x27;),
      root: this.get(&#x27;views&#x27;),
      engines: engines
    });

    if (!view.path) {
      var dirs = Array.isArray(view.root) &#x26;&#x26; view.root.length &#x3e; 1
        ? &#x27;directories &#x22;&#x27; + view.root.slice(0, -1).join(&#x27;&#x22;, &#x22;&#x27;) + &#x27;&#x22; or &#x22;&#x27; + view.root[view.root.length - 1] + &#x27;&#x22;&#x27;
        : &#x27;directory &#x22;&#x27; + view.root + &#x27;&#x22;&#x27;
      var err = new Error(&#x27;Failed to lookup view &#x22;&#x27; + name + &#x27;&#x22; in views &#x27; + dirs);
      err.view = view;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view;
    }
  }

  // render
  tryRender(view, renderOptions, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.report" id="apidoc.element.loopback.application.report">
        function <span class="apidocSignatureSpan">loopback.application.</span>report
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.route" id="apidoc.element.loopback.application.route">
        function <span class="apidocSignatureSpan">loopback.application.</span>route
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function route(path) {
  this.lazyrouter();
  return this._router.route(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.search" id="apidoc.element.loopback.application.search">
        function <span class="apidocSignatureSpan">loopback.application.</span>search
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.set" id="apidoc.element.loopback.application.set">
        function <span class="apidocSignatureSpan">loopback.application.</span>set
        <span class="apidocSignatureSpan">(setting, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    return this.settings[setting];
  }

  debug(&#x27;set &#x22;%s&#x22; to %o&#x27;, setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case &#x27;etag&#x27;:
      this.set(&#x27;etag fn&#x27;, compileETag(val));
      break;
    case &#x27;query parser&#x27;:
      this.set(&#x27;query parser fn&#x27;, compileQueryParser(val));
      break;
    case &#x27;trust proxy&#x27;:
      this.set(&#x27;trust proxy fn&#x27;, compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For example, to listen on the specified port and all hosts, and ignore app config.
* ```js
* app.listen(80);
* ```
*
* The function also installs a `listening` callback that calls
* `app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;port&#x27;)` with the value returned by `server.address().port`.
* This way the port param contains always the real port number, even when
* listen was called with port number 0.
*
* @param {Function} [cb] If specified, the callback is added as a listener
*   for the server&#x27;s &#x22;listening&#x22; event.
* @returns {http.Server} A node `http.Server` with this application configured
*   as the request handler.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.subscribe" id="apidoc.element.loopback.application.subscribe">
        function <span class="apidocSignatureSpan">loopback.application.</span>subscribe
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.trace" id="apidoc.element.loopback.application.trace">
        function <span class="apidocSignatureSpan">loopback.application.</span>trace
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.unbind" id="apidoc.element.loopback.application.unbind">
        function <span class="apidocSignatureSpan">loopback.application.</span>unbind
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbind = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.unlink" id="apidoc.element.loopback.application.unlink">
        function <span class="apidocSignatureSpan">loopback.application.</span>unlink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.unlock" id="apidoc.element.loopback.application.unlock">
        function <span class="apidocSignatureSpan">loopback.application.</span>unlock
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.unsubscribe" id="apidoc.element.loopback.application.unsubscribe">
        function <span class="apidocSignatureSpan">loopback.application.</span>unsubscribe
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function (path){
  if (method === &#x27;get&#x27; &#x26;&#x26; arguments.length === 1) {
    // app.get(setting)
    return this.set(path);
  }

  this.lazyrouter();

  var route = this._router.route(path);
  route[method].apply(route, slice.call(arguments, 1));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.application.use" id="apidoc.element.loopback.application.use">
        function <span class="apidocSignatureSpan">loopback.application.</span>use
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(fn) {
  var offset = 0;
  var path = &#x27;/&#x27;;

  // default path to &#x27;/&#x27;
  // disambiguate app.use([fn])
  if (typeof fn !== &#x27;function&#x27;) {
    var arg = fn;

    while (Array.isArray(arg) &#x26;&#x26; arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== &#x27;function&#x27;) {
      offset = 1;
      path = fn;
    }
  }

  var fns = flatten(slice.call(arguments, offset));

  if (fns.length === 0) {
    throw new TypeError(&#x27;app.use() requires middleware functions&#x27;);
  }

  // setup router
  this.lazyrouter();
  var router = this._router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router.use(path, fn);
    }

    debug(&#x27;.use app under %s&#x27;, path);
    fn.mountpath = path;
    fn.parent = this;

    // restore .app property on req and res
    router.use(path, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        setPrototyeOf(req, orig.request)
        setPrototyeOf(res, orig.response)
        next(err);
      });
    });

    // mounted an app
    fn.emit(&#x27;mount&#x27;, this);
  }, this);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (this._requestHandlingPhases.indexOf(name) === -1)
  throw new Error(g.f(&#x27;Unknown {{middleware}} phase %s&#x27;, name));

debug(&#x27;use %s %s %s&#x27;, fullPhaseName, paths, handlerName);

this._skipLayerSorting = true;
this.<span class="apidocCodeKeywordSpan">use</span>(paths, handler);

var layer = this._findLayerByHandler(handler);
if (layer) {
  // Set the phase name for sorting
  layer.phase = fullPhaseName;
} else {
  debug(&#x27;No matching layer is found for %s %s&#x27;, fullPhaseName, handlerName);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.index" id="apidoc.module.loopback.index">module loopback.index</a></h1>






    <h2>
        <a href="#apidoc.element.loopback.index.index" id="apidoc.element.loopback.index.index">
        function <span class="apidocSignatureSpan">loopback.</span>index
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createApplication(options) {
  var app = loopbackExpress();

  merge(app, proto);

  app.loopback = loopback;

  // Create a new instance of models registry per each app instance
  app.models = function() {
    return proto.models.apply(this, arguments);
  };

  // Create a new instance of datasources registry per each app instance
  app.datasources = app.dataSources = {};

  // Create a new instance of connector registry per each app instance
  app.connectors = {};

  // Register built-in connectors. It&#x27;s important to keep this code
  // hand-written, so that all require() calls are static
  // and thus browserify can process them (include connectors in the bundle)
  app.connector(&#x27;memory&#x27;, loopback.Memory);
  app.connector(&#x27;remote&#x27;, loopback.Remote);
  app.connector(&#x27;kv-memory&#x27;,
    require(&#x27;loopback-datasource-juggler/lib/connectors/kv-memory&#x27;));

  if (loopback.localRegistry || options &#x26;&#x26; options.localRegistry === true) {
    // setup the app registry
    var registry = app.registry = new Registry();
    if (options &#x26;&#x26; options.loadBuiltinModels === true) {
      require(&#x27;./builtin-models&#x27;)(registry);
    }
  } else {
    app.registry = loopback.registry;
  }

  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.ACL" id="apidoc.element.loopback.index.ACL">
        function <span class="apidocSignatureSpan">loopback.index.</span>ACL
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.AccessToken" id="apidoc.element.loopback.index.AccessToken">
        function <span class="apidocSignatureSpan">loopback.index.</span>AccessToken
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Application" id="apidoc.element.loopback.index.Application">
        function <span class="apidocSignatureSpan">loopback.index.</span>Application
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Change" id="apidoc.element.loopback.index.Change">
        function <span class="apidocSignatureSpan">loopback.index.</span>Change
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Checkpoint" id="apidoc.element.loopback.index.Checkpoint">
        function <span class="apidocSignatureSpan">loopback.index.</span>Checkpoint
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Connector" id="apidoc.element.loopback.index.Connector">
        function <span class="apidocSignatureSpan">loopback.index.</span>Connector
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connector(options) {
  EventEmitter.apply(this, arguments);
  this.options = options;

  debug(&#x27;created with options&#x27;, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.DataSource" id="apidoc.element.loopback.index.DataSource">
        function <span class="apidocSignatureSpan">loopback.index.</span>DataSource
        <span class="apidocSignatureSpan">(name, settings, modelBuilder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataSource(name, settings, modelBuilder) {
  if (!(this instanceof DataSource)) {
    return new DataSource(name, settings);
  }

  // Check if the settings object is passed as the first argument
  if (typeof name === &#x27;object&#x27; &#x26;&#x26; settings === undefined) {
    settings = name;
    name = undefined;
  }

  // Check if the first argument is a URL
  if (typeof name === &#x27;string&#x27; &#x26;&#x26; name.indexOf(&#x27;://&#x27;) !== -1) {
    name = utils.parseSettings(name);
  }

  // Check if the settings is in the form of URL string
  if (typeof settings === &#x27;string&#x27; &#x26;&#x26; settings.indexOf(&#x27;://&#x27;) !== -1) {
    settings = utils.parseSettings(settings);
  }

  this.modelBuilder = modelBuilder || new ModelBuilder();
  this.models = this.modelBuilder.models;
  this.definitions = this.modelBuilder.definitions;
  this.juggler = juggler;

  // operation metadata
  // Initialize it before calling setup as the connector might register operations
  this._operations = {};

  this.setup(name, settings);

  this._setupConnector();

  // connector
  var connector = this.connector;

  // DataAccessObject - connector defined or supply the default
  var dao = (connector &#x26;&#x26; connector.DataAccessObject) || this.constructor.DataAccessObject;
  this.DataAccessObject = function() {
  };

  // define DataAccessObject methods
  Object.keys(dao).forEach(function(name) {
    var fn = dao[name];
    this.DataAccessObject[name] = fn;

    if (typeof fn === &#x27;function&#x27;) {
      this.defineOperation(name, {
        accepts: fn.accepts,
        &#x27;returns&#x27;: fn.returns,
        http: fn.http,
        remoteEnabled: fn.shared ? true : false,
        scope: this.DataAccessObject,
        fnName: name,
      });
    }
  }.bind(this));

  // define DataAccessObject.prototype methods
  Object.keys(dao.prototype).forEach(function(name) {
    var fn = dao.prototype[name];
    this.DataAccessObject.prototype[name] = fn;
    if (typeof fn === &#x27;function&#x27;) {
      this.defineOperation(name, {
        prototype: true,
        accepts: fn.accepts,
        &#x27;returns&#x27;: fn.returns,
        http: fn.http,
        remoteEnabled: fn.shared ? true : false,
        scope: this.DataAccessObject.prototype,
        fnName: name,
      });
    }
  }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Email" id="apidoc.element.loopback.index.Email">
        function <span class="apidocSignatureSpan">loopback.index.</span>Email
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.GeoPoint" id="apidoc.element.loopback.index.GeoPoint">
        function <span class="apidocSignatureSpan">loopback.index.</span>GeoPoint
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GeoPoint(data) {
  if (!(this instanceof GeoPoint)) {
    return new GeoPoint(data);
  }

  if (arguments.length === 2) {
    data = {
      lat: arguments[0],
      lng: arguments[1],
    };
  }

  assert(Array.isArray(data) || typeof data === &#x27;object&#x27; || typeof data === &#x27;string&#x27;,
    &#x27;must provide valid geo-coordinates array [lat, lng] or object or a &#x22;lat, lng&#x22; string&#x27;);

  if (typeof data === &#x27;string&#x27;) {
    try {
      data = JSON.parse(data);
    } catch (err) {
      data = data.split(/,\s*/);
      assert(data.length === 2, &#x27;must provide a string &#x22;lat,lng&#x22; creating a GeoPoint with a string&#x27;);
    }
  }
  if (Array.isArray(data)) {
    data = {
      lat: Number(data[0]),
      lng: Number(data[1]),
    };
  } else {
    data.lng = Number(data.lng);
    data.lat = Number(data.lat);
  }

  assert(typeof data === &#x27;object&#x27;, &#x27;must provide a lat and lng object when creating a GeoPoint&#x27;);
  assert(typeof data.lat === &#x27;number&#x27; &#x26;&#x26; !isNaN(data.lat), &#x27;lat must be a number when creating a GeoPoint&#x27;);
  assert(typeof data.lng === &#x27;number&#x27; &#x26;&#x26; !isNaN(data.lng), &#x27;lng must be a number when creating a GeoPoint&#x27;);
  assert(data.lng &#x3c;= 180, &#x27;lng must be &#x3c;= 180&#x27;);
  assert(data.lng &#x3e;= -180, &#x27;lng must be &#x3e;= -180&#x27;);
  assert(data.lat &#x3c;= 90, &#x27;lat must be &#x3c;= 90&#x27;);
  assert(data.lat &#x3e;= -90, &#x27;lat must be &#x3e;= -90&#x27;);

  this.lat = data.lat;
  this.lng = data.lng;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.KeyValueModel" id="apidoc.element.loopback.index.KeyValueModel">
        function <span class="apidocSignatureSpan">loopback.index.</span>KeyValueModel
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Mail" id="apidoc.element.loopback.index.Mail">
        function <span class="apidocSignatureSpan">loopback.index.</span>Mail
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MailConnector(settings) {
  assert(typeof settings === &#x27;object&#x27;, &#x27;cannot initialize MailConnector without a settings object&#x27;);

  var transports = settings.transports;

  // if transports is not in settings object AND settings.transport exists
  if (!transports &#x26;&#x26; settings.transport) {
    // then wrap single transport in an array and assign to transports
    transports = [settings.transport];
  }

  if (!transports) {
    transports = [];
  }

  this.transportsIndex = {};
  this.transports = [];

  if (loopback.isServer) {
    transports.forEach(this.setupTransport.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Memory" id="apidoc.element.loopback.index.Memory">
        function <span class="apidocSignatureSpan">loopback.index.</span>Memory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Memory() {
  // TODO implement entire memory connector
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Remote" id="apidoc.element.loopback.index.Remote">
        function <span class="apidocSignatureSpan">loopback.index.</span>Remote
        <span class="apidocSignatureSpan">(settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RemoteConnector(settings) {
  assert(typeof settings ===
    &#x27;object&#x27;,
    &#x27;cannot initiaze RemoteConnector without a settings object&#x27;);
  this.client = settings.client;
  this.adapter = settings.adapter || &#x27;rest&#x27;;
  this.protocol = settings.protocol || &#x27;http&#x27;;
  this.root = settings.root || &#x27;&#x27;;
  this.host = settings.host || &#x27;localhost&#x27;;
  this.port = settings.port || 3000;
  this.remotes = remoting.create();
  this.name = &#x27;remote-connector&#x27;;

  if (settings.url) {
    this.url = settings.url;
  } else {
    this.url = this.protocol + &#x27;://&#x27; + this.host + &#x27;:&#x27; + this.port + this.root;
  }

  // handle mixins in the define() method
  var DAO = this.DataAccessObject = function() {
  };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Role" id="apidoc.element.loopback.index.Role">
        function <span class="apidocSignatureSpan">loopback.index.</span>Role
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.RoleMapping" id="apidoc.element.loopback.index.RoleMapping">
        function <span class="apidocSignatureSpan">loopback.index.</span>RoleMapping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Route" id="apidoc.element.loopback.index.Route">
        function <span class="apidocSignatureSpan">loopback.index.</span>Route
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Route(path) {
  this.path = path;
  this.stack = [];

  debug(&#x27;new %o&#x27;, path)

  // route handlers for various http methods
  this.methods = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Router" id="apidoc.element.loopback.index.Router">
        function <span class="apidocSignatureSpan">loopback.index.</span>Router
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setPrototypeOf(router, proto)

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.Scope" id="apidoc.element.loopback.index.Scope">
        function <span class="apidocSignatureSpan">loopback.index.</span>Scope
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.User" id="apidoc.element.loopback.index.User">
        function <span class="apidocSignatureSpan">loopback.index.</span>User
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ModelConstructor(data, options) {
  if (!(this instanceof ModelConstructor)) {
    return new ModelConstructor(data, options);
  }
  if (ModelClass.settings.unresolved) {
    throw new Error(g.f(&#x27;Model %s is not defined.&#x27;, ModelClass.modelName));
  }
  ModelBaseClass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.ValidationError" id="apidoc.element.loopback.index.ValidationError">
        function <span class="apidocSignatureSpan">loopback.index.</span>ValidationError
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(obj) {
  if (!(this instanceof ValidationError)) return new ValidationError(obj);

  this.name = &#x27;ValidationError&#x27;;

  var context = obj &#x26;&#x26; obj.constructor &#x26;&#x26; obj.constructor.modelName;
  this.message = g.f(
    &#x27;The %s instance is not valid. Details: %s.&#x27;,
      context ? &#x27;`&#x27; + context + &#x27;`&#x27; : &#x27;model&#x27;,
      formatErrors(obj.errors, obj.toJSON()) || &#x27;(unknown)&#x27;
  );

  this.statusCode = 422;

  this.details = {
    context: context,
    codes: obj.errors &#x26;&#x26; obj.errors.codes,
    messages: obj.errors,
  };

  if (Error.captureStackTrace) {
    // V8 (Chrome, Opera, Node)
    Error.captureStackTrace(this, this.constructor);
  } else if (errorHasStackProperty) {
    // Firefox
    this.stack = (new Error).stack;
  }
  // Safari and PhantomJS initializes `error.stack` on throw
  // Internet Explorer does not support `error.stack`
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return save();
}

inst.isValid(function(valid) {
  if (valid) {
    save();
  } else {
    var err = new Model.<span class="apidocCodeKeywordSpan">ValidationError</span>(inst);
    // throws option is dangerous for async usage
    if (options.throws) {
      throw err;
    }
    callback(err, inst);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.configureModel" id="apidoc.element.loopback.index.configureModel">
        function <span class="apidocSignatureSpan">loopback.index.</span>configureModel
        <span class="apidocSignatureSpan">(ModelCtor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configureModel = function (ModelCtor, config) {
  return this.registry.configureModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

config = extend({}, config);
config.dataSource = dataSource;

setSharedMethodSharedProperties(ModelCtor, app, config);

app.registry.<span class="apidocCodeKeywordSpan">configureModel</span>(ModelCtor, config);
}

function setSharedMethodSharedProperties(model, app, modelConfigs) {
var settings = {};

// apply config.json settings
var config = app.get(&#x27;remoting&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.context" id="apidoc.element.loopback.index.context">
        function <span class="apidocSignatureSpan">loopback.index.</span>context
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function () {
  throw new Error(g.f(
    &#x27;%s middleware was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback#context&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.createContext" id="apidoc.element.loopback.index.createContext">
        function <span class="apidocSignatureSpan">loopback.index.</span>createContext
        <span class="apidocSignatureSpan">(scopeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContext = function (scopeName) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.createContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      &#x27;loopback.runInContext()&#x27;,
      &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
  };

  loopback.createContext = function(scopeName) {
    throw new Error(g.f(
      &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
      &#x27;loopback.<span class="apidocCodeKeywordSpan">createContext</span>()&#x27;,
      &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
  };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.createDataSource" id="apidoc.element.loopback.index.createDataSource">
        function <span class="apidocSignatureSpan">loopback.index.</span>createDataSource
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDataSource = function (name, options) {
  return this.registry.createDataSource.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      config.connector = require(connectorPath);
    }
  }
  if (config.connector &#x26;&#x26; typeof config.connector === &#x27;object&#x27; &#x26;&#x26; !config.connector.name)
    config.connector.name = name;
}

return registry.<span class="apidocCodeKeywordSpan">createDataSource</span>(config);
}

function configureModel(ModelCtor, config, app) {
assert(ModelCtor.prototype instanceof ModelCtor.registry.getModel(&#x27;Model&#x27;),
  ModelCtor.modelName + &#x27; must be a descendant of loopback.Model&#x27;);

var dataSource = config.dataSource;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.createModel" id="apidoc.element.loopback.index.createModel">
        function <span class="apidocSignatureSpan">loopback.index.</span>createModel
        <span class="apidocSignatureSpan">(name, properties, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createModel = function (name, properties, options) {
  return this.registry.createModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

app.model = function(Model, config) {
var isPublic = true;
var registry = this.registry;

if (typeof Model === &#x27;string&#x27;) {
  var msg = &#x27;app.model(modelName, settings) is no longer supported. &#x27; +
    &#x27;Use app.registry.<span class="apidocCodeKeywordSpan">createModel</span>(modelName, definition) and &#x27; +
    &#x27;app.model(ModelCtor, config) instead.&#x27;;
  throw new Error(msg);
}

if (arguments.length &#x3e; 1) {
  config = config || {};
  configureModel(Model, config, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.errorHandler" id="apidoc.element.loopback.index.errorHandler">
        function <span class="apidocSignatureSpan">loopback.index.</span>errorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorHandler = function (options) {
  throw new Error(&#x27;loopback.errorHandler is no longer available.&#x27; +
  &#x27; Please use the module &#x22;strong-error-handler&#x22; instead.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.favicon" id="apidoc.element.loopback.index.favicon">
        function <span class="apidocSignatureSpan">loopback.index.</span>favicon
        <span class="apidocSignatureSpan">(icon, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">favicon = function (icon, options) {
  icon = icon || path.join(__dirname, &#x27;../../favicon.ico&#x27;);
  return favicon(icon, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x27;use strict&#x27;;
var favicon = require(&#x27;serve-favicon&#x27;);
var path = require(&#x27;path&#x27;);

/**
 * Serve the LoopBack favicon.
 * @header loopback.<span class="apidocCodeKeywordSpan">favicon</span>()
 */
module.exports = function(icon, options) {
  icon = icon || path.join(__dirname, &#x27;../../favicon.ico&#x27;);
  return favicon(icon, options);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.findModel" id="apidoc.element.loopback.index.findModel">
        function <span class="apidocSignatureSpan">loopback.index.</span>findModel
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModel = function (modelName) {
  return this.registry.findModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // the principalType must either be &#x27;USER&#x27;
    if (p.type === Principal.USER) {
      return {id: p.id, principalType: p.type};
    }

    // or permit to resolve a valid user model
    var userModel = this.registry.<span class="apidocCodeKeywordSpan">findModel</span>(p.type);
    if (!userModel) continue;
    if (userModel.prototype instanceof BaseUser) {
      return {id: p.id, principalType: p.type};
    }
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.getCurrentContext" id="apidoc.element.loopback.index.getCurrentContext">
        function <span class="apidocSignatureSpan">loopback.index.</span>getCurrentContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCurrentContext = function () {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.getCurrentContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports = function(loopback) {
juggler.getCurrentContext =
remoting.getCurrentContext =
loopback.getCurrentContext = function() {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.<span class="apidocCodeKeywordSpan">getCurrentContext</span>()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
};

loopback.runInContext = function(fn) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.runInContext()&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.getModel" id="apidoc.element.loopback.index.getModel">
        function <span class="apidocSignatureSpan">loopback.index.</span>getModel
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModel = function (modelName) {
  return this.registry.getModel.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = context || {};

assert(context.registry,
  &#x27;Application registry is mandatory in AccessContext but missing in provided context&#x27;);
this.registry = context.registry;
this.principals = context.principals || [];
var model = context.model;
model = (&#x27;string&#x27; === typeof model) ? this.registry.<span class="apidocCodeKeywordSpan">getModel</span>(model) : model
;
this.model = model;
this.modelName = model &#x26;&#x26; model.modelName;

this.modelId = context.id || context.modelId;
this.property = context.property || AccessContext.ALL;

this.method = context.method;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.getModelByType" id="apidoc.element.loopback.index.getModelByType">
        function <span class="apidocSignatureSpan">loopback.index.</span>getModelByType
        <span class="apidocSignatureSpan">(modelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModelByType = function (modelType) {
  return this.registry.getModelByType.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.<span class="apidocCodeKeywordSpan">getModelByType</span>(aclModel);
  return _aclModel;
};

/**
 * Check if the given access token can invoke the specified method.
 *
 * @param {AccessToken} token The access token.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.memory" id="apidoc.element.loopback.index.memory">
        function <span class="apidocSignatureSpan">loopback.index.</span>memory
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memory = function (name) {
  return this.registry.memory.apply(this.registry, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.query" id="apidoc.element.loopback.index.query">
        function <span class="apidocSignatureSpan">loopback.index.</span>query
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function query(options) {
  var opts = Object.create(options || null);
  var queryparse = qs.parse;

  if (typeof options === &#x27;function&#x27;) {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined &#x26;&#x26; opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next){
    if (!req.query) {
      var val = parseUrl(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.remoteMethod" id="apidoc.element.loopback.index.remoteMethod">
        function <span class="apidocSignatureSpan">loopback.index.</span>remoteMethod
        <span class="apidocSignatureSpan">(fn, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteMethod = function (fn, options) {
  fn.shared = true;
  if (typeof options === &#x27;object&#x27;) {
    Object.keys(options).forEach(function(key) {
      fn[key] = options[key];
    });
  }
  fn.http = fn.http || {verb: &#x27;get&#x27;};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Enable remote invocation for the specified method.
* See [Remote methods](http://loopback.io/doc/en/lb2/Remote-methods.html) for more information.
*
* Static method example:
* ```js
* Model.myMethod();
* Model.<span class="apidocCodeKeywordSpan">remoteMethod</span>(&#x27;myMethod&#x27;);
* ```
*
* @param {String} name The name of the method.
* @param {Object} options The remoting options.
* See [Remote methods - Options](http://loopback.io/doc/en/lb2/Remote-methods.html#options).
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.rest" id="apidoc.element.loopback.index.rest">
        function <span class="apidocSignatureSpan">loopback.index.</span>rest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rest() {
  var handlers; // Cached handlers

  return function restApiHandler(req, res, next) {
    var app = req.app;
    var registry = app.registry;

    if (!handlers) {
      handlers = [];
      var remotingOptions = app.get(&#x27;remoting&#x27;) || {};

      var contextOptions = remotingOptions.context;
      if (contextOptions !== undefined &#x26;&#x26; contextOptions !== false) {
        throw new Error(g.f(
          &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
          &#x27;remoting.context option&#x27;,
          &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
      }

      if (app.isAuthEnabled) {
        var AccessToken = registry.getModelByType(&#x27;AccessToken&#x27;);
        handlers.push(loopback.token({model: AccessToken, app: app}));
      }

      handlers.push(function(req, res, next) {
        // Need to get an instance of the REST handler per request
        return app.handler(&#x27;rest&#x27;)(req, res, next);
      });
    }
    if (handlers.length === 1) {
      return handlers[0](req, res, next);
    }
    async.eachSeries(handlers, function(handler, done) {
      handler(req, res, done);
    }, next);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = rest;

/**
 * Expose models over REST.
 *
 * For example:
 * ```js
 * app.use(loopback.<span class="apidocCodeKeywordSpan">rest</span>());
 * ```
 * For more information, see [Exposing models over a REST API](http://loopback.io/doc/en/lb2/Exposing-models-over-REST.html).
 * @header loopback.rest()
 */

function rest() {
var handlers; // Cached handlers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.runInContext" id="apidoc.element.loopback.index.runInContext">
        function <span class="apidocSignatureSpan">loopback.index.</span>runInContext
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runInContext = function (fn) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.runInContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;loopback.getCurrentContext()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
};

loopback.runInContext = function(fn) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.<span class="apidocCodeKeywordSpan">runInContext</span>()&#x27;,
    &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
};

loopback.createContext = function(scopeName) {
  throw new Error(g.f(
    &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
    &#x27;loopback.createContext()&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.static" id="apidoc.element.loopback.index.static">
        function <span class="apidocSignatureSpan">loopback.index.</span>static
        <span class="apidocSignatureSpan">(root, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serveStatic(root, options) {
  if (!root) {
    throw new TypeError(&#x27;root path required&#x27;)
  }

  if (typeof root !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;root path must be a string&#x27;)
  }

  // copy options object
  var opts = Object.create(options || null)

  // fall-though
  var fallthrough = opts.fallthrough !== false

  // default redirect
  var redirect = opts.redirect !== false

  // headers listener
  var setHeaders = opts.setHeaders

  if (setHeaders &#x26;&#x26; typeof setHeaders !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;option setHeaders must be function&#x27;)
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0
  opts.root = resolve(root)

  // construct directory listener
  var onDirectory = redirect
    ? createRedirectDirectoryListener()
    : createNotFoundDirectoryListener()

  return function serveStatic (req, res, next) {
    if (req.method !== &#x27;GET&#x27; &#x26;&#x26; req.method !== &#x27;HEAD&#x27;) {
      if (fallthrough) {
        return next()
      }

      // method not allowed
      res.statusCode = 405
      res.setHeader(&#x27;Allow&#x27;, &#x27;GET, HEAD&#x27;)
      res.setHeader(&#x27;Content-Length&#x27;, &#x27;0&#x27;)
      res.end()
      return
    }

    var forwardError = !fallthrough
    var originalUrl = parseUrl.original(req)
    var path = parseUrl(req).pathname

    // make sure redirect occurs at mount
    if (path === &#x27;/&#x27; &#x26;&#x26; originalUrl.pathname.substr(-1) !== &#x27;/&#x27;) {
      path = &#x27;&#x27;
    }

    // create send stream
    var stream = send(req, path, opts)

    // add directory handler
    stream.on(&#x27;directory&#x27;, onDirectory)

    // add headers listener
    if (setHeaders) {
      stream.on(&#x27;headers&#x27;, setHeaders)
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on(&#x27;file&#x27;, function onFile () {
        // once file is determined, always forward error
        forwardError = true
      })
    }

    // forward errors
    stream.on(&#x27;error&#x27;, function error (err) {
      if (forwardError || !(err.statusCode &#x3c; 500)) {
        next(err)
        return
      }

      next()
    })

    // pipe
    stream.pipe(res)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Serve static assets of a LoopBack application.
 *
 * @param {string} root The root directory from which the static assets are to
 * be served.
 * @param {object} options Refer to
 *   [express documentation](http://expressjs.com/4x/api.html#express.static)
 *   for the full list of available options.
 * @header loopback.<span class="apidocCodeKeywordSpan">static</span>(root, [options])
 */
&#x27;use strict&#x27;;
module.exports = require(&#x27;express&#x27;).static;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.status" id="apidoc.element.loopback.index.status">
        function <span class="apidocSignatureSpan">loopback.index.</span>status
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function status() {
  var started = new Date();

  return function(req, res) {
    res.send({
      started: started,
      uptime: (Date.now() - Number(started)) / 1000,
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

UserModel.afterRemote(&#x27;confirm&#x27;, function(ctx, inst, next) {
  if (ctx.args.redirect !== undefined) {
    if (!ctx.res) {
      return next(new Error(g.f(&#x27;The transport does not support HTTP redirects.&#x27;)));
    }
    ctx.res.location(ctx.args.redirect);
    ctx.res.<span class="apidocCodeKeywordSpan">status</span>(302);
  }
  next();
});

// default models
assert(loopback.Email, &#x27;Email model must be defined before User model&#x27;);
UserModel.email = loopback.Email;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.template" id="apidoc.element.loopback.index.template">
        function <span class="apidocSignatureSpan">loopback.index.</span>template
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">template = function (file) {
  var templates = this._templates || (this._templates = {});
  var str = templates[file] || (templates[file] = fs.readFileSync(file, &#x27;utf8&#x27;));
  return ejs.compile(str, {
    filename: file,
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      });
    }
  }
  return fn.promise;
};

function createVerificationEmailBody(options, cb) {
  var template = loopback.<span class="apidocCodeKeywordSpan">template</span>(options.template);
  var body = template(options);
  cb(null, body);
}

/**
 * A default verification token generator which accepts the user the token is
 * being generated for and a callback function to indicate completion.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.token" id="apidoc.element.loopback.index.token">
        function <span class="apidocSignatureSpan">loopback.index.</span>token
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(options) {
  options = options || {};
  var TokenModel;

  var currentUserLiteral = options.currentUserLiteral;
  if (currentUserLiteral &#x26;&#x26; (typeof currentUserLiteral !== &#x27;string&#x27;)) {
    debug(&#x27;Set currentUserLiteral to \&#x27;me\&#x27; as the value is not a string.&#x27;);
    currentUserLiteral = &#x27;me&#x27;;
  }
  if (typeof currentUserLiteral === &#x27;string&#x27;) {
    currentUserLiteral = escapeRegExp(currentUserLiteral);
  }

  var enableDoublecheck = !!options.enableDoublecheck;
  var overwriteExistingToken = !!options.overwriteExistingToken;

  return function(req, res, next) {
    var app = req.app;
    var registry = app.registry;
    if (!TokenModel) {
      TokenModel = registry.getModel(options.model || &#x27;AccessToken&#x27;);
    }

    assert(typeof TokenModel === &#x27;function&#x27;,
      &#x27;loopback.token() middleware requires a AccessToken model&#x27;);

    if (req.accessToken !== undefined) {
      if (!enableDoublecheck) {
        // req.accessToken is defined already (might also be &#x22;null&#x22; or &#x22;false&#x22;) and enableDoublecheck
        // has not been set --&#x3e; skip searching for credentials
        rewriteUserLiteral(req, currentUserLiteral);
        return next();
      }
      if (req.accessToken &#x26;&#x26; req.accessToken.id &#x26;&#x26; !overwriteExistingToken) {
        // req.accessToken.id is defined, which means that some other middleware has identified a valid user.
        // when overwriteExistingToken is not set to a truthy value, skip searching for credentials.
        rewriteUserLiteral(req, currentUserLiteral);
        return next();
      }
      // continue normal operation (as if req.accessToken was undefined)
    }
    TokenModel.findForRequest(req, options, function(err, token) {
      req.accessToken = token || null;
      rewriteUserLiteral(req, currentUserLiteral);
      var ctx = req.loopbackContext;
      if (ctx &#x26;&#x26; ctx.active) ctx.set(&#x27;accessToken&#x27;, token);
      next(err);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      &#x27;%s was removed in version 3.0. See %s for more details.&#x27;,
      &#x27;remoting.context option&#x27;,
      &#x27;http://loopback.io/doc/en/lb2/Using-current-context.html&#x27;));
  }

  if (app.isAuthEnabled) {
    var AccessToken = registry.getModelByType(&#x27;AccessToken&#x27;);
    handlers.push(loopback.<span class="apidocCodeKeywordSpan">token</span>({model: AccessToken, app: app}));
  }

  handlers.push(function(req, res, next) {
    // Need to get an instance of the REST handler per request
    return app.handler(&#x27;rest&#x27;)(req, res, next);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.index.urlNotFound" id="apidoc.element.loopback.index.urlNotFound">
        function <span class="apidocSignatureSpan">loopback.index.</span>urlNotFound
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlNotFound() {
  return function raiseUrlNotFoundError(req, res, next) {
    var error = new Error(&#x27;Cannot &#x27; + req.method + &#x27; &#x27; + req.url);
    error.status = 404;
    next(error);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
&#x27;use strict&#x27;;
module.exports = urlNotFound;

/**
 * Convert any request not handled so far to a 404 error
 * to be handled by error-handling middleware.
 * @header loopback.<span class="apidocCodeKeywordSpan">urlNotFound</span>()
 */
function urlNotFound() {
return function raiseUrlNotFoundError(req, res, next) {
  var error = new Error(&#x27;Cannot &#x27; + req.method + &#x27; &#x27; + req.url);
  error.status = 404;
  next(error);
};
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.registry" id="apidoc.module.loopback.registry">module loopback.registry</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.registry.registry" id="apidoc.element.loopback.registry.registry">
        function <span class="apidocSignatureSpan">loopback.</span>registry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Registry() {
  this.defaultDataSources = {};
  this.modelBuilder = new ModelBuilder();
  require(&#x27;./model&#x27;)(this);
  require(&#x27;./persisted-model&#x27;)(this);

  // Set the default model base class.
  this.modelBuilder.defaultModelBaseClass = this.getModel(&#x27;Model&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.registry.prototype" id="apidoc.module.loopback.registry.prototype">module loopback.registry.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.registry.prototype._defineRemoteMethods" id="apidoc.element.loopback.registry.prototype._defineRemoteMethods">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>_defineRemoteMethods
        <span class="apidocSignatureSpan">(ModelCtor, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineRemoteMethods = function (ModelCtor, methods) {
  if (!methods) return;
  if (typeof methods !== &#x27;object&#x27;) {
    g.warn(&#x27;Ignoring non-object &#x22;methods&#x22; setting of &#x22;%s&#x22;.&#x27;,
      ModelCtor.modelName);
    return;
  }

  Object.keys(methods).forEach(function(key) {
    var meta = methods[key];
    var m = key.match(/^prototype\.(.*)$/);
    var isStatic = !m;

    if (typeof meta.isStatic !== &#x27;boolean&#x27;) {
      key = isStatic ? key : m[1];
      meta.isStatic = isStatic;
    } else if (meta.isStatic &#x26;&#x26; m) {
      throw new Error(g.f(&#x27;Remoting metadata for %s.%s {{&#x22;isStatic&#x22;}} does &#x27; +
      &#x27;not match new method name-based style.&#x27;, ModelCtor.modelName, key));
    } else {
      key = isStatic ? key : m[1];
      deprecated(g.f(&#x27;Remoting metadata {{&#x22;isStatic&#x22;}} is deprecated. Please &#x27; +
      &#x27;specify {{&#x22;prototype.name&#x22;}} in method name instead for {{isStatic=false}}.&#x27;));
    }
    ModelCtor.remoteMethod(key, meta);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

BaseModel = BaseModel || this.getModel(&#x27;PersistedModel&#x27;);
var model = BaseModel.extend(name, properties, options);
model.registry = this;

this.<span class="apidocCodeKeywordSpan">_defineRemoteMethods</span>(model, model.settings.methods);

return model;
};

function buildModelOptionsFromConfig(config) {
var options = extend({}, config.options);
for (var key in config) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.configureModel" id="apidoc.element.loopback.registry.prototype.configureModel">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>configureModel
        <span class="apidocSignatureSpan">(ModelCtor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configureModel = function (ModelCtor, config) {
  var settings = ModelCtor.settings;
  var modelName = ModelCtor.modelName;

  // Relations
  if (typeof config.relations === &#x27;object&#x27; &#x26;&#x26; config.relations !== null) {
    var relations = settings.relations = settings.relations || {};
    Object.keys(config.relations).forEach(function(key) {
      // FIXME: [rfeng] We probably should check if the relation exists
      relations[key] = extend(relations[key] || {}, config.relations[key]);
    });
  } else if (config.relations != null) {
    g.warn(&#x27;The relations property of `%s` configuration &#x27; +
      &#x27;must be an object&#x27;, modelName);
  }

  // ACLs
  if (Array.isArray(config.acls)) {
    var acls = settings.acls = settings.acls || [];
    config.acls.forEach(function(acl) {
      addACL(acls, acl);
    });
  } else if (config.acls != null) {
    g.warn(&#x27;The acls property of `%s` configuration &#x27; +
      &#x27;must be an array of objects&#x27;, modelName);
  }

  // Settings
  var excludedProperties = {
    base: true,
    &#x27;super&#x27;: true,
    relations: true,
    acls: true,
    dataSource: true,
  };
  if (typeof config.options === &#x27;object&#x27; &#x26;&#x26; config.options !== null) {
    for (var p in config.options) {
      if (!(p in excludedProperties)) {
        settings[p] = config.options[p];
      } else {
        g.warn(&#x27;Property `%s` cannot be reconfigured for `%s`&#x27;,
          p, modelName);
      }
    }
  } else if (config.options != null) {
    g.warn(&#x27;The options property of `%s` configuration &#x27; +
      &#x27;must be an object&#x27;, modelName);
  }

  // It&#x27;s important to attach the datasource after we have updated
  // configuration, so that the datasource picks up updated relations
  if (config.dataSource) {
    assert(config.dataSource instanceof DataSource,
        &#x27;Cannot configure &#x27; + ModelCtor.modelName +
        &#x27;: config.dataSource must be an instance of DataSource&#x27;);
    ModelCtor.attachTo(config.dataSource);
    debug(&#x27;Attached model `%s` to dataSource `%s`&#x27;,
      modelName, config.dataSource.name);
  } else if (config.dataSource === null || config.dataSource === false) {
    debug(&#x27;Model `%s` is not attached to any DataSource by configuration.&#x27;,
      modelName);
  } else {
    debug(&#x27;Model `%s` is not attached to any DataSource, possibly by a mistake.&#x27;,
      modelName);
    g.warn(
      &#x27;The configuration of `%s` is missing {{`dataSource`}} property.\n&#x27; +
      &#x27;Use `null` or `false` to mark models not attached to any data source.&#x27;,
      modelName);
  }

  var newMethodNames = config.methods &#x26;&#x26; Object.keys(config.methods);
  var hasNewMethods = newMethodNames &#x26;&#x26; newMethodNames.length;
  var hasDescendants = this.getModelByType(ModelCtor) !== ModelCtor;
  if (hasNewMethods &#x26;&#x26; hasDescendants) {
    g.warn(
      &#x27;Child models of `%s` will not inherit newly defined remote methods %s.&#x27;,
      modelName, newMethodNames);
  }

  // Remote methods
  this._defineRemoteMethods(ModelCtor, config.methods);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

config = extend({}, config);
config.dataSource = dataSource;

setSharedMethodSharedProperties(ModelCtor, app, config);

app.registry.<span class="apidocCodeKeywordSpan">configureModel</span>(ModelCtor, config);
}

function setSharedMethodSharedProperties(model, app, modelConfigs) {
var settings = {};

// apply config.json settings
var config = app.get(&#x27;remoting&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.createDataSource" id="apidoc.element.loopback.registry.prototype.createDataSource">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>createDataSource
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDataSource = function (name, options) {
  var self = this;

  var ds = new DataSource(name, options, self.modelBuilder);
  ds.createModel = function(name, properties, settings) {
    settings = settings || {};
    var BaseModel = settings.base || settings.super;
    if (!BaseModel) {
      // Check the connector types
      var connectorTypes = ds.getTypes();
      if (Array.isArray(connectorTypes) &#x26;&#x26; connectorTypes.indexOf(&#x27;db&#x27;) !== -1) {
        // Only set up the base model to PersistedModel if the connector is DB
        BaseModel = self.PersistedModel;
      } else {
        BaseModel = self.Model;
      }
      settings.base = BaseModel;
    }
    var ModelCtor = self.createModel(name, properties, settings);
    ModelCtor.attachTo(ds);
    return ModelCtor;
  };

  if (ds.settings &#x26;&#x26; ds.settings.defaultForType) {
    var msg = g.f(&#x27;{{DataSource}} option {{&#x22;defaultForType&#x22;}} is no longer supported&#x27;);
    throw new Error(msg);
  }

  return ds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      config.connector = require(connectorPath);
    }
  }
  if (config.connector &#x26;&#x26; typeof config.connector === &#x27;object&#x27; &#x26;&#x26; !config.connector.name)
    config.connector.name = name;
}

return registry.<span class="apidocCodeKeywordSpan">createDataSource</span>(config);
}

function configureModel(ModelCtor, config, app) {
assert(ModelCtor.prototype instanceof ModelCtor.registry.getModel(&#x27;Model&#x27;),
  ModelCtor.modelName + &#x27; must be a descendant of loopback.Model&#x27;);

var dataSource = config.dataSource;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.createModel" id="apidoc.element.loopback.registry.prototype.createModel">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>createModel
        <span class="apidocSignatureSpan">(name, properties, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createModel = function (name, properties, options) {
  if (arguments.length === 1 &#x26;&#x26; typeof name === &#x27;object&#x27;) {
    var config = name;
    name = config.name;
    properties = config.properties;
    options = buildModelOptionsFromConfig(config);

    assert(typeof name === &#x27;string&#x27;,
      &#x27;The model-config property `name` must be a string&#x27;);
  }

  options = options || {};
  var BaseModel = options.base || options.super;

  if (typeof BaseModel === &#x27;string&#x27;) {
    var baseName = BaseModel;
    BaseModel = this.findModel(BaseModel);
    if (!BaseModel) {
      throw new Error(g.f(&#x27;Model not found: model `%s` is extending an unknown model `%s`.&#x27;,
        name, baseName));
    }
  }

  BaseModel = BaseModel || this.getModel(&#x27;PersistedModel&#x27;);
  var model = BaseModel.extend(name, properties, options);
  model.registry = this;

  this._defineRemoteMethods(model, model.settings.methods);

  return model;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

app.model = function(Model, config) {
var isPublic = true;
var registry = this.registry;

if (typeof Model === &#x27;string&#x27;) {
  var msg = &#x27;app.model(modelName, settings) is no longer supported. &#x27; +
    &#x27;Use app.registry.<span class="apidocCodeKeywordSpan">createModel</span>(modelName, definition) and &#x27; +
    &#x27;app.model(ModelCtor, config) instead.&#x27;;
  throw new Error(msg);
}

if (arguments.length &#x3e; 1) {
  config = config || {};
  configureModel(Model, config, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.findModel" id="apidoc.element.loopback.registry.prototype.findModel">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>findModel
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModel = function (modelName) {
  if (typeof modelName === &#x27;function&#x27;) return modelName;
  return this.modelBuilder.models[modelName];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // the principalType must either be &#x27;USER&#x27;
    if (p.type === Principal.USER) {
      return {id: p.id, principalType: p.type};
    }

    // or permit to resolve a valid user model
    var userModel = this.registry.<span class="apidocCodeKeywordSpan">findModel</span>(p.type);
    if (!userModel) continue;
    if (userModel.prototype instanceof BaseUser) {
      return {id: p.id, principalType: p.type};
    }
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.getModel" id="apidoc.element.loopback.registry.prototype.getModel">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>getModel
        <span class="apidocSignatureSpan">(modelName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModel = function (modelName) {
  var model = this.findModel(modelName);
  if (model) return model;

  throw new Error(g.f(&#x27;Model not found: %s&#x27;, modelName));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
context = context || {};

assert(context.registry,
  &#x27;Application registry is mandatory in AccessContext but missing in provided context&#x27;);
this.registry = context.registry;
this.principals = context.principals || [];
var model = context.model;
model = (&#x27;string&#x27; === typeof model) ? this.registry.<span class="apidocCodeKeywordSpan">getModel</span>(model) : model
;
this.model = model;
this.modelName = model &#x26;&#x26; model.modelName;

this.modelId = context.id || context.modelId;
this.property = context.property || AccessContext.ALL;

this.method = context.method;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.getModelByType" id="apidoc.element.loopback.registry.prototype.getModelByType">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>getModelByType
        <span class="apidocSignatureSpan">(modelType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModelByType = function (modelType) {
  var type = typeof modelType;
  var accepted = [&#x27;function&#x27;, &#x27;string&#x27;];

  assert(accepted.indexOf(type) &#x3e; -1,
    &#x27;The model type must be a constructor or model name&#x27;);

  if (type === &#x27;string&#x27;) {
    modelType = this.getModel(modelType);
  }

  var models = this.modelBuilder.models;
  for (var m in models) {
    if (models[m].prototype instanceof modelType) {
      return models[m];
    }
  }
  return modelType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // The function is used as a setter
    _aclModel = ACL;
  }
  if (_aclModel) {
    return _aclModel;
  }
  var aclModel = registry.getModel(&#x27;ACL&#x27;);
  _aclModel = registry.<span class="apidocCodeKeywordSpan">getModelByType</span>(aclModel);
  return _aclModel;
};

/**
 * Check if the given access token can invoke the specified method.
 *
 * @param {AccessToken} token The access token.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.registry.prototype.memory" id="apidoc.element.loopback.registry.prototype.memory">
        function <span class="apidocSignatureSpan">loopback.registry.prototype.</span>memory
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memory = function (name) {
  name = name || &#x27;default&#x27;;
  var memory = (
    this._memoryDataSources || (this._memoryDataSources = {})
    )[name];

  if (!memory) {
    memory = this._memoryDataSources[name] = this.createDataSource({
      connector: &#x27;memory&#x27;,
    });
  }

  return memory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.request" id="apidoc.module.loopback.request">module loopback.request</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.request.accepts" id="apidoc.element.loopback.request.accepts">
        function <span class="apidocSignatureSpan">loopback.request.</span>accepts
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accepts = function (){
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.acceptsCharset" id="apidoc.element.loopback.request.acceptsCharset">
        function <span class="apidocSignatureSpan">loopback.request.</span>acceptsCharset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acceptsCharset = function () {
&#x22;use strict&#x22;
log.call(deprecate, message, site)
return fn.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.acceptsCharsets" id="apidoc.element.loopback.request.acceptsCharsets">
        function <span class="apidocSignatureSpan">loopback.request.</span>acceptsCharsets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acceptsCharsets = function (){
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.acceptsEncoding" id="apidoc.element.loopback.request.acceptsEncoding">
        function <span class="apidocSignatureSpan">loopback.request.</span>acceptsEncoding
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acceptsEncoding = function () {
&#x22;use strict&#x22;
log.call(deprecate, message, site)
return fn.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.acceptsEncodings" id="apidoc.element.loopback.request.acceptsEncodings">
        function <span class="apidocSignatureSpan">loopback.request.</span>acceptsEncodings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acceptsEncodings = function (){
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.acceptsLanguage" id="apidoc.element.loopback.request.acceptsLanguage">
        function <span class="apidocSignatureSpan">loopback.request.</span>acceptsLanguage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acceptsLanguage = function () {
&#x22;use strict&#x22;
log.call(deprecate, message, site)
return fn.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.acceptsLanguages" id="apidoc.element.loopback.request.acceptsLanguages">
        function <span class="apidocSignatureSpan">loopback.request.</span>acceptsLanguages
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acceptsLanguages = function (){
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.get" id="apidoc.element.loopback.request.get">
        function <span class="apidocSignatureSpan">loopback.request.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function header(name) {
  if (!name) {
    throw new TypeError(&#x27;name argument is required to req.get&#x27;);
  }

  if (typeof name !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;name must be a string to req.get&#x27;);
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case &#x27;referer&#x27;:
    case &#x27;referrer&#x27;:
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* supports Express middleware. See
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/&#x27;, function(req, res){
*   res.send(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.header" id="apidoc.element.loopback.request.header">
        function <span class="apidocSignatureSpan">loopback.request.</span>header
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function header(name) {
  if (!name) {
    throw new TypeError(&#x27;name argument is required to req.get&#x27;);
  }

  if (typeof name !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;name must be a string to req.get&#x27;);
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case &#x27;referer&#x27;:
    case &#x27;referrer&#x27;:
      return this.headers.referrer
        || this.headers.referer;
    default:
      return this.headers[lc];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof id === &#x27;string&#x27;) {
  return id;
}
    }

    for (i = 0, length = headers.length; i &#x3c; length; i++) {
id = req.<span class="apidocCodeKeywordSpan">header</span>(headers[i]);

if (typeof id === &#x27;string&#x27;) {
  // Add support for oAuth 2.0 bearer token
  // http://tools.ietf.org/html/rfc6750
  if (id.indexOf(&#x27;Bearer &#x27;) === 0) {
    id = id.substring(7);
    // Decode from base64
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.is" id="apidoc.element.loopback.request.is">
        function <span class="apidocSignatureSpan">loopback.request.</span>is
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i &#x3c; arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeis(this, arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.param" id="apidoc.element.loopback.request.param">
        function <span class="apidocSignatureSpan">loopback.request.</span>param
        <span class="apidocSignatureSpan">(name, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function param(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};

  var args = arguments.length === 1
    ? &#x27;name&#x27;
    : &#x27;name, default&#x27;;
  deprecate(&#x27;req.param(&#x27; + args + &#x27;): Use req.params, req.body, or req.query instead&#x27;);

  if (null != params[name] &#x26;&#x26; params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];

  return defaultValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  remotes.authorization = function(ctx, next) {
var method = ctx.method;
var req = ctx.req;
var Model = method.ctor;
var modelInstance = ctx.instance;

var modelId = modelInstance &#x26;&#x26; modelInstance.id ||
  // replacement for deprecated req.<span class="apidocCodeKeywordSpan">param</span>()
  (req.params &#x26;&#x26; req.params.id !== undefined ? req.params.id :
   req.body &#x26;&#x26; req.body.id !== undefined ? req.body.id :
   req.query &#x26;&#x26; req.query.id !== undefined ? req.query.id :
   undefined);

var modelName = Model.modelName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.request.range" id="apidoc.element.loopback.request.range">
        function <span class="apidocSignatureSpan">loopback.request.</span>range
        <span class="apidocSignatureSpan">(size, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function range(size, options) {
  var range = this.get(&#x27;Range&#x27;);
  if (!range) return;
  return parseRange(size, range, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.response" id="apidoc.module.loopback.response">module loopback.response</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.response.append" id="apidoc.element.loopback.response.append">
        function <span class="apidocSignatureSpan">loopback.response.</span>append
        <span class="apidocSignatureSpan">(field, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
      : [prev, val];
  }

  return this.set(field, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.attachment" id="apidoc.element.loopback.response.attachment">
        function <span class="apidocSignatureSpan">loopback.response.</span>attachment
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set(&#x27;Content-Disposition&#x27;, contentDisposition(filename));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.clearCookie" id="apidoc.element.loopback.response.clearCookie">
        function <span class="apidocSignatureSpan">loopback.response.</span>clearCookie
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearCookie(name, options) {
  var opts = merge({ expires: new Date(1), path: &#x27;/&#x27; }, options);

  return this.cookie(name, &#x27;&#x27;, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.contentType" id="apidoc.element.loopback.response.contentType">
        function <span class="apidocSignatureSpan">loopback.response.</span>contentType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function contentType(type) {
  var ct = type.indexOf(&#x27;/&#x27;) === -1
    ? mime.lookup(type)
    : type;

  return this.set(&#x27;Content-Type&#x27;, ct);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.cookie" id="apidoc.element.loopback.response.cookie">
        function <span class="apidocSignatureSpan">loopback.response.</span>cookie
        <span class="apidocSignatureSpan">(name, value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cookie = function (name, value, options) {
  var opts = merge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed &#x26;&#x26; !secret) {
    throw new Error(&#x27;cookieParser(&#x22;secret&#x22;) required for signed cookies&#x27;);
  }

  var val = typeof value === &#x27;object&#x27;
    ? &#x27;j:&#x27; + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = &#x27;s:&#x27; + sign(val, secret);
  }

  if (&#x27;maxAge&#x27; in opts) {
    opts.expires = new Date(Date.now() + opts.maxAge);
    opts.maxAge /= 1000;
  }

  if (opts.path == null) {
    opts.path = &#x27;/&#x27;;
  }

  this.append(&#x27;Set-Cookie&#x27;, cookie.serialize(name, String(val), opts));

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.download" id="apidoc.element.loopback.response.download">
        function <span class="apidocSignatureSpan">loopback.response.</span>download
        <span class="apidocSignatureSpan">(path, filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function download(path, filename, callback) {
  var done = callback;
  var name = filename;

  // support function as second arg
  if (typeof filename === &#x27;function&#x27;) {
    done = filename;
    name = null;
  }

  // set Content-Disposition when file is sent
  var headers = {
    &#x27;Content-Disposition&#x27;: contentDisposition(name || path)
  };

  // Resolve the full path for sendFile
  var fullPath = resolve(path);

  return this.sendFile(fullPath, { headers: headers }, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.format" id="apidoc.element.loopback.response.format">
        function <span class="apidocSignatureSpan">loopback.response.</span>format
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (obj){
  var req = this.req;
  var next = req.next;

  var fn = obj.default;
  if (fn) delete obj.default;
  var keys = Object.keys(obj);

  var key = keys.length &#x3e; 0
    ? req.accepts(keys)
    : false;

  this.vary(&#x22;Accept&#x22;);

  if (key) {
    this.set(&#x27;Content-Type&#x27;, normalizeType(key).value);
    obj[key](req, this, next);
  } else if (fn) {
    fn();
  } else {
    var err = new Error(&#x27;Not Acceptable&#x27;);
    err.status = err.statusCode = 406;
    err.types = normalizeTypes(keys).map(function(o){ return o.value });
    next(err);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.get" id="apidoc.element.loopback.response.get">
        function <span class="apidocSignatureSpan">loopback.response.</span>get
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (field){
  return this.getHeader(field);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* supports Express middleware. See
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/&#x27;, function(req, res){
*   res.send(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.header" id="apidoc.element.loopback.response.header">
        function <span class="apidocSignatureSpan">loopback.response.</span>header
        <span class="apidocSignatureSpan">(field, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === &#x27;content-type&#x27; &#x26;&#x26; !charsetRegExp.test(value)) {
      var charset = mime.charsets.lookup(value.split(&#x27;;&#x27;)[0]);
      if (charset) value += &#x27;; charset=&#x27; + charset.toLowerCase();
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof id === &#x27;string&#x27;) {
  return id;
}
    }

    for (i = 0, length = headers.length; i &#x3c; length; i++) {
id = req.<span class="apidocCodeKeywordSpan">header</span>(headers[i]);

if (typeof id === &#x27;string&#x27;) {
  // Add support for oAuth 2.0 bearer token
  // http://tools.ietf.org/html/rfc6750
  if (id.indexOf(&#x27;Bearer &#x27;) === 0) {
    id = id.substring(7);
    // Decode from base64
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.json" id="apidoc.element.loopback.response.json">
        function <span class="apidocSignatureSpan">loopback.response.</span>json
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === &#x27;number&#x27;) {
      deprecate(&#x27;res.json(obj, status): Use res.status(status).json(obj) instead&#x27;);
      this.statusCode = arguments[1];
    } else {
      deprecate(&#x27;res.json(status, obj): Use res.status(status).json(obj) instead&#x27;);
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var replacer = app.get(&#x27;json replacer&#x27;);
  var spaces = app.get(&#x27;json spaces&#x27;);
  var body = stringify(val, replacer, spaces);

  // content-type
  if (!this.get(&#x27;Content-Type&#x27;)) {
    this.set(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
  }

  return this.send(body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.jsonp" id="apidoc.element.loopback.response.jsonp">
        function <span class="apidocSignatureSpan">loopback.response.</span>jsonp
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === &#x27;number&#x27;) {
      deprecate(&#x27;res.jsonp(obj, status): Use res.status(status).json(obj) instead&#x27;);
      this.statusCode = arguments[1];
    } else {
      deprecate(&#x27;res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead&#x27;);
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var replacer = app.get(&#x27;json replacer&#x27;);
  var spaces = app.get(&#x27;json spaces&#x27;);
  var body = stringify(val, replacer, spaces);
  var callback = this.req.query[app.get(&#x27;jsonp callback name&#x27;)];

  // content-type
  if (!this.get(&#x27;Content-Type&#x27;)) {
    this.set(&#x27;X-Content-Type-Options&#x27;, &#x27;nosniff&#x27;);
    this.set(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === &#x27;string&#x27; &#x26;&#x26; callback.length !== 0) {
    this.charset = &#x27;utf-8&#x27;;
    this.set(&#x27;X-Content-Type-Options&#x27;, &#x27;nosniff&#x27;);
    this.set(&#x27;Content-Type&#x27;, &#x27;text/javascript&#x27;);

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, &#x27;&#x27;);

    // replace chars not allowed in JavaScript that are in JSON
    body = body
      .replace(/\u2028/g, &#x27;\\u2028&#x27;)
      .replace(/\u2029/g, &#x27;\\u2029&#x27;);

    // the /**/ is a specific security mitigation for &#x22;Rosetta Flash JSONP abuse&#x22;
    // the typeof check is just to reduce client error noise
    body = &#x27;/**/ typeof &#x27; + callback + &#x27; === \&#x27;function\&#x27; &#x26;&#x26; &#x27; + callback + &#x27;(&#x27; + body + &#x27;);&#x27;;
  }

  return this.send(body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.links" id="apidoc.element.loopback.response.links">
        function <span class="apidocSignatureSpan">loopback.response.</span>links
        <span class="apidocSignatureSpan">(links)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">links = function (links){
  var link = this.get(&#x27;Link&#x27;) || &#x27;&#x27;;
  if (link) link += &#x27;, &#x27;;
  return this.set(&#x27;Link&#x27;, link + Object.keys(links).map(function(rel){
    return &#x27;&#x3c;&#x27; + links[rel] + &#x27;&#x3e;; rel=&#x22;&#x27; + rel + &#x27;&#x22;&#x27;;
  }).join(&#x27;, &#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.location" id="apidoc.element.loopback.response.location">
        function <span class="apidocSignatureSpan">loopback.response.</span>location
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function location(url) {
  var loc = url;

  // &#x22;back&#x22; is an alias for the referrer
  if (url === &#x27;back&#x27;) {
    loc = this.req.get(&#x27;Referrer&#x27;) || &#x27;/&#x27;;
  }

  // set location
  return this.set(&#x27;Location&#x27;, encodeUrl(loc));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
);

UserModel.afterRemote(&#x27;confirm&#x27;, function(ctx, inst, next) {
  if (ctx.args.redirect !== undefined) {
    if (!ctx.res) {
      return next(new Error(g.f(&#x27;The transport does not support HTTP redirects.&#x27;)));
    }
    ctx.res.<span class="apidocCodeKeywordSpan">location</span>(ctx.args.redirect);
    ctx.res.status(302);
  }
  next();
});

// default models
assert(loopback.Email, &#x27;Email model must be defined before User model&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.redirect" id="apidoc.element.loopback.response.redirect">
        function <span class="apidocSignatureSpan">loopback.response.</span>redirect
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === &#x27;number&#x27;) {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate(&#x27;res.redirect(url, status): Use res.redirect(status, url) instead&#x27;);
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get(&#x27;Location&#x27;);

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses[status] + &#x27;. Redirecting to &#x27; + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = &#x27;&#x3c;p&#x3e;&#x27; + statuses[status] + &#x27;. Redirecting to &#x3c;a href=&#x22;&#x27; + u + &#x27;&#x22;&#x3e;&#x27; + u + &#x27;&#x3c;/a&#x3e;&#x3c;/p&#x3e;&#x27;
    },

    default: function(){
      body = &#x27;&#x27;;
    }
  });

  // Respond
  this.statusCode = status;
  this.set(&#x27;Content-Length&#x27;, Buffer.byteLength(body));

  if (this.req.method === &#x27;HEAD&#x27;) {
    this.end();
  } else {
    this.end(body);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.render" id="apidoc.element.loopback.response.render">
        function <span class="apidocSignatureSpan">loopback.response.</span>render
        <span class="apidocSignatureSpan">(view, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === &#x27;function&#x27;) {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.send" id="apidoc.element.loopback.response.send">
        function <span class="apidocSignatureSpan">loopback.response.</span>send
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(body) {
  var chunk = body;
  var encoding;
  var len;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== &#x27;number&#x27; &#x26;&#x26; typeof arguments[1] === &#x27;number&#x27;) {
      deprecate(&#x27;res.send(body, status): Use res.status(status).send(body) instead&#x27;);
      this.statusCode = arguments[1];
    } else {
      deprecate(&#x27;res.send(status, body): Use res.status(status).send(body) instead&#x27;);
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === &#x27;number&#x27; &#x26;&#x26; arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get(&#x27;Content-Type&#x27;)) {
      this.type(&#x27;txt&#x27;);
    }

    deprecate(&#x27;res.send(status): Use res.sendStatus(status) instead&#x27;);
    this.statusCode = chunk;
    chunk = statuses[chunk]
  }

  switch (typeof chunk) {
    // string defaulting to html
    case &#x27;string&#x27;:
      if (!this.get(&#x27;Content-Type&#x27;)) {
        this.type(&#x27;html&#x27;);
      }
      break;
    case &#x27;boolean&#x27;:
    case &#x27;number&#x27;:
    case &#x27;object&#x27;:
      if (chunk === null) {
        chunk = &#x27;&#x27;;
      } else if (Buffer.isBuffer(chunk)) {
        if (!this.get(&#x27;Content-Type&#x27;)) {
          this.type(&#x27;bin&#x27;);
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === &#x27;string&#x27;) {
    encoding = &#x27;utf8&#x27;;
    type = this.get(&#x27;Content-Type&#x27;);

    // reflect this in content-type
    if (typeof type === &#x27;string&#x27;) {
      this.set(&#x27;Content-Type&#x27;, setCharset(type, &#x27;utf-8&#x27;));
    }
  }

  // populate Content-Length
  if (chunk !== undefined) {
    if (!Buffer.isBuffer(chunk)) {
      // convert chunk to Buffer; saves later double conversions
      chunk = new Buffer(chunk, encoding);
      encoding = undefined;
    }

    len = chunk.length;
    this.set(&#x27;Content-Length&#x27;, len);
  }

  // populate ETag
  var etag;
  var generateETag = len !== undefined &#x26;&#x26; app.get(&#x27;etag fn&#x27;);
  if (typeof generateETag === &#x27;function&#x27; &#x26;&#x26; !this.get(&#x27;ETag&#x27;)) {
    if ((etag = generateETag(chunk, encoding))) {
      this.set(&#x27;ETag&#x27;, etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader(&#x27;Content-Type&#x27;);
    this.removeHeader(&#x27;Content-Length&#x27;);
    this.removeHeader(&#x27;Transfer-Encoding&#x27;);
    chunk = &#x27;&#x27;;
  }

  if (req.method === &#x27;HEAD&#x27;) {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [Express documentation](http://expressjs.com/) for details.
*
* ```js
* var loopback = require(&#x27;loopback&#x27;);
* var app = loopback();
*
* app.get(&#x27;/&#x27;, function(req, res){
*   res.<span class="apidocCodeKeywordSpan">send</span>(&#x27;hello world&#x27;);
* });
*
* app.listen(3000);
* ```
*
* @class LoopBackApplication
* @header var app = loopback()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.sendFile" id="apidoc.element.loopback.response.sendFile">
        function <span class="apidocSignatureSpan">loopback.response.</span>sendFile
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError(&#x27;path argument is required to res.sendFile&#x27;);
  }

  // support function as second arg
  if (typeof options === &#x27;function&#x27;) {
    done = options;
    opts = {};
  }

  if (!opts.root &#x26;&#x26; !isAbsolute(path)) {
    throw new TypeError(&#x27;path must be absolute or specify root to res.sendFile&#x27;);
  }

  // create file stream
  var pathname = encodeURI(path);
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err &#x26;&#x26; err.code === &#x27;EISDIR&#x27;) return next();

    // next() all but write errors
    if (err &#x26;&#x26; err.code !== &#x27;ECONNABORTED&#x27; &#x26;&#x26; err.syscall !== &#x27;write&#x27;) {
      next(err);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.sendStatus" id="apidoc.element.loopback.response.sendStatus">
        function <span class="apidocSignatureSpan">loopback.response.</span>sendStatus
        <span class="apidocSignatureSpan">(statusCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sendStatus(statusCode) {
  var body = statuses[statusCode] || String(statusCode)

  this.statusCode = statusCode;
  this.type(&#x27;txt&#x27;);

  return this.send(body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.sendfile" id="apidoc.element.loopback.response.sendfile">
        function <span class="apidocSignatureSpan">loopback.response.</span>sendfile
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendfile = function (arg0, arg1, arg2) {
&#x22;use strict&#x22;
log.call(deprecate, message, site)
return fn.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.set" id="apidoc.element.loopback.response.set">
        function <span class="apidocSignatureSpan">loopback.response.</span>set
        <span class="apidocSignatureSpan">(field, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === &#x27;content-type&#x27; &#x26;&#x26; !charsetRegExp.test(value)) {
      var charset = mime.charsets.lookup(value.split(&#x27;;&#x27;)[0]);
      if (charset) value += &#x27;; charset=&#x27; + charset.toLowerCase();
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For example, to listen on the specified port and all hosts, and ignore app config.
* ```js
* app.listen(80);
* ```
*
* The function also installs a `listening` callback that calls
* `app.<span class="apidocCodeKeywordSpan">set</span>(&#x27;port&#x27;)` with the value returned by `server.address().port`.
* This way the port param contains always the real port number, even when
* listen was called with port number 0.
*
* @param {Function} [cb] If specified, the callback is added as a listener
*   for the server&#x27;s &#x22;listening&#x22; event.
* @returns {http.Server} A node `http.Server` with this application configured
*   as the request handler.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.status" id="apidoc.element.loopback.response.status">
        function <span class="apidocSignatureSpan">loopback.response.</span>status
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function status(code) {
  this.statusCode = code;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

UserModel.afterRemote(&#x27;confirm&#x27;, function(ctx, inst, next) {
  if (ctx.args.redirect !== undefined) {
    if (!ctx.res) {
      return next(new Error(g.f(&#x27;The transport does not support HTTP redirects.&#x27;)));
    }
    ctx.res.location(ctx.args.redirect);
    ctx.res.<span class="apidocCodeKeywordSpan">status</span>(302);
  }
  next();
});

// default models
assert(loopback.Email, &#x27;Email model must be defined before User model&#x27;);
UserModel.email = loopback.Email;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.type" id="apidoc.element.loopback.response.type">
        function <span class="apidocSignatureSpan">loopback.response.</span>type
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function contentType(type) {
  var ct = type.indexOf(&#x27;/&#x27;) === -1
    ? mime.lookup(type)
    : type;

  return this.set(&#x27;Content-Type&#x27;, ct);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    filter.where[idName] = {inq: ids};
    model.find(filter, function(err, models) {
      if (err) return callback(err);
      var modelIds = models.map(function(m) {
        return m[idName].toString();
      });
      callback(null, changes.filter(function(ch) {
        if (ch.<span class="apidocCodeKeywordSpan">type</span>() === Change.DELETE) return true;
        return modelIds.indexOf(ch.modelId) &#x3e; -1;
      }));
    });
  });
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.response.vary" id="apidoc.element.loopback.response.vary">
        function <span class="apidocSignatureSpan">loopback.response.</span>vary
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">vary = function (field){
  // checks for back-compat
  if (!field || (Array.isArray(field) &#x26;&#x26; !field.length)) {
    deprecate(&#x27;res.vary(): Provide a field name&#x27;);
    return this;
  }

  vary(this, field);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.loopback.utils" id="apidoc.module.loopback.utils">module loopback.utils</a></h1>


    <h2>
        <a href="#apidoc.element.loopback.utils.concatResults" id="apidoc.element.loopback.utils.concatResults">
        function <span class="apidocSignatureSpan">loopback.utils.</span>concatResults
        <span class="apidocSignatureSpan">(previousResults, currentResults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatResults(previousResults, currentResults) {
  if (Array.isArray(currentResults)) {
    previousResults = previousResults.concat(currentResults);
  } else if (typeof currentResults === &#x27;object&#x27;) {
    Object.keys(currentResults).forEach(function(key) {
      previousResults[key] = concatResults(previousResults[key], currentResults[key]);
    });
  } else {
    previousResults = currentResults;
  }

  return previousResults;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.utils.createPromiseCallback" id="apidoc.element.loopback.utils.createPromiseCallback">
        function <span class="apidocSignatureSpan">loopback.utils.</span>createPromiseCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPromiseCallback() {
  var cb;
  var promise = new Promise(function(resolve, reject) {
    cb = function(err, data) {
      if (err) return reject(err);
      return resolve(data);
    };
  });
  cb.promise = promise;
  return cb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof options === &#x27;function&#x27;) {
  options = {};
}

options = options || {};

var sourceModel = this;
callback = callback || utils.<span class="apidocCodeKeywordSpan">createPromiseCallback</span>();

debug(&#x27;replicating %s since %s to %s since %s&#x27;,
  sourceModel.modelName,
  since.source,
  targetModel.modelName,
  since.target);
if (options.filter) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.utils.downloadInChunks" id="apidoc.element.loopback.utils.downloadInChunks">
        function <span class="apidocSignatureSpan">loopback.utils.</span>downloadInChunks
        <span class="apidocSignatureSpan">(filter, chunkSize, processFunction, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function downloadInChunks(filter, chunkSize, processFunction, cb) {
  var results = [];
  filter = filter ? JSON.parse(JSON.stringify(filter)) : {};

  if (!chunkSize || chunkSize &#x3c; 1) {
    // if chunking not required
    processFunction(filter, cb);
  } else {
    filter.skip = 0;
    filter.limit = chunkSize;

    processFunction(JSON.parse(JSON.stringify(filter)), pageAndConcatResults);
  }

  function pageAndConcatResults(err, pagedResults) {
    if (err) {
      return cb(err);
    } else {
      results = concatResults(results, pagedResults);
      if (pagedResults.length &#x3e;= chunkSize) {
        filter.skip += pagedResults.length;
        processFunction(JSON.parse(JSON.stringify(filter)), pageAndConcatResults);
      } else {
        cb(null, results);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  createSourceUpdates,
  bulkUpdate,
];

async.waterfall(tasks, done);

function getSourceChanges(cb) {
  utils.<span class="apidocCodeKeywordSpan">downloadInChunks</span>(
    options.filter,
    replicationChunkSize,
    function(filter, pagingCallback) {
      sourceModel.changes(since.source, filter, pagingCallback);
    },
    debug.enabled ? log : cb);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.loopback.utils.uploadInChunks" id="apidoc.element.loopback.utils.uploadInChunks">
        function <span class="apidocSignatureSpan">loopback.utils.</span>uploadInChunks
        <span class="apidocSignatureSpan">(largeArray, chunkSize, processFunction, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uploadInChunks(largeArray, chunkSize, processFunction, cb) {
  var chunkArrays = [];

  if (!chunkSize || chunkSize &#x3c; 1 || largeArray.length &#x3c;= chunkSize) {
    // if chunking not required
    processFunction(largeArray, cb);
  } else {
    // copying so that the largeArray object does not get affected during splice
    var copyOfLargeArray = [].concat(largeArray);

    // chunking to smaller arrays
    while (copyOfLargeArray.length &#x3e; 0) {
      chunkArrays.push(copyOfLargeArray.splice(0, chunkSize));
    }

    var tasks = chunkArrays.map(function(chunkArray) {
      return function(previousResults, chunkCallback) {
        var lastArg = arguments[arguments.length - 1];

        if (typeof lastArg === &#x27;function&#x27;) {
          chunkCallback = lastArg;
        }

        processFunction(chunkArray, function(err, results) {
          if (err) {
            return chunkCallback(err);
          }

          // if this is the first async waterfall call or if previous results was not defined
          if (typeof previousResults === &#x27;function&#x27; || typeof previousResults === &#x27;undefined&#x27; ||
            previousResults === null) {
            previousResults = results;
          } else if (results) {
            previousResults = concatResults(previousResults, results);
          }

          chunkCallback(err, previousResults);
        });
      };
    });

    async.waterfall(tasks, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    debug(&#x27;\tusing source changes&#x27;);
    result.forEach(function(it) { debug(&#x27;\t\t%j&#x27;, it); });
    cb(err, result);
  }
}

function getDiffFromTarget(sourceChanges, cb) {
  utils.<span class="apidocCodeKeywordSpan">uploadInChunks</span>(
    sourceChanges,
    replicationChunkSize,
    function(smallArray, chunkCallback) {
      return targetModel.diff(since.target, smallArray, chunkCallback);
    },
    debug.enabled ? log : cb);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
